var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { c as commonjsGlobal, f as from$e, t as toString$8, a as fromString$8, r as rfc4648$9, b as baseX$9, d as create$c, e as coerce$9, g as base32$c, h as base58$3, i as getDefaultExportFromCjs, j as decode$R, k as base58btc$9, C as CID$9, l as base32$d } from "./_page-ca2722d0.js";
var getBrowserRtc = function getBrowserRTC2() {
  if (typeof globalThis === "undefined")
    return null;
  var wrtc = {
    RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
    RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
    RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
  };
  if (!wrtc.RTCPeerConnection)
    return null;
  return wrtc;
};
var events$1 = { exports: {} };
var R$1 = typeof Reflect === "object" ? Reflect : null;
var ReflectApply = R$1 && typeof R$1.apply === "function" ? R$1.apply : function ReflectApply2(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R$1 && typeof R$1.ownKeys === "function") {
  ReflectOwnKeys = R$1.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys2(target) {
    return Object.getOwnPropertyNames(target);
  };
}
function ProcessEmitWarning(warning) {
  if (console && console.warn)
    console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
  return value !== value;
};
function EventEmitter$4() {
  EventEmitter$4.init.call(this);
}
events$1.exports = EventEmitter$4;
events$1.exports.once = once;
EventEmitter$4.EventEmitter = EventEmitter$4;
EventEmitter$4.prototype._events = void 0;
EventEmitter$4.prototype._eventsCount = 0;
EventEmitter$4.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(listener) {
  if (typeof listener !== "function") {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}
Object.defineProperty(EventEmitter$4, "defaultMaxListeners", {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
    }
    defaultMaxListeners = arg;
  }
});
EventEmitter$4.init = function() {
  if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
  }
  this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$4.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
  }
  this._maxListeners = n;
  return this;
};
function _getMaxListeners(that) {
  if (that._maxListeners === void 0)
    return EventEmitter$4.defaultMaxListeners;
  return that._maxListeners;
}
EventEmitter$4.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};
EventEmitter$4.prototype.emit = function emit(type) {
  var args = [];
  for (var i2 = 1; i2 < arguments.length; i2++)
    args.push(arguments[i2]);
  var doError = type === "error";
  var events2 = this._events;
  if (events2 !== void 0)
    doError = doError && events2.error === void 0;
  else if (!doError)
    return false;
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      throw er;
    }
    var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
    err.context = er;
    throw err;
  }
  var handler = events2[type];
  if (handler === void 0)
    return false;
  if (typeof handler === "function") {
    ReflectApply(handler, this, args);
  } else {
    var len2 = handler.length;
    var listeners2 = arrayClone(handler, len2);
    for (var i2 = 0; i2 < len2; ++i2)
      ReflectApply(listeners2[i2], this, args);
  }
  return true;
};
function _addListener(target, type, listener, prepend) {
  var m;
  var events2;
  var existing;
  checkListener(listener);
  events2 = target._events;
  if (events2 === void 0) {
    events2 = target._events = /* @__PURE__ */ Object.create(null);
    target._eventsCount = 0;
  } else {
    if (events2.newListener !== void 0) {
      target.emit(
        "newListener",
        type,
        listener.listener ? listener.listener : listener
      );
      events2 = target._events;
    }
    existing = events2[type];
  }
  if (existing === void 0) {
    existing = events2[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === "function") {
      existing = events2[type] = prepend ? [listener, existing] : [existing, listener];
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      w.name = "MaxListenersExceededWarning";
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }
  return target;
}
EventEmitter$4.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};
EventEmitter$4.prototype.on = EventEmitter$4.prototype.addListener;
EventEmitter$4.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};
function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}
function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: void 0, target, type, listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}
EventEmitter$4.prototype.once = function once2(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$4.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
};
EventEmitter$4.prototype.removeListener = function removeListener(type, listener) {
  var list, events2, position, i2, originalListener;
  checkListener(listener);
  events2 = this._events;
  if (events2 === void 0)
    return this;
  list = events2[type];
  if (list === void 0)
    return this;
  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = /* @__PURE__ */ Object.create(null);
    else {
      delete events2[type];
      if (events2.removeListener)
        this.emit("removeListener", type, list.listener || listener);
    }
  } else if (typeof list !== "function") {
    position = -1;
    for (i2 = list.length - 1; i2 >= 0; i2--) {
      if (list[i2] === listener || list[i2].listener === listener) {
        originalListener = list[i2].listener;
        position = i2;
        break;
      }
    }
    if (position < 0)
      return this;
    if (position === 0)
      list.shift();
    else {
      spliceOne(list, position);
    }
    if (list.length === 1)
      events2[type] = list[0];
    if (events2.removeListener !== void 0)
      this.emit("removeListener", type, originalListener || listener);
  }
  return this;
};
EventEmitter$4.prototype.off = EventEmitter$4.prototype.removeListener;
EventEmitter$4.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners2, events2, i2;
  events2 = this._events;
  if (events2 === void 0)
    return this;
  if (events2.removeListener === void 0) {
    if (arguments.length === 0) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    } else if (events2[type] !== void 0) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else
        delete events2[type];
    }
    return this;
  }
  if (arguments.length === 0) {
    var keys = Object.keys(events2);
    var key;
    for (i2 = 0; i2 < keys.length; ++i2) {
      key = keys[i2];
      if (key === "removeListener")
        continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners("removeListener");
    this._events = /* @__PURE__ */ Object.create(null);
    this._eventsCount = 0;
    return this;
  }
  listeners2 = events2[type];
  if (typeof listeners2 === "function") {
    this.removeListener(type, listeners2);
  } else if (listeners2 !== void 0) {
    for (i2 = listeners2.length - 1; i2 >= 0; i2--) {
      this.removeListener(type, listeners2[i2]);
    }
  }
  return this;
};
function _listeners(target, type, unwrap2) {
  var events2 = target._events;
  if (events2 === void 0)
    return [];
  var evlistener = events2[type];
  if (evlistener === void 0)
    return [];
  if (typeof evlistener === "function")
    return unwrap2 ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap2 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter$4.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};
EventEmitter$4.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};
EventEmitter$4.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === "function") {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};
EventEmitter$4.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events2 = this._events;
  if (events2 !== void 0) {
    var evlistener = events2[type];
    if (typeof evlistener === "function") {
      return 1;
    } else if (evlistener !== void 0) {
      return evlistener.length;
    }
  }
  return 0;
}
EventEmitter$4.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i2 = 0; i2 < n; ++i2)
    copy[i2] = arr[i2];
  return copy;
}
function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}
function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i2 = 0; i2 < ret.length; ++i2) {
    ret[i2] = arr[i2].listener || arr[i2];
  }
  return ret;
}
function once(emitter, name2) {
  return new Promise(function(resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name2, resolver);
      reject(err);
    }
    function resolver() {
      if (typeof emitter.removeListener === "function") {
        emitter.removeListener("error", errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name2, resolver, { once: true });
    if (name2 !== "error") {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === "function") {
    eventTargetAgnosticAddListener(emitter, "error", handler, flags);
  }
}
function eventTargetAgnosticAddListener(emitter, name2, listener, flags) {
  if (typeof emitter.on === "function") {
    if (flags.once) {
      emitter.once(name2, listener);
    } else {
      emitter.on(name2, listener);
    }
  } else if (typeof emitter.addEventListener === "function") {
    emitter.addEventListener(name2, function wrapListener(arg) {
      if (flags.once) {
        emitter.removeEventListener(name2, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}
var browser = { exports: {} };
var ms$1;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs)
    return ms$1;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d2 = h * 24;
  var w = d2 * 7;
  var y = d2 * 365.25;
  ms$1 = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse2(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce2;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = requireMs();
  createDebug.destroy = destroy;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash2 = 0;
    for (let i2 = 0; i2 < namespace.length; i2++) {
      hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i2);
      hash2 |= 0;
    }
    return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug2(...args) {
      if (!debug2.enabled) {
        return;
      }
      const self2 = debug2;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format2) => {
        if (match === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format2];
        if (typeof formatter === "function") {
          const val = args[index];
          match = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.useColors = createDebug.useColors();
    debug2.color = createDebug.selectColor(namespace);
    debug2.extend = extend;
    debug2.destroy = createDebug.destroy;
    Object.defineProperty(debug2, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug2);
    }
    return debug2;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i2;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len2 = split.length;
    for (i2 = 0; i2 < len2; i2++) {
      if (!split[i2]) {
        continue;
      }
      namespaces = split[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name2) {
    if (name2[name2.length - 1] === "*") {
      return true;
    }
    let i2;
    let len2;
    for (i2 = 0, len2 = createDebug.skips.length; i2 < len2; i2++) {
      if (createDebug.skips[i2].test(name2)) {
        return false;
      }
    }
    for (i2 = 0, len2 = createDebug.names.length; i2 < len2; i2++) {
      if (createDebug.names[i2].test(name2)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce2(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common$1 = setup;
(function(module, exports) {
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module.exports = common$1(exports);
  const { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
})(browser, browser.exports);
const debug$1 = browser.exports;
var numbers = "0123456789", letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", specials = "!$%^&*()_+|~-=`{}[]:;<>?,./";
function _defaults(opts) {
  opts || (opts = {});
  return {
    length: opts.length || 8,
    numeric: typeof opts.numeric === "boolean" ? opts.numeric : true,
    letters: typeof opts.letters === "boolean" ? opts.letters : true,
    special: typeof opts.special === "boolean" ? opts.special : false,
    exclude: Array.isArray(opts.exclude) ? opts.exclude : []
  };
}
function _buildChars(opts) {
  var chars2 = "";
  if (opts.numeric) {
    chars2 += numbers;
  }
  if (opts.letters) {
    chars2 += letters;
  }
  if (opts.special) {
    chars2 += specials;
  }
  for (var i2 = 0; i2 <= opts.exclude.length; i2++) {
    chars2 = chars2.replace(opts.exclude[i2], "");
  }
  return chars2;
}
var randomString = function randomString2(opts) {
  opts = _defaults(opts);
  var i2, rn, rnd = "", len2 = opts.length;
  opts.exclude;
  var randomChars = _buildChars(opts);
  for (i2 = 1; i2 <= len2; i2++) {
    rnd += randomChars.substring(rn = Math.floor(Math.random() * randomChars.length), rn + 1);
  }
  return rnd;
};
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
let promise;
var queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : {}) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
  throw err;
}, 0));
function assign(obj, props) {
  for (const key in props) {
    Object.defineProperty(obj, key, {
      value: props[key],
      enumerable: true,
      configurable: true
    });
  }
  return obj;
}
function createError(err, code2, props) {
  if (!err || typeof err === "string") {
    throw new TypeError("Please pass an Error to err-code");
  }
  if (!props) {
    props = {};
  }
  if (typeof code2 === "object") {
    props = code2;
    code2 = "";
  }
  if (code2) {
    props.code = code2;
  }
  try {
    return assign(err, props);
  } catch (_2) {
    props.message = err.message;
    props.stack = err.stack;
    const ErrClass = function() {
    };
    ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
    const output = assign(new ErrClass(), props);
    return output;
  }
}
var errCode$1 = createError;
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
const debug = browser.exports("simple-peer");
const getBrowserRTC = getBrowserRtc;
const randomstring$1 = randomString;
const queueMicrotask$2 = queueMicrotask_1;
const EventEmitter$3 = events$1.exports;
const errCode = errCode$1;
const MAX_BUFFERED_AMOUNT = 64 * 1024;
const ICECOMPLETE_TIMEOUT = 5 * 1e3;
const CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
function filterTrickle(sdp) {
  return sdp.replace(/a=ice-options:trickle\s\n/g, "");
}
function warn(message) {
  console.warn(message);
}
class Peer$1 extends EventEmitter$3 {
  constructor(opts) {
    opts = Object.assign({
      allowHalfOpen: false
    }, opts);
    super(opts);
    this.id = opts.id || randomstring$1({ length: 20 });
    this._debug("new peer %o", opts);
    this.channelName = opts.initiator ? opts.channelName || randomstring$1({ length: 20 }) : null;
    this.initiator = opts.initiator || false;
    this.channelConfig = opts.channelConfig || Peer$1.channelConfig;
    this.channelNegotiated = this.channelConfig.negotiated;
    this.config = Object.assign({}, Peer$1.config, opts.config);
    this.proprietaryConstraints = Object.assign({}, Peer$1.proprietaryConstraints, opts.proprietaryConstraints);
    this.offerOptions = opts.offerOptions || {};
    this.answerOptions = opts.answerOptions || {};
    this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
    this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
    this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
    this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
    this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
    this.destroyed = false;
    this.destroying = false;
    this._connected = false;
    this.remoteAddress = void 0;
    this.remoteFamily = void 0;
    this.remotePort = void 0;
    this.localAddress = void 0;
    this.localFamily = void 0;
    this.localPort = void 0;
    this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
    if (!this._wrtc) {
      if (typeof window === "undefined") {
        throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
      } else {
        throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
      }
    }
    this._pcReady = false;
    this._channelReady = false;
    this._iceComplete = false;
    this._iceCompleteTimer = null;
    this._channel = null;
    this._pendingCandidates = [];
    this._isNegotiating = false;
    this._firstNegotiation = true;
    this._batchedNegotiation = false;
    this._queuedNegotiation = false;
    this._sendersAwaitingStable = [];
    this._senderMap = /* @__PURE__ */ new Map();
    this._closingInterval = null;
    this._remoteTracks = [];
    this._remoteStreams = [];
    this._chunk = null;
    this._cb = null;
    this._interval = null;
    try {
      this._pc = new this._wrtc.RTCPeerConnection(this.config, this.proprietaryConstraints);
    } catch (err) {
      this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR"));
      return;
    }
    this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
    this._pc.oniceconnectionstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onicegatheringstatechange = () => {
      this._onIceStateChange();
    };
    this._pc.onconnectionstatechange = () => {
      this._onConnectionStateChange();
    };
    this._pc.onsignalingstatechange = () => {
      this._onSignalingStateChange();
    };
    this._pc.onicecandidate = (event) => {
      this._onIceCandidate(event);
    };
    if (typeof this._pc.peerIdentity === "object") {
      this._pc.peerIdentity.catch((err) => {
        this.destroy(errCode(err, "ERR_PC_PEER_IDENTITY"));
      });
    }
    if (this.initiator || this.channelNegotiated) {
      this._setupData({
        channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
      });
    } else {
      this._pc.ondatachannel = (event) => {
        this._setupData(event);
      };
    }
    if (this.streams) {
      this.streams.forEach((stream) => {
        this.addStream(stream);
      });
    }
    this._pc.ontrack = (event) => {
      this._onTrack(event);
    };
    this._debug("initial negotiation");
    this._needsNegotiation();
    this._onFinishBound = () => {
      this._onFinish();
    };
    this.once("finish", this._onFinishBound);
  }
  get bufferSize() {
    return this._channel && this._channel.bufferedAmount || 0;
  }
  get connected() {
    return this._connected && this._channel.readyState === "open";
  }
  address() {
    return { port: this.localPort, family: this.localFamily, address: this.localAddress };
  }
  signal(data) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
    if (typeof data === "string") {
      try {
        data = JSON.parse(data);
      } catch (err) {
        data = {};
      }
    }
    this._debug("signal()");
    if (data.renegotiate && this.initiator) {
      this._debug("got request to renegotiate");
      this._needsNegotiation();
    }
    if (data.transceiverRequest && this.initiator) {
      this._debug("got request for transceiver");
      this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
    }
    if (data.candidate) {
      if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
        this._addIceCandidate(data.candidate);
      } else {
        this._pendingCandidates.push(data.candidate);
      }
    }
    if (data.sdp) {
      this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
        if (this.destroyed)
          return;
        this._pendingCandidates.forEach((candidate) => {
          this._addIceCandidate(candidate);
        });
        this._pendingCandidates = [];
        if (this._pc.remoteDescription.type === "offer")
          this._createAnswer();
      }).catch((err) => {
        this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
      });
    }
    if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
      this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
    }
  }
  _addIceCandidate(candidate) {
    const iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
    this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
      if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
        warn("Ignoring unsupported ICE candidate.");
      } else {
        this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
      }
    });
  }
  send(chunk) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
    this._channel.send(chunk);
  }
  addTransceiver(kind, init) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addTransceiver()");
    if (this.initiator) {
      try {
        this._pc.addTransceiver(kind, init);
        this._needsNegotiation();
      } catch (err) {
        this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
      }
    } else {
      this.emit("signal", {
        type: "transceiverRequest",
        transceiverRequest: { kind, init }
      });
    }
  }
  addStream(stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addStream()");
    stream.getTracks().forEach((track) => {
      this.addTrack(track, stream);
    });
  }
  addTrack(track, stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("addTrack()");
    const submap = this._senderMap.get(track) || /* @__PURE__ */ new Map();
    let sender = submap.get(stream);
    if (!sender) {
      sender = this._pc.addTrack(track, stream);
      submap.set(stream, sender);
      this._senderMap.set(track, submap);
      this._needsNegotiation();
    } else if (sender.removed) {
      throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
    } else {
      throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
    }
  }
  replaceTrack(oldTrack, newTrack, stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("replaceTrack()");
    const submap = this._senderMap.get(oldTrack);
    const sender = submap ? submap.get(stream) : null;
    if (!sender) {
      throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
    }
    if (newTrack)
      this._senderMap.set(newTrack, submap);
    if (sender.replaceTrack != null) {
      sender.replaceTrack(newTrack);
    } else {
      this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
    }
  }
  removeTrack(track, stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
    this._debug("removeSender()");
    const submap = this._senderMap.get(track);
    const sender = submap ? submap.get(stream) : null;
    if (!sender) {
      throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
    }
    try {
      sender.removed = true;
      this._pc.removeTrack(sender);
    } catch (err) {
      if (err.name === "NS_ERROR_UNEXPECTED") {
        this._sendersAwaitingStable.push(sender);
      } else {
        this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
      }
    }
    this._needsNegotiation();
  }
  removeStream(stream) {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
    this._debug("removeSenders()");
    stream.getTracks().forEach((track) => {
      this.removeTrack(track, stream);
    });
  }
  _needsNegotiation() {
    this._debug("_needsNegotiation");
    if (this._batchedNegotiation)
      return;
    this._batchedNegotiation = true;
    queueMicrotask$2(() => {
      this._batchedNegotiation = false;
      if (this.initiator || !this._firstNegotiation) {
        this._debug("starting batched negotiation");
        this.negotiate();
      } else {
        this._debug("non-initiator initial negotiation request discarded");
      }
      this._firstNegotiation = false;
    });
  }
  negotiate() {
    if (this.destroying)
      return;
    if (this.destroyed)
      throw errCode(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
    if (this.initiator) {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("start negotiation");
        setTimeout(() => {
          this._createOffer();
        }, 0);
      }
    } else {
      if (this._isNegotiating) {
        this._queuedNegotiation = true;
        this._debug("already negotiating, queueing");
      } else {
        this._debug("requesting negotiation from initiator");
        this.emit("signal", {
          type: "renegotiate",
          renegotiate: true
        });
      }
    }
    this._isNegotiating = true;
  }
  destroy(err) {
    this._destroy(err, () => {
    });
  }
  _destroy(err, cb) {
    if (this.destroyed || this.destroying)
      return;
    this.destroying = true;
    this._debug("destroying (error: %s)", err && (err.message || err));
    queueMicrotask$2(() => {
      this.destroyed = true;
      this.destroying = false;
      this._debug("destroy (error: %s)", err && (err.message || err));
      this._connected = false;
      this._pcReady = false;
      this._channelReady = false;
      this._remoteTracks = null;
      this._remoteStreams = null;
      this._senderMap = null;
      clearInterval(this._closingInterval);
      this._closingInterval = null;
      clearInterval(this._interval);
      this._interval = null;
      this._chunk = null;
      this._cb = null;
      if (this._onFinishBound)
        this.removeListener("finish", this._onFinishBound);
      this._onFinishBound = null;
      if (this._channel) {
        try {
          this._channel.close();
        } catch (err2) {
        }
        this._channel.onmessage = null;
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch (err2) {
        }
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ontrack = null;
        this._pc.ondatachannel = null;
      }
      this._pc = null;
      this._channel = null;
      if (err)
        this.emit("error", err);
      this.emit("close");
      cb();
    });
  }
  _setupData(event) {
    if (!event.channel) {
      return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
    }
    this._channel = event.channel;
    this._channel.binaryType = "arraybuffer";
    if (typeof this._channel.bufferedAmountLowThreshold === "number") {
      this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
    }
    this.channelName = this._channel.label;
    this._channel.onmessage = (event2) => {
      this._onChannelMessage(event2);
    };
    this._channel.onbufferedamountlow = () => {
      this._onChannelBufferedAmountLow();
    };
    this._channel.onopen = () => {
      this._onChannelOpen();
    };
    this._channel.onclose = () => {
      this._onChannelClose();
    };
    this._channel.onerror = (event2) => {
      const err = event2.error instanceof Error ? event2.error : new Error(`Datachannel error: ${event2.message} ${event2.filename}:${event2.lineno}:${event2.colno}`);
      this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
    };
    let isClosing = false;
    this._closingInterval = setInterval(() => {
      if (this._channel && this._channel.readyState === "closing") {
        if (isClosing)
          this._onChannelClose();
        isClosing = true;
      } else {
        isClosing = false;
      }
    }, CHANNEL_CLOSING_TIMEOUT);
  }
  _read() {
  }
  _write(chunk, encoding2, cb) {
    if (this.destroyed)
      return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
    if (this._connected) {
      try {
        this.send(chunk);
      } catch (err) {
        return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
      }
      if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        this._cb = cb;
      } else {
        cb(null);
      }
    } else {
      this._debug("write before connect");
      this._chunk = chunk;
      this._cb = cb;
    }
  }
  _onFinish() {
    if (this.destroyed)
      return;
    const destroySoon = () => {
      setTimeout(() => this.destroy(), 1e3);
    };
    if (this._connected) {
      destroySoon();
    } else {
      this.once("connect", destroySoon);
    }
  }
  _startIceCompleteTimeout() {
    if (this.destroyed)
      return;
    if (this._iceCompleteTimer)
      return;
    this._debug("started iceComplete timeout");
    this._iceCompleteTimer = setTimeout(() => {
      if (!this._iceComplete) {
        this._iceComplete = true;
        this._debug("iceComplete timeout completed");
        this.emit("iceTimeout");
        this.emit("_iceComplete");
      }
    }, this.iceCompleteTimeout);
  }
  _createOffer() {
    if (this.destroyed)
      return;
    this._pc.createOffer(this.offerOptions).then((offer) => {
      if (this.destroyed)
        return;
      if (!this.trickle && !this.allowHalfTrickle)
        offer.sdp = filterTrickle(offer.sdp);
      offer.sdp = this.sdpTransform(offer.sdp);
      const sendOffer = () => {
        if (this.destroyed)
          return;
        const signal = this._pc.localDescription || offer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
      };
      const onSuccess = () => {
        this._debug("createOffer success");
        if (this.destroyed)
          return;
        if (this.trickle || this._iceComplete)
          sendOffer();
        else
          this.once("_iceComplete", sendOffer);
      };
      const onError = (err) => {
        this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
    }).catch((err) => {
      this.destroy(errCode(err, "ERR_CREATE_OFFER"));
    });
  }
  _requestMissingTransceivers() {
    if (this._pc.getTransceivers) {
      this._pc.getTransceivers().forEach((transceiver) => {
        if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
          transceiver.requested = true;
          this.addTransceiver(transceiver.sender.track.kind);
        }
      });
    }
  }
  _createAnswer() {
    if (this.destroyed)
      return;
    this._pc.createAnswer(this.answerOptions).then((answer) => {
      if (this.destroyed)
        return;
      if (!this.trickle && !this.allowHalfTrickle)
        answer.sdp = filterTrickle(answer.sdp);
      answer.sdp = this.sdpTransform(answer.sdp);
      const sendAnswer = () => {
        if (this.destroyed)
          return;
        const signal = this._pc.localDescription || answer;
        this._debug("signal");
        this.emit("signal", {
          type: signal.type,
          sdp: signal.sdp
        });
        if (!this.initiator)
          this._requestMissingTransceivers();
      };
      const onSuccess = () => {
        if (this.destroyed)
          return;
        if (this.trickle || this._iceComplete)
          sendAnswer();
        else
          this.once("_iceComplete", sendAnswer);
      };
      const onError = (err) => {
        this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
      };
      this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
    }).catch((err) => {
      this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
    });
  }
  _onConnectionStateChange() {
    if (this.destroyed)
      return;
    if (this._pc.connectionState === "failed") {
      this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
    }
  }
  _onIceStateChange() {
    if (this.destroyed)
      return;
    const iceConnectionState = this._pc.iceConnectionState;
    const iceGatheringState = this._pc.iceGatheringState;
    this._debug(
      "iceStateChange (connection: %s) (gathering: %s)",
      iceConnectionState,
      iceGatheringState
    );
    this.emit("iceStateChange", iceConnectionState, iceGatheringState);
    if (iceConnectionState === "connected" || iceConnectionState === "completed") {
      this._pcReady = true;
      this._maybeReady();
    }
    if (iceConnectionState === "failed") {
      this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
    }
    if (iceConnectionState === "closed") {
      this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
    }
  }
  getStats(cb) {
    const flattenValues = (report) => {
      if (Object.prototype.toString.call(report.values) === "[object Array]") {
        report.values.forEach((value) => {
          Object.assign(report, value);
        });
      }
      return report;
    };
    if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
      this._pc.getStats().then((res) => {
        const reports = [];
        res.forEach((report) => {
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err) => cb(err));
    } else if (this._pc.getStats.length > 0) {
      this._pc.getStats((res) => {
        if (this.destroyed)
          return;
        const reports = [];
        res.result().forEach((result) => {
          const report = {};
          result.names().forEach((name2) => {
            report[name2] = result.stat(name2);
          });
          report.id = result.id;
          report.type = result.type;
          report.timestamp = result.timestamp;
          reports.push(flattenValues(report));
        });
        cb(null, reports);
      }, (err) => cb(err));
    } else {
      cb(null, []);
    }
  }
  _maybeReady() {
    this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
    if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
      return;
    this._connecting = true;
    const findCandidatePair = () => {
      if (this.destroyed)
        return;
      this.getStats((err, items) => {
        if (this.destroyed)
          return;
        if (err)
          items = [];
        const remoteCandidates = {};
        const localCandidates = {};
        const candidatePairs = {};
        let foundSelectedCandidatePair = false;
        items.forEach((item) => {
          if (item.type === "remotecandidate" || item.type === "remote-candidate") {
            remoteCandidates[item.id] = item;
          }
          if (item.type === "localcandidate" || item.type === "local-candidate") {
            localCandidates[item.id] = item;
          }
          if (item.type === "candidatepair" || item.type === "candidate-pair") {
            candidatePairs[item.id] = item;
          }
        });
        const setSelectedCandidatePair = (selectedCandidatePair) => {
          foundSelectedCandidatePair = true;
          let local = localCandidates[selectedCandidatePair.localCandidateId];
          if (local && (local.ip || local.address)) {
            this.localAddress = local.ip || local.address;
            this.localPort = Number(local.port);
          } else if (local && local.ipAddress) {
            this.localAddress = local.ipAddress;
            this.localPort = Number(local.portNumber);
          } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
            local = selectedCandidatePair.googLocalAddress.split(":");
            this.localAddress = local[0];
            this.localPort = Number(local[1]);
          }
          if (this.localAddress) {
            this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
          }
          let remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
          if (remote && (remote.ip || remote.address)) {
            this.remoteAddress = remote.ip || remote.address;
            this.remotePort = Number(remote.port);
          } else if (remote && remote.ipAddress) {
            this.remoteAddress = remote.ipAddress;
            this.remotePort = Number(remote.portNumber);
          } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
            remote = selectedCandidatePair.googRemoteAddress.split(":");
            this.remoteAddress = remote[0];
            this.remotePort = Number(remote[1]);
          }
          if (this.remoteAddress) {
            this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
          }
          this._debug(
            "connect local: %s:%s remote: %s:%s",
            this.localAddress,
            this.localPort,
            this.remoteAddress,
            this.remotePort
          );
        };
        items.forEach((item) => {
          if (item.type === "transport" && item.selectedCandidatePairId) {
            setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
          }
          if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
            setSelectedCandidatePair(item);
          }
        });
        if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
          setTimeout(findCandidatePair, 100);
          return;
        } else {
          this._connecting = false;
          this._connected = true;
        }
        if (this._chunk) {
          try {
            this.send(this._chunk);
          } catch (err2) {
            return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
          }
          this._chunk = null;
          this._debug('sent chunk from "write before connect"');
          const cb = this._cb;
          this._cb = null;
          cb(null);
        }
        if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
          this._interval = setInterval(() => this._onInterval(), 150);
          if (this._interval.unref)
            this._interval.unref();
        }
        this._debug("connect");
        this.emit("connect");
      });
    };
    findCandidatePair();
  }
  _onInterval() {
    if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
      return;
    }
    this._onChannelBufferedAmountLow();
  }
  _onSignalingStateChange() {
    if (this.destroyed)
      return;
    if (this._pc.signalingState === "stable") {
      this._isNegotiating = false;
      this._debug("flushing sender queue", this._sendersAwaitingStable);
      this._sendersAwaitingStable.forEach((sender) => {
        this._pc.removeTrack(sender);
        this._queuedNegotiation = true;
      });
      this._sendersAwaitingStable = [];
      if (this._queuedNegotiation) {
        this._debug("flushing negotiation queue");
        this._queuedNegotiation = false;
        this._needsNegotiation();
      } else {
        this._debug("negotiated");
        this.emit("negotiated");
      }
    }
    this._debug("signalingStateChange %s", this._pc.signalingState);
    this.emit("signalingStateChange", this._pc.signalingState);
  }
  _onIceCandidate(event) {
    if (this.destroyed)
      return;
    if (event.candidate && this.trickle) {
      this.emit("signal", {
        type: "candidate",
        candidate: {
          candidate: event.candidate.candidate,
          sdpMLineIndex: event.candidate.sdpMLineIndex,
          sdpMid: event.candidate.sdpMid
        }
      });
    } else if (!event.candidate && !this._iceComplete) {
      this._iceComplete = true;
      this.emit("_iceComplete");
    }
    if (event.candidate) {
      this._startIceCompleteTimeout();
    }
  }
  _onChannelMessage(event) {
    if (this.destroyed)
      return;
    this.emit("data", event.data);
  }
  _onChannelBufferedAmountLow() {
    if (this.destroyed || !this._cb)
      return;
    this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
    const cb = this._cb;
    this._cb = null;
    cb(null);
  }
  _onChannelOpen() {
    if (this._connected || this.destroyed)
      return;
    this._debug("on channel open");
    this._channelReady = true;
    this._maybeReady();
  }
  _onChannelClose() {
    if (this.destroyed)
      return;
    this._debug("on channel close");
    this.destroy();
  }
  _onTrack(event) {
    if (this.destroyed)
      return;
    const { track, receiver, streams } = event;
    streams.forEach((eventStream) => {
      this._debug("on track");
      this.emit("track", track, eventStream, receiver);
      this._remoteTracks.push({ track, stream: eventStream });
      if (this._remoteStreams.some((remoteStream) => {
        return remoteStream.id === eventStream.id;
      }))
        return;
      this._remoteStreams.push(eventStream);
      queueMicrotask$2(() => {
        this._debug("on stream");
        this.emit("stream", eventStream, receiver);
      });
    });
  }
  _debug() {
    const args = [].slice.call(arguments);
    args[0] = "[" + this.id + "] " + args[0];
    debug.apply(null, args);
  }
}
Peer$1.WEBRTC_SUPPORT = !!getBrowserRTC();
Peer$1.config = {
  iceServers: [
    {
      urls: [
        "stun:stun.l.google.com:19302",
        "stun:{}.stun.twilio.com:3478"
      ]
    }
  ],
  sdpSemantics: "unified-plan"
};
Peer$1.channelConfig = {};
Peer$1.proprietaryConstraints = {};
var tinySimplePeer = Peer$1;
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars.length; i$1++) {
  lookup$2[chars.charCodeAt(i$1)] = i$1;
}
var encode$D = function(arraybuffer) {
  var bytes2 = new Uint8Array(arraybuffer), i2, len2 = bytes2.length, base642 = "";
  for (i2 = 0; i2 < len2; i2 += 3) {
    base642 += chars[bytes2[i2] >> 2];
    base642 += chars[(bytes2[i2] & 3) << 4 | bytes2[i2 + 1] >> 4];
    base642 += chars[(bytes2[i2 + 1] & 15) << 2 | bytes2[i2 + 2] >> 6];
    base642 += chars[bytes2[i2 + 2] & 63];
  }
  if (len2 % 3 === 2) {
    base642 = base642.substring(0, base642.length - 1) + "=";
  } else if (len2 % 3 === 1) {
    base642 = base642.substring(0, base642.length - 2) + "==";
  }
  return base642;
};
var decode$Q = function(base642) {
  var bufferLength = base642.length * 0.75, len2 = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var arraybuffer = new ArrayBuffer(bufferLength), bytes2 = new Uint8Array(arraybuffer);
  for (i2 = 0; i2 < len2; i2 += 4) {
    encoded1 = lookup$2[base642.charCodeAt(i2)];
    encoded2 = lookup$2[base642.charCodeAt(i2 + 1)];
    encoded3 = lookup$2[base642.charCodeAt(i2 + 2)];
    encoded4 = lookup$2[base642.charCodeAt(i2 + 3)];
    bytes2[p2++] = encoded1 << 2 | encoded2 >> 4;
    bytes2[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes2[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return arraybuffer;
};
var convertHex = { exports: {} };
(function(module) {
  !function(globals) {
    var convertHex2 = {
      bytesToHex: function(bytes2) {
        return arrBytesToHex(bytes2);
      },
      hexToBytes: function(hex) {
        if (hex.length % 2 === 1)
          throw new Error("hexToBytes can't have a string with an odd number of characters.");
        if (hex.indexOf("0x") === 0)
          hex = hex.slice(2);
        return hex.match(/../g).map(function(x2) {
          return parseInt(x2, 16);
        });
      }
    };
    function arrBytesToHex(bytes2) {
      return bytes2.map(function(x2) {
        return padLeft(x2.toString(16), 2);
      }).join("");
    }
    function padLeft(orig, len2) {
      if (orig.length > len2)
        return orig;
      return Array(len2 - orig.length + 1).join("0") + orig;
    }
    if (module.exports) {
      module.exports = convertHex2;
    } else {
      globals.convertHex = convertHex2;
    }
  }(commonjsGlobal);
})(convertHex);
var arrayBufferToHex = function arrayBufferToHex2(arrayBuffer) {
  if (typeof arrayBuffer !== "object" || arrayBuffer === null || typeof arrayBuffer.byteLength !== "number") {
    throw new TypeError("Expected input to be an ArrayBuffer");
  }
  var view = new Uint8Array(arrayBuffer);
  var result = "";
  var value;
  for (var i2 = 0; i2 < view.length; i2++) {
    value = view[i2].toString(16);
    result += value.length === 1 ? "0" + value : value;
  }
  return result;
};
const CONNECT_TIMEOUT = 15e3;
const MAX_MESSAGE_LENGTH_BYTES = 16e3;
const CHUNK_HEADER_LENGTH_BYTES = 12;
const CHUNK_MAGIC_WORD = 8121;
const CHUNK_MAX_LENGTH_BYTES = MAX_MESSAGE_LENGTH_BYTES - CHUNK_HEADER_LENGTH_BYTES;
const SIGNAL_MESSAGE_HEADER_WORDS = [33451, 33229, 4757, 41419];
const CANDIDATE_TYPES = {
  host: 0,
  srflx: 1,
  relay: 2
};
const CANDIDATE_TCP_TYPES = {
  active: 0,
  passive: 1,
  so: 2
};
const CANDIDATE_IDX = {
  TYPE: 0,
  PROTOCOL: 1,
  IP: 2,
  PORT: 3,
  RELATED_IP: 4,
  RELATED_PORT: 5,
  TCP_TYPE: 6
};
const DEFAULT_STUN_ICE = [
  { urls: "stun:stun1.l.google.com:19302" },
  { urls: "stun:{}.stun.twilio.com:3478" }
];
const DEFAULT_TURN_ICE = [
  {
    urls: "turn:openrelay.metered.ca:80",
    username: "openrelayproject",
    credential: "openrelayproject"
  },
  {
    urls: "turn:openrelay.metered.ca:443",
    username: "openrelayproject",
    credential: "openrelayproject"
  },
  {
    urls: "turn:openrelay.metered.ca:443?transport=tcp",
    username: "openrelayproject",
    credential: "openrelayproject"
  }
];
const randomstring = (len2) => {
  const bytes2 = crypto.getRandomValues(new Uint8Array(len2));
  const str = bytes2.reduce((accum, v) => accum + String.fromCharCode(v), "");
  return btoa(str).replaceAll("=", "");
};
const textDecoder$4 = new TextDecoder("utf-8");
const textEncoder$6 = new TextEncoder();
const arrToText = textDecoder$4.decode.bind(textDecoder$4);
const textToArr = textEncoder$6.encode.bind(textEncoder$6);
const removeInPlace = (a2, condition) => {
  let i2 = 0;
  let j = 0;
  while (i2 < a2.length) {
    const val = a2[i2];
    if (!condition(val, i2, a2))
      a2[j++] = val;
    i2++;
  }
  a2.length = j;
  return a2;
};
const ua$1 = window.navigator.userAgent;
const iOS = !!ua$1.match(/iPad/i) || !!ua$1.match(/iPhone/i);
const webkit = !!ua$1.match(/WebKit/i);
const iOSSafari = !!(iOS && webkit && !ua$1.match(/CriOS/i));
const isFirefox = !!((navigator == null ? void 0 : navigator.userAgent.toLowerCase().indexOf("firefox")) > -1);
const hexToBase64 = (hex) => encode$D(convertHex.exports.hexToBytes(hex));
const base64ToHex = (b64) => arrayBufferToHex(decode$Q(b64));
function createSdp(isOffer, iceUFrag, icePwd, dtlsFingerprintBase64) {
  const dtlsHex = base64ToHex(dtlsFingerprintBase64);
  let dtlsFingerprint = "";
  for (let i2 = 0; i2 < dtlsHex.length; i2 += 2) {
    dtlsFingerprint += `${dtlsHex[i2]}${dtlsHex[i2 + 1]}${i2 === dtlsHex.length - 2 ? "" : ":"}`.toUpperCase();
  }
  const sdp = [
    "v=0",
    "o=- 5498186869896684180 2 IN IP4 127.0.0.1",
    "s=-",
    "t=0 0",
    "a=msid-semantic: WMS",
    "m=application 9 UDP/DTLS/SCTP webrtc-datachannel",
    "c=IN IP4 0.0.0.0",
    "a=mid:0",
    "a=sctp-port:5000"
  ];
  if (isOffer) {
    sdp.push("a=setup:actpass");
  } else {
    sdp.push("a=setup:active");
  }
  sdp.push(`a=ice-ufrag:${iceUFrag}`);
  sdp.push(`a=ice-pwd:${icePwd}`);
  sdp.push(`a=fingerprint:sha-256 ${dtlsFingerprint}`);
  return sdp.join("\r\n") + "\r\n";
}
const parseCandidate = (line) => {
  let parts;
  if (line.indexOf("a=candidate:") === 0) {
    parts = line.substring(12).split(" ");
  } else {
    parts = line.substring(10).split(" ");
  }
  const candidate = [
    CANDIDATE_TYPES[parts[7]],
    parts[2].toLowerCase() === "udp" ? 0 : 1,
    parts[4],
    parseInt(parts[5], 10)
  ];
  for (let i2 = 8; i2 < parts.length; i2 += 2) {
    switch (parts[i2]) {
      case "raddr":
        while (candidate.length < 5)
          candidate.push(null);
        candidate[4] = parts[i2 + 1];
        break;
      case "rport":
        while (candidate.length < 6)
          candidate.push(null);
        candidate[5] = parseInt(parts[i2 + 1], 10);
        break;
      case "tcptype":
        while (candidate.length < 7)
          candidate.push(null);
        candidate[6] = CANDIDATE_TCP_TYPES[parts[i2 + 1]];
        break;
    }
  }
  while (candidate.length < 8)
    candidate.push(null);
  candidate[7] = parseInt(parts[3], 10);
  return candidate;
};
class P2PCF extends events$1.exports {
  constructor(clientId = "", roomId = "", options = {}) {
    var _a2;
    super();
    if (!clientId || clientId.length < 4) {
      throw new Error("Client ID must be at least four characters");
    }
    if (!roomId || roomId.length < 4) {
      throw new Error("Room ID must be at least four characters");
    }
    this._step = this._step.bind(this);
    this.peers = /* @__PURE__ */ new Map();
    this.msgChunks = /* @__PURE__ */ new Map();
    this.connectedSessions = [];
    this.clientId = clientId;
    this.roomId = roomId;
    this.sessionId = randomstring(20);
    this.packages = [];
    this.dataTimestamp = null;
    this.lastPackages = null;
    this.lastProcessedReceivedDataTimestamps = /* @__PURE__ */ new Map();
    this.packageReceivedFromPeers = /* @__PURE__ */ new Set();
    this.startedAtTimestamp = null;
    this.peerOptions = options.rtcPeerConnectionOptions || {};
    this.peerProprietaryConstraints = options.rtcPeerConnectionProprietaryConstraints || {};
    this.peerSdpTransform = options.sdpTransform || ((sdp) => sdp);
    this.workerUrl = options.workerUrl || "https://p2pcf.minddrop.workers.dev";
    if (this.workerUrl.endsWith("/")) {
      this.workerUrl = this.workerUrl.substring(0, this.workerUrl.length - 1);
    }
    this.stunIceServers = options.stunIceServers || DEFAULT_STUN_ICE;
    this.turnIceServers = options.turnIceServers || DEFAULT_TURN_ICE;
    this.networkChangePollIntervalMs = options.networkChangePollIntervalMs || 15e3;
    this.stateExpirationIntervalMs = options.stateExpirationIntervalMs || 2 * 60 * 1e3;
    this.stateHeartbeatWindowMs = options.stateHeartbeatWindowMs || 3e4;
    this.fastPollingDurationMs = options.fastPollingDurationMs || 1e4;
    this.fastPollingRateMs = options.fastPollingRateMs || 750;
    this.slowPollingRateMs = options.slowPollingRateMs || 1500;
    this.wrtc = getBrowserRtc();
    this.dtlsCert = null;
    this.udpEnabled = null;
    this.isSymmetric = null;
    this.dtlsFingerprint = null;
    this.reflexiveIps = /* @__PURE__ */ new Set();
    this.isSending = false;
    this.finished = false;
    this.nextStepTime = -1;
    this.deleteKey = null;
    this.sentFirstPoll = false;
    this.stopFastPollingAt = -1;
    if (!((_a2 = window.history.state) == null ? void 0 : _a2._p2pcfContextId)) {
      window.history.replaceState(
        {
          ...window.history.state,
          _p2pcfContextId: randomstring(20)
        },
        window.location.href
      );
    }
    this.contextId = window.history.state._p2pcfContextId;
  }
  async _init() {
    if (this.dtlsCert === null) {
      this.dtlsCert = await this.wrtc.RTCPeerConnection.generateCertificate({
        name: "ECDSA",
        namedCurve: "P-256"
      });
    }
  }
  async _step(finish2 = false) {
    const {
      sessionId,
      clientId,
      roomId,
      contextId,
      stateExpirationIntervalMs,
      stateHeartbeatWindowMs,
      packages,
      fastPollingDurationMs,
      fastPollingRateMs,
      slowPollingRateMs
    } = this;
    const now = Date.now();
    if (finish2) {
      if (this.finished)
        return;
      if (!this.deleteKey)
        return;
      this.finished = true;
    } else {
      if (this.nextStepTime > now)
        return;
      if (this.isSending)
        return;
      if (this.reflexiveIps.length === 0)
        return;
    }
    this.isSending = true;
    try {
      const localDtlsFingerprintBase64 = hexToBase64(
        this.dtlsFingerprint.replaceAll(":", "")
      );
      const localPeerInfo = [
        sessionId,
        clientId,
        this.isSymmetric,
        localDtlsFingerprintBase64,
        this.startedAtTimestamp,
        [...this.reflexiveIps]
      ];
      const payload = { r: roomId, k: contextId };
      if (finish2) {
        payload.dk = this.deleteKey;
      }
      const expired = this.dataTimestamp === null || now - this.dataTimestamp >= stateExpirationIntervalMs - stateHeartbeatWindowMs;
      const packagesChanged = this.lastPackages !== JSON.stringify(packages);
      let includePackages = false;
      if (expired || packagesChanged || finish2) {
        this.dataTimestamp = now;
        removeInPlace(packages, (pkg) => {
          const sentAt = pkg[pkg.length - 2];
          return now - sentAt > 60 * 1e3;
        });
        includePackages = true;
      }
      if (finish2) {
        includePackages = false;
      }
      if (this.sentFirstPoll) {
        payload.d = localPeerInfo;
        payload.t = this.dataTimestamp;
        payload.x = this.stateExpirationIntervalMs;
        if (includePackages) {
          payload.p = packages;
          this.lastPackages = JSON.stringify(packages);
        }
      }
      const body = JSON.stringify(payload);
      const headers = { "Content-Type": "application/json " };
      let keepalive = false;
      if (finish2) {
        headers["X-Worker-Method"] = "DELETE";
        keepalive = true;
      }
      const res = await fetch(this.workerUrl, {
        method: "POST",
        headers,
        body,
        keepalive
      });
      const { ps: remotePeerDatas, pk: remotePackages, dk } = await res.json();
      if (dk) {
        this.deleteKey = dk;
      }
      if (finish2)
        return;
      if (remotePeerDatas.length === 0 && !this.sentFirstPoll) {
        payload.d = localPeerInfo;
        payload.t = this.dataTimestamp;
        payload.x = this.stateExpirationIntervalMs;
        payload.p = packages;
        this.lastPackages = JSON.stringify(packages);
        const res2 = await fetch(this.workerUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const { dk: dk2 } = await res2.json();
        if (dk2) {
          this.deleteKey = dk2;
        }
      }
      this.sentFirstPoll = true;
      const previousPeerSessionIds = [...this.peers.keys()];
      this._handleWorkerResponse(
        localPeerInfo,
        localDtlsFingerprintBase64,
        packages,
        remotePeerDatas,
        remotePackages
      );
      const activeSessionIds = remotePeerDatas.map((p2) => p2[0]);
      const peersChanged = previousPeerSessionIds.length !== activeSessionIds.length || activeSessionIds.find((c) => !previousPeerSessionIds.includes(c)) || previousPeerSessionIds.find((c) => !activeSessionIds.includes(c));
      if (peersChanged) {
        this.stopFastPollingAt = now + fastPollingDurationMs;
      }
      if (now < this.stopFastPollingAt) {
        this.nextStepTime = now + fastPollingRateMs;
      } else {
        this.nextStepTime = now + slowPollingRateMs;
      }
    } catch (e) {
      console.error(e);
      this.nextStepTime = now + slowPollingRateMs;
    } finally {
      this.isSending = false;
    }
  }
  _handleWorkerResponse(localPeerData, localDtlsFingerprintBase64, localPackages, remotePeerDatas, remotePackages) {
    const localStartedAtTimestamp = this.startedAtTimestamp;
    const {
      dtlsCert: localDtlsCert,
      peers,
      lastProcessedReceivedDataTimestamps,
      packageReceivedFromPeers,
      stunIceServers,
      turnIceServers
    } = this;
    const [localSessionId, , localSymmetric] = localPeerData;
    const now = Date.now();
    for (const remotePeerData of remotePeerDatas) {
      const [
        remoteSessionId,
        remoteClientId,
        remoteSymmetric,
        remoteDtlsFingerprintBase64,
        remoteStartedAtTimestamp,
        remoteReflexiveIps,
        remoteDataTimestamp
      ] = remotePeerData;
      if (lastProcessedReceivedDataTimestamps.get(remoteSessionId) === remoteDataTimestamp) {
        continue;
      }
      const isPeerA = localSymmetric === remoteSymmetric ? localStartedAtTimestamp === remoteStartedAtTimestamp ? localSessionId > remoteSessionId : localStartedAtTimestamp > remoteStartedAtTimestamp : localSymmetric;
      const iceServers = localSymmetric || remoteSymmetric ? turnIceServers : stunIceServers;
      const delaySetRemoteUntilReceiveCandidates = isFirefox;
      const remotePackage = remotePackages.find((p2) => p2[1] === remoteSessionId);
      const peerOptions = { ...this.peerOptions, iceServers };
      if (localDtlsCert) {
        peerOptions.certificates = [localDtlsCert];
      }
      if (isPeerA) {
        if (peers.has(remoteSessionId))
          continue;
        if (!remotePackage)
          continue;
        lastProcessedReceivedDataTimestamps.set(
          remoteSessionId,
          remoteDataTimestamp
        );
        if (packageReceivedFromPeers.has(remoteSessionId))
          continue;
        packageReceivedFromPeers.add(remoteSessionId);
        const [
          ,
          ,
          remoteIceUFrag,
          remoteIcePwd,
          remoteDtlsFingerprintBase642,
          localIceUFrag,
          localIcePwd,
          ,
          remoteCandidates
        ] = remotePackage;
        const peer = new tinySimplePeer({
          config: peerOptions,
          initiator: false,
          iceCompleteTimeout: Infinity,
          proprietaryConstraints: this.peerProprietaryConstraints,
          sdpTransform: (sdp) => {
            const lines = [];
            for (const l2 of sdp.split("\r\n")) {
              if (l2.startsWith("a=ice-ufrag")) {
                lines.push(`a=ice-ufrag:${localIceUFrag}`);
              } else if (l2.startsWith("a=ice-pwd")) {
                lines.push(`a=ice-pwd:${localIcePwd}`);
              } else {
                lines.push(l2);
              }
            }
            return this.peerSdpTransform(lines.join("\r\n"));
          }
        });
        peer.id = remoteSessionId;
        peer.client_id = remoteClientId;
        this._wireUpCommonPeerEvents(peer);
        peers.set(peer.id, peer);
        const pkg = [
          remoteSessionId,
          localSessionId,
          null,
          null,
          null,
          null,
          null,
          now,
          []
        ];
        const pkgCandidates = pkg[pkg.length - 1];
        const initialCandidateSignalling = (e) => {
          var _a2;
          if (!((_a2 = e.candidate) == null ? void 0 : _a2.candidate))
            return;
          pkgCandidates.push(e.candidate.candidate);
        };
        peer.on("signal", initialCandidateSignalling);
        const finishIce = () => {
          peer.removeListener("signal", initialCandidateSignalling);
          if (localPackages.includes(pkg))
            return;
          if (pkgCandidates.length === 0)
            return;
          localPackages.push(pkg);
        };
        peer.once("_iceComplete", finishIce);
        setTimeout(() => {
          if (peer._iceComplete || peer.connected)
            return;
          console.warn("Peer A didn't connect in time", peer.id);
          peer._iceComplete = true;
          this._removePeer(peer, true);
          this._updateConnectedSessions();
        }, CONNECT_TIMEOUT);
        const remoteSdp = createSdp(
          true,
          remoteIceUFrag,
          remoteIcePwd,
          remoteDtlsFingerprintBase642
        );
        for (const candidate of remoteCandidates) {
          peer.signal({ candidate: { candidate, sdpMLineIndex: 0 } });
        }
        peer.signal({ type: "offer", sdp: remoteSdp });
      } else {
        if (!peers.has(remoteSessionId)) {
          lastProcessedReceivedDataTimestamps.set(
            remoteSessionId,
            remoteDataTimestamp
          );
          const remoteUfrag = randomstring(12);
          const remotePwd = randomstring(32);
          const peer2 = new tinySimplePeer({
            config: peerOptions,
            proprietaryConstraints: this.rtcPeerConnectionProprietaryConstraints,
            iceCompleteTimeout: Infinity,
            initiator: true,
            sdpTransform: this.peerSdpTransform
          });
          peer2.id = remoteSessionId;
          peer2.client_id = remoteClientId;
          this._wireUpCommonPeerEvents(peer2);
          peers.set(peer2.id, peer2);
          const pkg = [
            remoteSessionId,
            localSessionId,
            null,
            null,
            null,
            remoteUfrag,
            remotePwd,
            now,
            []
          ];
          const pkgCandidates = pkg[pkg.length - 1];
          const initialCandidateSignalling = (e) => {
            var _a2;
            if (!((_a2 = e.candidate) == null ? void 0 : _a2.candidate))
              return;
            pkgCandidates.push(e.candidate.candidate);
          };
          peer2.on("signal", initialCandidateSignalling);
          const finishIce = () => {
            peer2.removeListener("signal", initialCandidateSignalling);
            if (localPackages.includes(pkg))
              return;
            if (pkgCandidates.length === 0)
              return;
            localPackages.push(pkg);
          };
          peer2.once("_iceComplete", finishIce);
          setTimeout(() => {
            if (peer2._iceComplete || peer2.connected)
              return;
            console.warn("Peer B failed to connect in time", peer2.id);
            peer2._iceComplete = true;
            this._removePeer(peer2, true);
            this._updateConnectedSessions();
          }, CONNECT_TIMEOUT);
          const enqueuePackageFromOffer = (e) => {
            if (e.type !== "offer")
              return;
            peer2.removeListener("signal", enqueuePackageFromOffer);
            for (const l2 of e.sdp.split("\r\n")) {
              switch (l2.split(":")[0]) {
                case "a=ice-ufrag":
                  pkg[2] = l2.substring(12);
                  break;
                case "a=ice-pwd":
                  pkg[3] = l2.substring(10);
                  break;
                case "a=fingerprint":
                  pkg[4] = hexToBase64(l2.substring(22).replaceAll(":", ""));
                  break;
              }
            }
            let remoteSdp = createSdp(
              false,
              remoteUfrag,
              remotePwd,
              remoteDtlsFingerprintBase64
            );
            for (let i2 = 0; i2 < remoteReflexiveIps.length; i2++) {
              remoteSdp += `a=candidate:0 1 udp ${i2 + 1} ${remoteReflexiveIps[i2]} 30000 typ srflx\r
`;
            }
            if (!delaySetRemoteUntilReceiveCandidates) {
              peer2.signal({ type: "answer", sdp: remoteSdp });
            } else {
              peer2._pendingRemoteSdp = remoteSdp;
            }
          };
          peer2.once("signal", enqueuePackageFromOffer);
        }
        if (!remotePackage)
          continue;
        const [, , , , , , , , remoteCandidates] = remotePackage;
        if (packageReceivedFromPeers.has(remoteSessionId))
          continue;
        if (!peers.has(remoteSessionId))
          continue;
        const peer = peers.get(remoteSessionId);
        if (delaySetRemoteUntilReceiveCandidates && !peer._pc.remoteDescription && peer._pendingRemoteSdp) {
          if (!peer.connected) {
            for (const candidate of remoteCandidates) {
              peer.signal({ candidate: { candidate, sdpMLineIndex: 0 } });
            }
          }
          peer.signal({ type: "answer", sdp: peer._pendingRemoteSdp });
          delete peer._pendingRemoteSdp;
          packageReceivedFromPeers.add(remoteSessionId);
        }
        if (!delaySetRemoteUntilReceiveCandidates && peer._pc.remoteDescription && remoteCandidates.length > 0) {
          if (!peer.connected) {
            for (const candidate of remoteCandidates) {
              peer.signal({ candidate: { candidate, sdpMLineIndex: 0 } });
            }
          }
          packageReceivedFromPeers.add(remoteSessionId);
        }
      }
    }
    const remoteSessionIds = remotePeerDatas.map((p2) => p2[0]);
    for (const [sessionId, peer] of peers.entries()) {
      if (remoteSessionIds.includes(sessionId))
        continue;
      if (!peer.connected) {
        console.warn("Removing unconnected peer not in peer list", peer.id);
        this._removePeer(peer, true);
      }
    }
  }
  async start() {
    this.startedAtTimestamp = Date.now();
    await this._init();
    const [
      udpEnabled,
      isSymmetric,
      reflexiveIps,
      dtlsFingerprint
    ] = await this._getNetworkSettings(this.dtlsCert);
    if (this.finished)
      return;
    this.udpEnabled = udpEnabled;
    this.isSymmetric = isSymmetric;
    this.reflexiveIps = reflexiveIps;
    this.dtlsFingerprint = dtlsFingerprint;
    this.networkSettingsInterval = setInterval(async () => {
      const [
        newUdpEnabled,
        newIsSymmetric,
        newReflexiveIps,
        newDtlsFingerprint
      ] = await this._getNetworkSettings(this.dtlsCert);
      if (newUdpEnabled !== this.udpEnabled || newIsSymmetric !== this.isSymmetric || newDtlsFingerprint !== this.dtlsFingerprint || !![...newReflexiveIps].find((ip) => ![...this.reflexiveIps].find((ip2) => ip === ip2)) || !![...reflexiveIps].find((ip) => ![...newReflexiveIps].find((ip2) => ip === ip2))) {
        this.dataTimestamp = null;
      }
      this.udpEnabled = newUdpEnabled;
      this.isSymmetric = newIsSymmetric;
      this.reflexiveIps = newReflexiveIps;
      this.dtlsFingerprint = newDtlsFingerprint;
    }, this.networkChangePollIntervalMs);
    this._step = this._step.bind(this);
    this.stepInterval = setInterval(this._step, 500);
    this.destroyOnUnload = () => this.destroy();
    for (const ev of iOSSafari ? ["pagehide"] : ["unload"]) {
      window.addEventListener(ev, this.destroyOnUnload);
    }
  }
  _removePeer(peer, destroy = false) {
    const { packageReceivedFromPeers, packages, peers } = this;
    if (!peers.has(peer.id))
      return;
    removeInPlace(packages, (pkg) => pkg[0] === peer.id);
    packageReceivedFromPeers.delete(peer.id);
    peers.delete(peer.id);
    if (destroy) {
      peer.destroy();
    }
    this.emit("peerclose", peer);
  }
  send(peer, msg) {
    if (!peer.connected)
      return;
    let dataArrBuffer = null;
    let messageId = null;
    if (msg instanceof ArrayBuffer) {
      dataArrBuffer = msg;
    } else if (msg instanceof Uint8Array) {
      if (msg.buffer.byteLength === msg.length) {
        dataArrBuffer = msg.buffer;
      } else {
        dataArrBuffer = msg.buffer.slice(msg.byteOffset, msg.byteOffset + msg.byteLength);
      }
    } else {
      throw new Error("Unsupported send data type", msg);
    }
    if (dataArrBuffer.byteLength > MAX_MESSAGE_LENGTH_BYTES || new Uint16Array(dataArrBuffer, 0, 1) === CHUNK_MAGIC_WORD) {
      messageId = Math.floor(Math.random() * 256 * 128);
    }
    if (messageId !== null) {
      for (let offset = 0, chunkId = 0; offset < dataArrBuffer.byteLength; offset += CHUNK_MAX_LENGTH_BYTES, chunkId++) {
        const chunkSize = Math.min(
          CHUNK_MAX_LENGTH_BYTES,
          dataArrBuffer.byteLength - offset
        );
        let bufSize = CHUNK_HEADER_LENGTH_BYTES + chunkSize;
        while (bufSize % 4 !== 0) {
          bufSize++;
        }
        const buf2 = new ArrayBuffer(bufSize);
        new Uint8Array(buf2, CHUNK_HEADER_LENGTH_BYTES).set(
          new Uint8Array(dataArrBuffer, offset, chunkSize)
        );
        const u16 = new Uint16Array(buf2);
        const u32 = new Uint32Array(buf2);
        u16[0] = CHUNK_MAGIC_WORD;
        u16[1] = messageId;
        u16[2] = chunkId;
        u16[3] = offset + CHUNK_MAX_LENGTH_BYTES >= dataArrBuffer.byteLength ? 1 : 0;
        u32[2] = dataArrBuffer.byteLength;
        peer.send(buf2);
      }
    } else {
      peer.send(dataArrBuffer);
    }
  }
  broadcast(msg) {
    for (const peer of this.peers.values()) {
      this.send(peer, msg);
    }
  }
  destroy() {
    if (this._step) {
      this._step(true);
    }
    if (this.networkSettingsInterval) {
      clearInterval(this.networkSettingsInterval);
      this.networkSettingsInterval = null;
    }
    if (this.stepInterval) {
      clearInterval(this.stepInterval);
      this.stepInterval = null;
    }
    if (this.destroyOnUnload) {
      for (const ev of iOSSafari ? ["pagehide"] : ["beforeunload", "unload"]) {
        window.removeEventListener(ev, this.destroyOnUnload);
      }
      this.destroyOnUnload = null;
    }
    for (const peer of this.peers.values()) {
      peer.destroy();
    }
  }
  _chunkHandler(data, messageId, chunkId) {
    let target = null;
    if (!this.msgChunks.has(messageId)) {
      const totalLength = new Uint32Array(data, 0, 3)[2];
      target = new Uint8Array(totalLength);
      this.msgChunks.set(messageId, target);
    } else {
      target = this.msgChunks.get(messageId);
    }
    const offsetToSet = chunkId * CHUNK_MAX_LENGTH_BYTES;
    const numBytesToSet = Math.min(
      target.byteLength - offsetToSet,
      CHUNK_MAX_LENGTH_BYTES
    );
    target.set(
      new Uint8Array(data, CHUNK_HEADER_LENGTH_BYTES, numBytesToSet),
      chunkId * CHUNK_MAX_LENGTH_BYTES
    );
    return target.buffer;
  }
  _updateConnectedSessions() {
    this.connectedSessions.length = 0;
    for (const [sessionId, peer] of this.peers) {
      if (peer.connected) {
        this.connectedSessions.push(sessionId);
        continue;
      }
    }
  }
  async _getNetworkSettings() {
    await this._init();
    let dtlsFingerprint = null;
    const candidates = [];
    const reflexiveIps = /* @__PURE__ */ new Set();
    const peerOptions = { iceServers: this.stunIceServers };
    if (this.dtlsCert) {
      peerOptions.certificates = [this.dtlsCert];
    }
    const pc = new this.wrtc.RTCPeerConnection(peerOptions);
    const dc = pc.createDataChannel("x");
    const p2 = new Promise((resolve) => {
      setTimeout(() => resolve(), 5e3);
      pc.onicecandidate = (e) => {
        if (!e.candidate)
          return resolve();
        if (e.candidate.candidate) {
          candidates.push(parseCandidate(e.candidate.candidate));
        }
      };
    });
    pc.createOffer().then((offer) => {
      for (const l2 of offer.sdp.split("\n")) {
        if (l2.indexOf("a=fingerprint") === -1)
          continue;
        dtlsFingerprint = l2.split(" ")[1].trim();
      }
      pc.setLocalDescription(offer);
    });
    await p2;
    dc.close();
    pc.close();
    let isSymmetric = false;
    let udpEnabled = false;
    for (const c of candidates) {
      if (c[0] !== CANDIDATE_TYPES.srflx)
        continue;
      udpEnabled = true;
      reflexiveIps.add(c[CANDIDATE_IDX.IP]);
      for (const d2 of candidates) {
        if (d2[0] !== CANDIDATE_TYPES.srflx)
          continue;
        if (c === d2)
          continue;
        if (typeof c[CANDIDATE_IDX.RELATED_PORT] === "number" && typeof d2[CANDIDATE_IDX.RELATED_PORT] === "number" && c[CANDIDATE_IDX.RELATED_PORT] === d2[CANDIDATE_IDX.RELATED_PORT] && c[CANDIDATE_IDX.PORT] !== d2[CANDIDATE_IDX.PORT]) {
          isSymmetric = true;
          break;
        }
      }
    }
    return [udpEnabled, isSymmetric, reflexiveIps, dtlsFingerprint];
  }
  _handlePeerError(peer, err) {
    if (err.errorDetail === "sctp-failure" && err.message.indexOf("User-Initiated Abort") >= 0) {
      return;
    }
    console.error(err);
  }
  _checkForSignalOrEmitMessage(peer, msg) {
    if (msg.byteLength < SIGNAL_MESSAGE_HEADER_WORDS.length * 2) {
      this.emit("msg", peer, msg);
      return;
    }
    const u16 = new Uint16Array(msg, 0, SIGNAL_MESSAGE_HEADER_WORDS.length);
    for (let i2 = 0; i2 < SIGNAL_MESSAGE_HEADER_WORDS.length; i2++) {
      if (u16[i2] !== SIGNAL_MESSAGE_HEADER_WORDS[i2]) {
        this.emit("msg", peer, msg);
        return;
      }
    }
    const u8 = new Uint8Array(msg, SIGNAL_MESSAGE_HEADER_WORDS.length * 2);
    let payload = arrToText(u8);
    if (payload.endsWith("\0")) {
      payload = payload.substring(0, payload.length - 1);
    }
    peer.signal(payload);
  }
  _wireUpCommonPeerEvents(peer) {
    peer.on("connect", () => {
      this.emit("peerconnect", peer);
      removeInPlace(this.packages, (pkg) => pkg[0] === peer.id);
      this._updateConnectedSessions();
    });
    peer.on("data", (data) => {
      let messageId = null;
      let u16 = null;
      if (data.byteLength >= CHUNK_HEADER_LENGTH_BYTES) {
        u16 = new Uint16Array(data, 0, CHUNK_HEADER_LENGTH_BYTES / 2);
        if (u16[0] === CHUNK_MAGIC_WORD) {
          messageId = u16[1];
        }
      }
      if (messageId !== null) {
        try {
          const chunkId = u16[2];
          const last = u16[3] !== 0;
          const msg = this._chunkHandler(data, messageId, chunkId, last);
          if (last) {
            this._checkForSignalOrEmitMessage(peer, msg);
            this.msgChunks.delete(messageId);
          }
        } catch (e) {
          console.error(e);
        }
      } else {
        this._checkForSignalOrEmitMessage(peer, data);
      }
    });
    peer.on("error", (err) => {
      console.warn(err);
    });
    peer.on("close", () => {
      this._removePeer(peer);
      this._updateConnectedSessions();
    });
    peer.on("signal", (signalData) => {
      const payloadBytes = textToArr(
        JSON.stringify(signalData)
      );
      let len2 = payloadBytes.byteLength + SIGNAL_MESSAGE_HEADER_WORDS.length * 2;
      if (len2 % 2 !== 0) {
        len2++;
      }
      const buf2 = new ArrayBuffer(len2);
      const u8 = new Uint8Array(buf2);
      const u16 = new Uint16Array(buf2);
      u8.set(payloadBytes, SIGNAL_MESSAGE_HEADER_WORDS.length * 2);
      for (let i2 = 0; i2 < SIGNAL_MESSAGE_HEADER_WORDS.length; i2++) {
        u16[i2] = SIGNAL_MESSAGE_HEADER_WORDS[i2];
      }
      this.send(peer, buf2);
    });
  }
}
var encode_1$9 = encode$C;
var MSB$b = 128, REST$b = 127, MSBALL$9 = ~REST$b, INT$9 = Math.pow(2, 31);
function encode$C(num, out, offset) {
  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
    encode$C.bytes = 0;
    throw new RangeError("Could not encode varint");
  }
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$9) {
    out[offset++] = num & 255 | MSB$b;
    num /= 128;
  }
  while (num & MSBALL$9) {
    out[offset++] = num & 255 | MSB$b;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$C.bytes = offset - oldOffset + 1;
  return out;
}
var decode$P = read$9;
var MSB$a = 128, REST$a = 127;
function read$9(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2 || shift > 49) {
      read$9.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$a) << shift : (b2 & REST$a) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$a);
  read$9.bytes = counter - offset;
  return res;
}
var N1$9 = Math.pow(2, 7);
var N2$9 = Math.pow(2, 14);
var N3$9 = Math.pow(2, 21);
var N4$9 = Math.pow(2, 28);
var N5$9 = Math.pow(2, 35);
var N6$9 = Math.pow(2, 42);
var N7$9 = Math.pow(2, 49);
var N8$9 = Math.pow(2, 56);
var N9$9 = Math.pow(2, 63);
var length$a = function(value) {
  return value < N1$9 ? 1 : value < N2$9 ? 2 : value < N3$9 ? 3 : value < N4$9 ? 4 : value < N5$9 ? 5 : value < N6$9 ? 6 : value < N7$9 ? 7 : value < N8$9 ? 8 : value < N9$9 ? 9 : 10;
};
var varint$9 = {
  encode: encode_1$9,
  decode: decode$P,
  encodingLength: length$a
};
const typeofs = [
  "string",
  "number",
  "bigint",
  "symbol"
];
const objectTypeNames = [
  "Function",
  "Generator",
  "AsyncGenerator",
  "GeneratorFunction",
  "AsyncGeneratorFunction",
  "AsyncFunction",
  "Observable",
  "Array",
  "Buffer",
  "Object",
  "RegExp",
  "Date",
  "Error",
  "Map",
  "Set",
  "WeakMap",
  "WeakSet",
  "ArrayBuffer",
  "SharedArrayBuffer",
  "DataView",
  "Promise",
  "URL",
  "HTMLElement",
  "Int8Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Int16Array",
  "Uint16Array",
  "Int32Array",
  "Uint32Array",
  "Float32Array",
  "Float64Array",
  "BigInt64Array",
  "BigUint64Array"
];
function is$1(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf = typeof value;
  if (typeofs.includes(typeOf)) {
    return typeOf;
  }
  if (typeOf === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer$1(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer$1(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
class Type {
  constructor(major, name2, terminal) {
    this.major = major;
    this.majorEncoded = major << 5;
    this.name = name2;
    this.terminal = terminal;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(typ) {
    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
  }
}
Type.uint = new Type(0, "uint", true);
Type.negint = new Type(1, "negint", true);
Type.bytes = new Type(2, "bytes", true);
Type.string = new Type(3, "string", true);
Type.array = new Type(4, "array", false);
Type.map = new Type(5, "map", false);
Type.tag = new Type(6, "tag", false);
Type.float = new Type(7, "float", true);
Type.false = new Type(7, "false", true);
Type.true = new Type(7, "true", true);
Type.null = new Type(7, "null", true);
Type.undefined = new Type(7, "undefined", true);
Type.break = new Type(7, "break", true);
class Token {
  constructor(type, value, encodedLength) {
    this.type = type;
    this.value = value;
    this.encodedLength = encodedLength;
    this.encodedBytes = void 0;
    this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
}
const useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
const textDecoder$3 = new TextDecoder();
const textEncoder$5 = new TextEncoder();
function isBuffer(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
const toString$7 = useBuffer ? (bytes2, start, end2) => {
  return end2 - start > 64 ? globalThis.Buffer.from(bytes2.subarray(start, end2)).toString("utf8") : utf8Slice(bytes2, start, end2);
} : (bytes2, start, end2) => {
  return end2 - start > 64 ? textDecoder$3.decode(bytes2.subarray(start, end2)) : utf8Slice(bytes2, start, end2);
};
const fromString$7 = useBuffer ? (string2) => {
  return string2.length > 64 ? globalThis.Buffer.from(string2) : utf8ToBytes(string2);
} : (string2) => {
  return string2.length > 64 ? textEncoder$5.encode(string2) : utf8ToBytes(string2);
};
const fromArray = (arr) => {
  return Uint8Array.from(arr);
};
const slice = useBuffer ? (bytes2, start, end2) => {
  if (isBuffer(bytes2)) {
    return new Uint8Array(bytes2.subarray(start, end2));
  }
  return bytes2.slice(start, end2);
} : (bytes2, start, end2) => {
  return bytes2.slice(start, end2);
};
const concat$2 = useBuffer ? (chunks, length2) => {
  chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
  return asU8A(globalThis.Buffer.concat(chunks, length2));
} : (chunks, length2) => {
  const out = new Uint8Array(length2);
  let off2 = 0;
  for (let b2 of chunks) {
    if (off2 + b2.length > out.length) {
      b2 = b2.subarray(0, out.length - off2);
    }
    out.set(b2, off2);
    off2 += b2.length;
  }
  return out;
};
const alloc = useBuffer ? (size) => {
  return globalThis.Buffer.allocUnsafe(size);
} : (size) => {
  return new Uint8Array(size);
};
function compare$1(b1, b2) {
  if (isBuffer(b1) && isBuffer(b2)) {
    return b1.compare(b2);
  }
  for (let i2 = 0; i2 < b1.length; i2++) {
    if (b1[i2] === b2[i2]) {
      continue;
    }
    return b1[i2] < b2[i2] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string2, units = Infinity) {
  let codePoint;
  const length2 = string2.length;
  let leadSurrogate = null;
  const bytes2 = [];
  for (let i2 = 0; i2 < length2; ++i2) {
    codePoint = string2.charCodeAt(i2);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        } else if (i2 + 1 === length2) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes2.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes2.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes2.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes2.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes2.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes2;
}
function utf8Slice(buf2, offset, end2) {
  const res = [];
  while (offset < end2) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end2) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
const MAX_ARGUMENTS_LENGTH = 4096;
function decodeCodePointsArray(codePoints) {
  const len2 = codePoints.length;
  if (len2 <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i2 = 0;
  while (i2 < len2) {
    res += String.fromCharCode.apply(String, codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
const defaultChunkSize = 256;
class Bl {
  constructor(chunkSize = defaultChunkSize) {
    this.chunkSize = chunkSize;
    this.cursor = 0;
    this.maxCursor = -1;
    this.chunks = [];
    this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0;
    this.maxCursor = -1;
    if (this.chunks.length) {
      this.chunks = [];
    }
    if (this._initReuseChunk !== null) {
      this.chunks.push(this._initReuseChunk);
      this.maxCursor = this._initReuseChunk.length - 1;
    }
  }
  push(bytes2) {
    let topChunk = this.chunks[this.chunks.length - 1];
    const newMax = this.cursor + bytes2.length;
    if (newMax <= this.maxCursor + 1) {
      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
      topChunk.set(bytes2, chunkPos);
    } else {
      if (topChunk) {
        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
        if (chunkPos < topChunk.length) {
          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
          this.maxCursor = this.cursor - 1;
        }
      }
      if (bytes2.length < 64 && bytes2.length < this.chunkSize) {
        topChunk = alloc(this.chunkSize);
        this.chunks.push(topChunk);
        this.maxCursor += topChunk.length;
        if (this._initReuseChunk === null) {
          this._initReuseChunk = topChunk;
        }
        topChunk.set(bytes2, 0);
      } else {
        this.chunks.push(bytes2);
        this.maxCursor += bytes2.length;
      }
    }
    this.cursor += bytes2.length;
  }
  toBytes(reset2 = false) {
    let byts;
    if (this.chunks.length === 1) {
      const chunk = this.chunks[0];
      if (reset2 && this.cursor > chunk.length / 2) {
        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
        this._initReuseChunk = null;
        this.chunks = [];
      } else {
        byts = slice(chunk, 0, this.cursor);
      }
    } else {
      byts = concat$2(this.chunks, this.cursor);
    }
    if (reset2) {
      this.reset();
    }
    return byts;
  }
}
const decodeErrPrefix = "CBOR decode error:";
const encodeErrPrefix = "CBOR encode error:";
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
const uintBoundaries = [
  24,
  256,
  65536,
  4294967296,
  BigInt("18446744073709551616")
];
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi2 = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo2 = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint) {
  if (uint < uintBoundaries[0]) {
    const nuint = Number(uint);
    buf2.push([major | nuint]);
  } else if (uint < uintBoundaries[1]) {
    const nuint = Number(uint);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint < uintBoundaries[2]) {
    const nuint = Number(uint);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint < uintBoundaries[3]) {
    const nuint = Number(uint);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint);
    if (buint < uintBoundaries[4]) {
      const set2 = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo2 = Number(buint & BigInt(4294967295));
      let hi2 = Number(buint >> BigInt(32) & BigInt(4294967295));
      set2[8] = lo2 & 255;
      lo2 = lo2 >> 8;
      set2[7] = lo2 & 255;
      lo2 = lo2 >> 8;
      set2[6] = lo2 & 255;
      lo2 = lo2 >> 8;
      set2[5] = lo2 & 255;
      set2[4] = hi2 & 255;
      hi2 = hi2 >> 8;
      set2[3] = hi2 & 255;
      hi2 = hi2 >> 8;
      set2[2] = hi2 & 255;
      hi2 = hi2 >> 8;
      set2[1] = hi2 & 255;
      buf2.push(set2);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
encodeUint.encodedSize = function encodedSize(token) {
  return encodeUintValue.encodedSize(token.value);
};
encodeUintValue.encodedSize = function encodedSize2(uint) {
  if (uint < uintBoundaries[0]) {
    return 1;
  }
  if (uint < uintBoundaries[1]) {
    return 2;
  }
  if (uint < uintBoundaries[2]) {
    return 3;
  }
  if (uint < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeUint.compareTokens = function compareTokens(tok1, tok2) {
  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
};
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
const neg1b = BigInt(-1);
const pos1b = BigInt(1);
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
encodeNegint.encodedSize = function encodedSize3(token) {
  const negint = token.value;
  const unsigned = typeof negint === "bigint" ? negint * neg1b - pos1b : negint * -1 - 1;
  if (unsigned < uintBoundaries[0]) {
    return 1;
  }
  if (unsigned < uintBoundaries[1]) {
    return 2;
  }
  if (unsigned < uintBoundaries[2]) {
    return 3;
  }
  if (unsigned < uintBoundaries[3]) {
    return 5;
  }
  return 9;
};
encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
};
function toToken$3(data, pos, prefix, length2) {
  assertEnoughData(data, pos, prefix + length2);
  const buf2 = slice(data, pos + prefix, pos + prefix + length2);
  return new Token(Type.bytes, buf2, prefix + length2);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken$3(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken$3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken$3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken$3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken$3(data, pos, 9, l2);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString$7(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes2 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes2.length);
  buf2.push(bytes2);
}
encodeBytes.encodedSize = function encodedSize4(token) {
  const bytes2 = tokenBytes(token);
  return encodeUintValue.encodedSize(bytes2.length) + bytes2.length;
};
encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
  return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
};
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare$1(b1, b2);
}
function toToken$2(data, pos, prefix, length2, options) {
  const totLength = prefix + length2;
  assertEnoughData(data, pos, totLength);
  const tok = new Token(Type.string, toString$7(data, pos + prefix, pos + totLength), totLength);
  if (options.retainStringBytes === true) {
    tok.byteValue = slice(data, pos + prefix, pos + totLength);
  }
  return tok;
}
function decodeStringCompact(data, pos, minor, options) {
  return toToken$2(data, pos, 1, minor, options);
}
function decodeString8(data, pos, _minor, options) {
  return toToken$2(data, pos, 2, readUint8(data, pos + 1, options), options);
}
function decodeString16(data, pos, _minor, options) {
  return toToken$2(data, pos, 3, readUint16(data, pos + 1, options), options);
}
function decodeString32(data, pos, _minor, options) {
  return toToken$2(data, pos, 5, readUint32(data, pos + 1, options), options);
}
function decodeString64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken$2(data, pos, 9, l2, options);
}
const encodeString = encodeBytes;
function toToken$1(_data, _pos, prefix, length2) {
  return new Token(Type.array, length2, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken$1(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken$1(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken$1(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken$1(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken$1(data, pos, 9, l2);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken$1(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
encodeArray.compareTokens = encodeUint.compareTokens;
encodeArray.encodedSize = function encodedSize5(token) {
  return encodeUintValue.encodedSize(token.value);
};
function toToken(_data, _pos, prefix, length2) {
  return new Token(Type.map, length2, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l2 = readUint64(data, pos + 1, options);
  if (typeof l2 === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken(data, pos, 9, l2);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
encodeMap.compareTokens = encodeUint.compareTokens;
encodeMap.encodedSize = function encodedSize6(token) {
  return encodeUintValue.encodedSize(token.value);
};
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
encodeTag.compareTokens = encodeUint.compareTokens;
encodeTag.encodedSize = function encodedSize7(token) {
  return encodeUintValue.encodedSize(token.value);
};
const MINOR_FALSE = 20;
const MINOR_TRUE = 21;
const MINOR_NULL = 22;
const MINOR_UNDEFINED = 23;
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  } else if (options.coerceUndefinedToNull === true) {
    return new Token(Type.null, null, 1);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes2, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes2);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
encodeFloat.encodedSize = function encodedSize8(token, options) {
  const float2 = token.value;
  if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
    return 1;
  }
  if (!options || options.float64 !== true) {
    encodeFloat16(float2);
    let decoded = readFloat16(ui8a, 1);
    if (float2 === decoded || Number.isNaN(float2)) {
      return 3;
    }
    encodeFloat32(float2);
    decoded = readFloat32(ui8a, 1);
    if (float2 === decoded) {
      return 5;
    }
  }
  return 9;
};
const buffer$1 = new ArrayBuffer(9);
const dataView = new DataView(buffer$1, 1);
const ui8a = new Uint8Array(buffer$1, 0);
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
encodeFloat.compareTokens = encodeUint.compareTokens;
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
const jump = [];
for (let i2 = 0; i2 <= 23; i2++) {
  jump[i2] = invalidMinor;
}
jump[24] = decodeUint8;
jump[25] = decodeUint16;
jump[26] = decodeUint32;
jump[27] = decodeUint64;
jump[28] = invalidMinor;
jump[29] = invalidMinor;
jump[30] = invalidMinor;
jump[31] = invalidMinor;
for (let i2 = 32; i2 <= 55; i2++) {
  jump[i2] = invalidMinor;
}
jump[56] = decodeNegint8;
jump[57] = decodeNegint16;
jump[58] = decodeNegint32;
jump[59] = decodeNegint64;
jump[60] = invalidMinor;
jump[61] = invalidMinor;
jump[62] = invalidMinor;
jump[63] = invalidMinor;
for (let i2 = 64; i2 <= 87; i2++) {
  jump[i2] = decodeBytesCompact;
}
jump[88] = decodeBytes8;
jump[89] = decodeBytes16;
jump[90] = decodeBytes32;
jump[91] = decodeBytes64;
jump[92] = invalidMinor;
jump[93] = invalidMinor;
jump[94] = invalidMinor;
jump[95] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 96; i2 <= 119; i2++) {
  jump[i2] = decodeStringCompact;
}
jump[120] = decodeString8;
jump[121] = decodeString16;
jump[122] = decodeString32;
jump[123] = decodeString64;
jump[124] = invalidMinor;
jump[125] = invalidMinor;
jump[126] = invalidMinor;
jump[127] = errorer("indefinite length bytes/strings are not supported");
for (let i2 = 128; i2 <= 151; i2++) {
  jump[i2] = decodeArrayCompact;
}
jump[152] = decodeArray8;
jump[153] = decodeArray16;
jump[154] = decodeArray32;
jump[155] = decodeArray64;
jump[156] = invalidMinor;
jump[157] = invalidMinor;
jump[158] = invalidMinor;
jump[159] = decodeArrayIndefinite;
for (let i2 = 160; i2 <= 183; i2++) {
  jump[i2] = decodeMapCompact;
}
jump[184] = decodeMap8;
jump[185] = decodeMap16;
jump[186] = decodeMap32;
jump[187] = decodeMap64;
jump[188] = invalidMinor;
jump[189] = invalidMinor;
jump[190] = invalidMinor;
jump[191] = decodeMapIndefinite;
for (let i2 = 192; i2 <= 215; i2++) {
  jump[i2] = decodeTagCompact;
}
jump[216] = decodeTag8;
jump[217] = decodeTag16;
jump[218] = decodeTag32;
jump[219] = decodeTag64;
jump[220] = invalidMinor;
jump[221] = invalidMinor;
jump[222] = invalidMinor;
jump[223] = invalidMinor;
for (let i2 = 224; i2 <= 243; i2++) {
  jump[i2] = errorer("simple values are not supported");
}
jump[244] = invalidMinor;
jump[245] = invalidMinor;
jump[246] = invalidMinor;
jump[247] = decodeUndefined;
jump[248] = errorer("simple values are not supported");
jump[249] = decodeFloat16;
jump[250] = decodeFloat32;
jump[251] = decodeFloat64;
jump[252] = invalidMinor;
jump[253] = invalidMinor;
jump[254] = invalidMinor;
jump[255] = decodeBreak;
const quick = [];
for (let i2 = 0; i2 < 24; i2++) {
  quick[i2] = new Token(Type.uint, i2, 1);
}
for (let i2 = -1; i2 >= -24; i2--) {
  quick[31 - i2] = new Token(Type.negint, i2, 1);
}
quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
quick[96] = new Token(Type.string, "", 1);
quick[128] = new Token(Type.array, 0, 1);
quick[160] = new Token(Type.map, 0, 1);
quick[244] = new Token(Type.false, false, 1);
quick[245] = new Token(Type.true, true, 1);
quick[246] = new Token(Type.null, null, 1);
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
const defaultEncodeOptions$2 = {
  float64: false,
  mapSorter: mapSorter$1,
  quickEncodeToken
};
function makeCborEncoders() {
  const encoders = [];
  encoders[Type.uint.major] = encodeUint;
  encoders[Type.negint.major] = encodeNegint;
  encoders[Type.bytes.major] = encodeBytes;
  encoders[Type.string.major] = encodeString;
  encoders[Type.array.major] = encodeArray;
  encoders[Type.map.major] = encodeMap;
  encoders[Type.tag.major] = encodeTag;
  encoders[Type.float.major] = encodeFloat;
  return encoders;
}
const cborEncoders$1 = makeCborEncoders();
const buf = new Bl();
class Ref {
  constructor(obj, parent) {
    this.obj = obj;
    this.parent = parent;
  }
  includes(obj) {
    let p2 = this;
    do {
      if (p2.obj === obj) {
        return true;
      }
    } while (p2 = p2.parent);
    return false;
  }
  static createCheck(stack, obj) {
    if (stack && stack.includes(obj)) {
      throw new Error(`${encodeErrPrefix} object contains circular references`);
    }
    return new Ref(obj, stack);
  }
}
const simpleTokens = {
  null: new Token(Type.null, null),
  undefined: new Token(Type.undefined, void 0),
  true: new Token(Type.true, true),
  false: new Token(Type.false, false),
  emptyArray: new Token(Type.array, 0),
  emptyMap: new Token(Type.map, 0)
};
const typeEncoders = {
  number(obj, _typ, _options, _refStack) {
    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
      return new Token(Type.float, obj);
    } else if (obj >= 0) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  bigint(obj, _typ, _options, _refStack) {
    if (obj >= BigInt(0)) {
      return new Token(Type.uint, obj);
    } else {
      return new Token(Type.negint, obj);
    }
  },
  Uint8Array(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, obj);
  },
  string(obj, _typ, _options, _refStack) {
    return new Token(Type.string, obj);
  },
  boolean(obj, _typ, _options, _refStack) {
    return obj ? simpleTokens.true : simpleTokens.false;
  },
  null(_obj, _typ, _options, _refStack) {
    return simpleTokens.null;
  },
  undefined(_obj, _typ, _options, _refStack) {
    return simpleTokens.undefined;
  },
  ArrayBuffer(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj));
  },
  DataView(obj, _typ, _options, _refStack) {
    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
  },
  Array(obj, _typ, options, refStack) {
    if (!obj.length) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyArray,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyArray;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const e of obj) {
      entries[i2++] = objectToTokens(e, options, refStack);
    }
    if (options.addBreakTokens) {
      return [
        new Token(Type.array, obj.length),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.array, obj.length),
      entries
    ];
  },
  Object(obj, typ, options, refStack) {
    const isMap = typ !== "Object";
    const keys = isMap ? obj.keys() : Object.keys(obj);
    const length2 = isMap ? obj.size : keys.length;
    if (!length2) {
      if (options.addBreakTokens === true) {
        return [
          simpleTokens.emptyMap,
          new Token(Type.break)
        ];
      }
      return simpleTokens.emptyMap;
    }
    refStack = Ref.createCheck(refStack, obj);
    const entries = [];
    let i2 = 0;
    for (const key of keys) {
      entries[i2++] = [
        objectToTokens(key, options, refStack),
        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
      ];
    }
    sortMapEntries(entries, options);
    if (options.addBreakTokens) {
      return [
        new Token(Type.map, length2),
        entries,
        new Token(Type.break)
      ];
    }
    return [
      new Token(Type.map, length2),
      entries
    ];
  }
};
typeEncoders.Map = typeEncoders.Object;
typeEncoders.Buffer = typeEncoders.Uint8Array;
for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
  typeEncoders[`${typ}Array`] = typeEncoders.DataView;
}
function objectToTokens(obj, options = {}, refStack) {
  const typ = is$1(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter$1(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders$1[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  buf.reset();
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode$B(data, options) {
  options = Object.assign({}, defaultEncodeOptions$2, options);
  return encodeCustom(data, cborEncoders$1, options);
}
const defaultDecodeOptions = {
  strict: false,
  allowIndefinite: true,
  allowUndefined: true,
  allowBigInt: true
};
class Tokeniser {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    const byt = this.data[this.pos];
    let token = quick[byt];
    if (token === void 0) {
      const decoder = jump[byt];
      if (!decoder) {
        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
      }
      const minor = byt & 31;
      token = decoder(this.data, this.pos, minor, this.options);
    }
    this.pos += token.encodedLength;
    return token;
  }
}
const DONE = Symbol.for("DONE");
const BREAK = Symbol.for("BREAK");
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i2 = 0; i2 < token.value; i2++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i2}, expected ${token.value})`);
    }
    arr[i2] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? /* @__PURE__ */ new Map() : void 0;
  for (let i2 = 0; i2 < token.value; i2++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i2} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode$O(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
const cborEncoders = makeCborEncoders();
const defaultEncodeOptions$1 = {
  float64: false,
  quickEncodeToken
};
function tokensToLength(tokens, encoders = cborEncoders, options = defaultEncodeOptions$1) {
  if (Array.isArray(tokens)) {
    let len2 = 0;
    for (const token of tokens) {
      len2 += tokensToLength(token, encoders, options);
    }
    return len2;
  } else {
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize === void 0 || typeof encoder.encodedSize !== "function") {
      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`);
    }
    return encoder.encodedSize(tokens, options);
  }
}
var encode_1$8 = encode$A;
var MSB$9 = 128, REST$9 = 127, MSBALL$8 = ~REST$9, INT$8 = Math.pow(2, 31);
function encode$A(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$8) {
    out[offset++] = num & 255 | MSB$9;
    num /= 128;
  }
  while (num & MSBALL$8) {
    out[offset++] = num & 255 | MSB$9;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$A.bytes = offset - oldOffset + 1;
  return out;
}
var decode$N = read$8;
var MSB$1$8 = 128, REST$1$8 = 127;
function read$8(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$8.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$8) << shift : (b2 & REST$1$8) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$8);
  read$8.bytes = counter - offset;
  return res;
}
var N1$8 = Math.pow(2, 7);
var N2$8 = Math.pow(2, 14);
var N3$8 = Math.pow(2, 21);
var N4$8 = Math.pow(2, 28);
var N5$8 = Math.pow(2, 35);
var N6$8 = Math.pow(2, 42);
var N7$8 = Math.pow(2, 49);
var N8$8 = Math.pow(2, 56);
var N9$8 = Math.pow(2, 63);
var length$9 = function(value) {
  return value < N1$8 ? 1 : value < N2$8 ? 2 : value < N3$8 ? 3 : value < N4$8 ? 4 : value < N5$8 ? 5 : value < N6$8 ? 6 : value < N7$8 ? 7 : value < N8$8 ? 8 : value < N9$8 ? 9 : 10;
};
var varint$8 = {
  encode: encode_1$8,
  decode: decode$N,
  encodingLength: length$9
};
var _brrp_varint$8 = varint$8;
const decode$M = (data, offset = 0) => {
  const code2 = _brrp_varint$8.decode(data, offset);
  return [
    code2,
    _brrp_varint$8.decode.bytes
  ];
};
const encodeTo$8 = (int, target, offset = 0) => {
  _brrp_varint$8.encode(int, target, offset);
  return target;
};
const encodingLength$8 = (int) => {
  return _brrp_varint$8.encodingLength(int);
};
const equals$i = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$8 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const create$b = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$8(code2);
  const digestOffset = sizeOffset + encodingLength$8(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$8(code2, bytes2, 0);
  encodeTo$8(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$8(code2, size, digest2, bytes2);
};
const decode$L = (multihash) => {
  const bytes2 = coerce$8(multihash);
  const [code2, sizeOffset] = decode$M(bytes2);
  const [size, digestOffset] = decode$M(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$8(code2, size, digest2, bytes2);
};
const equals$h = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$i(a2.bytes, b2.bytes);
  }
};
class Digest$8 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$8(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$8 = base$8;
var _brrp__multiformats_scope_baseX$8 = src$8;
class Encoder$8 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$8 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$8(this, decoder);
  }
}
class ComposedDecoder$8 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$8(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$8 = (left, right) => new ComposedDecoder$8({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$8 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$8(name2, prefix, baseEncode);
    this.decoder = new Decoder$8(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$d = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$8(name2, prefix, encode2, decode2);
const baseX$8 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$8(alphabet2, name2);
  return from$d({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$8(decode2(text))
  });
};
const decode$K = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$z = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$8 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$d({
    prefix,
    name: name2,
    encode(input) {
      return encode$z(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$K(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$8 = baseX$8({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX$8({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base32$b = rfc4648$8({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648$8({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class CID$8 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$8,
      byteLength: hidden$8,
      code: readonly$a,
      version: readonly$a,
      multihash: readonly$a,
      bytes: readonly$a,
      _baseCache: hidden$8,
      asCID: hidden$8
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$8) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$8) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$8.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$b(code2, digest2);
        return CID$8.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$h(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$8(bytes2, _baseCache, base3 || base58btc$8.encoder);
      default:
        return toStringV1$8(bytes2, _baseCache, base3 || base32$b.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$8(/^0\.0/, IS_CID_DEPRECATION$8);
    return !!(value && (value[cidSymbol$8] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$8) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$8(version2, code2, multihash, bytes2 || encodeCID$8(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$8] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$L(multihash);
      return CID$8.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$8) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$8}) block encoding`);
        } else {
          return new CID$8(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$8(version2, code2, digest2.bytes);
        return new CID$8(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$8.create(0, DAG_PB_CODE$8, digest2);
  }
  static createV1(code2, digest2) {
    return CID$8.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$8.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$8.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$8(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$8(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$8.createV0(digest2) : CID$8.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$M(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$8;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$8(source, base3);
    const cid = CID$8.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$8 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$8;
      return [
        base58btc$8.prefix,
        decoder.decode(`${base58btc$8.prefix}${source}`)
      ];
    }
    case base58btc$8.prefix: {
      const decoder = base3 || base58btc$8;
      return [
        base58btc$8.prefix,
        decoder.decode(source)
      ];
    }
    case base32$b.prefix: {
      const decoder = base3 || base32$b;
      return [
        base32$b.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$8 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$8.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$8 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$8 = 112;
const SHA_256_CODE$8 = 18;
const encodeCID$8 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$8(version2);
  const hashOffset = codeOffset + encodingLength$8(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$8(version2, bytes2, 0);
  encodeTo$8(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$8 = Symbol.for("@ipld/js-cid/CID");
const readonly$a = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$8 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$9 = "0.0.0-dev";
const deprecate$8 = (range, message) => {
  if (range.test(version$9)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$8 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const CID_CBOR_TAG = 42;
function cidEncoder$1(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID$8.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes2 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes2.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes2)
  ];
}
function undefinedEncoder$1() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder$1(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions$1 = {
  float64: true,
  typeEncoders: {
    Object: cidEncoder$1,
    undefined: undefinedEncoder$1,
    number: numberEncoder$1
  }
};
function cidDecoder(bytes2) {
  if (bytes2[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID$8.decode(bytes2.subarray(1));
}
const decodeOptions$1 = {
  allowIndefinite: false,
  coerceUndefinedToNull: true,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions$1.tags[CID_CBOR_TAG] = cidDecoder;
const name$8 = "dag-cbor";
const code$d = 113;
const encode$y = (node) => encode$B(node, encodeOptions$1);
const decode$J = (data) => decode$O(data, decodeOptions$1);
const dagCBOR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$8,
  code: code$d,
  encode: encode$y,
  decode: decode$J
}, Symbol.toStringTag, { value: "Module" }));
class CarBufferWriter {
  constructor(bytes2, headerSize) {
    this.bytes = bytes2;
    this.byteOffset = headerSize;
    this.roots = [];
    this.headerSize = headerSize;
  }
  addRoot(root, options) {
    addRoot(this, root, options);
    return this;
  }
  write(block) {
    addBlock(this, block);
    return this;
  }
  close(options) {
    return close(this, options);
  }
}
const addRoot = (writer2, root, options = {}) => {
  const {
    resize = false
  } = options;
  const { bytes: bytes2, headerSize, byteOffset, roots: roots2 } = writer2;
  writer2.roots.push(root);
  const size = headerLength(writer2);
  if (size > headerSize) {
    if (size - headerSize + byteOffset < bytes2.byteLength) {
      if (resize) {
        resizeHeader(writer2, size);
      } else {
        roots2.pop();
        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
      }
    } else {
      roots2.pop();
      throw new RangeError(`Buffer has no capacity for a new root ${root}`);
    }
  }
};
const blockLength = ({ cid, bytes: bytes2 }) => {
  const size = cid.bytes.byteLength + bytes2.byteLength;
  return varint$9.encodingLength(size) + size;
};
const addBlock = (writer2, { cid, bytes: bytes2 }) => {
  const byteLength2 = cid.bytes.byteLength + bytes2.byteLength;
  const size = varint$9.encode(byteLength2);
  if (writer2.byteOffset + size.length + byteLength2 > writer2.bytes.byteLength) {
    throw new RangeError("Buffer has no capacity for this block");
  } else {
    writeBytes$1(writer2, size);
    writeBytes$1(writer2, cid.bytes);
    writeBytes$1(writer2, bytes2);
  }
};
const close = (writer2, options = {}) => {
  const {
    resize = false
  } = options;
  const { roots: roots2, bytes: bytes2, byteOffset, headerSize } = writer2;
  const headerBytes = encode$y({
    version: 1,
    roots: roots2
  });
  const varintBytes = varint$9.encode(headerBytes.length);
  const size = varintBytes.length + headerBytes.byteLength;
  const offset = headerSize - size;
  if (offset === 0) {
    writeHeader(writer2, varintBytes, headerBytes);
    return bytes2.subarray(0, byteOffset);
  } else if (resize) {
    resizeHeader(writer2, size);
    writeHeader(writer2, varintBytes, headerBytes);
    return bytes2.subarray(0, writer2.byteOffset);
  } else {
    throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
  }
};
const resizeHeader = (writer2, byteLength2) => {
  const { bytes: bytes2, headerSize } = writer2;
  bytes2.set(bytes2.subarray(headerSize, writer2.byteOffset), byteLength2);
  writer2.byteOffset += byteLength2 - headerSize;
  writer2.headerSize = byteLength2;
};
const writeBytes$1 = (writer2, bytes2) => {
  writer2.bytes.set(bytes2, writer2.byteOffset);
  writer2.byteOffset += bytes2.length;
};
const writeHeader = ({ bytes: bytes2 }, varint2, header) => {
  bytes2.set(varint2);
  bytes2.set(header, varint2.length);
};
const headerPreludeTokens = [
  new Token(Type.map, 2),
  new Token(Type.string, "version"),
  new Token(Type.uint, 1),
  new Token(Type.string, "roots")
];
const CID_TAG = new Token(Type.tag, 42);
const calculateHeaderLength = (rootLengths) => {
  const tokens = [...headerPreludeTokens];
  tokens.push(new Token(Type.array, rootLengths.length));
  for (const rootLength of rootLengths) {
    tokens.push(CID_TAG);
    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }));
  }
  const length2 = tokensToLength(tokens);
  return varint$9.encodingLength(length2) + length2;
};
const headerLength = ({ roots: roots2 }) => calculateHeaderLength(roots2.map((cid) => cid.bytes.byteLength));
const createWriter = (buffer2, options = {}) => {
  const { roots: roots2 = [], byteOffset = 0, byteLength: byteLength2 = buffer2.byteLength, headerSize = headerLength({ roots: roots2 }) } = options;
  const bytes2 = new Uint8Array(buffer2, byteOffset, byteLength2);
  const writer2 = new CarBufferWriter(bytes2, headerSize);
  for (const root of roots2) {
    writer2.addRoot(root);
  }
  return writer2;
};
var encode_1$7 = encode$x;
var MSB$8 = 128, REST$8 = 127, MSBALL$7 = ~REST$8, INT$7 = Math.pow(2, 31);
function encode$x(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$7) {
    out[offset++] = num & 255 | MSB$8;
    num /= 128;
  }
  while (num & MSBALL$7) {
    out[offset++] = num & 255 | MSB$8;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$x.bytes = offset - oldOffset + 1;
  return out;
}
var decode$I = read$7;
var MSB$1$7 = 128, REST$1$7 = 127;
function read$7(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$7.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$7) << shift : (b2 & REST$1$7) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$7);
  read$7.bytes = counter - offset;
  return res;
}
var N1$7 = Math.pow(2, 7);
var N2$7 = Math.pow(2, 14);
var N3$7 = Math.pow(2, 21);
var N4$7 = Math.pow(2, 28);
var N5$7 = Math.pow(2, 35);
var N6$7 = Math.pow(2, 42);
var N7$7 = Math.pow(2, 49);
var N8$7 = Math.pow(2, 56);
var N9$7 = Math.pow(2, 63);
var length$8 = function(value) {
  return value < N1$7 ? 1 : value < N2$7 ? 2 : value < N3$7 ? 3 : value < N4$7 ? 4 : value < N5$7 ? 5 : value < N6$7 ? 6 : value < N7$7 ? 7 : value < N8$7 ? 8 : value < N9$7 ? 9 : 10;
};
var varint$7 = {
  encode: encode_1$7,
  decode: decode$I,
  encodingLength: length$8
};
var _brrp_varint$7 = varint$7;
const decode$H = (data, offset = 0) => {
  const code2 = _brrp_varint$7.decode(data, offset);
  return [
    code2,
    _brrp_varint$7.decode.bytes
  ];
};
const encodeTo$7 = (int, target, offset = 0) => {
  _brrp_varint$7.encode(int, target, offset);
  return target;
};
const encodingLength$7 = (int) => {
  return _brrp_varint$7.encodingLength(int);
};
const equals$g = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$7 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const create$a = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$7(code2);
  const digestOffset = sizeOffset + encodingLength$7(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$7(code2, bytes2, 0);
  encodeTo$7(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$7(code2, size, digest2, bytes2);
};
const decode$G = (multihash) => {
  const bytes2 = coerce$7(multihash);
  const [code2, sizeOffset] = decode$H(bytes2);
  const [size, digestOffset] = decode$H(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$7(code2, size, digest2, bytes2);
};
const equals$f = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$g(a2.bytes, b2.bytes);
  }
};
class Digest$7 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$7(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$7 = base$7;
var _brrp__multiformats_scope_baseX$7 = src$7;
class Encoder$7 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$7 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$7(this, decoder);
  }
}
class ComposedDecoder$7 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$7(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$7 = (left, right) => new ComposedDecoder$7({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$7 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$7(name2, prefix, baseEncode);
    this.decoder = new Decoder$7(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$c = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$7(name2, prefix, encode2, decode2);
const baseX$7 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$7(alphabet2, name2);
  return from$c({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$7(decode2(text))
  });
};
const decode$F = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$w = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$7 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$c({
    prefix,
    name: name2,
    encode(input) {
      return encode$w(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$F(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$7 = baseX$7({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX$7({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base32$a = rfc4648$7({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648$7({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class CID$7 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$7,
      byteLength: hidden$7,
      code: readonly$9,
      version: readonly$9,
      multihash: readonly$9,
      bytes: readonly$9,
      _baseCache: hidden$7,
      asCID: hidden$7
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$7) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$7) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$7.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$a(code2, digest2);
        return CID$7.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$f(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$7(bytes2, _baseCache, base3 || base58btc$7.encoder);
      default:
        return toStringV1$7(bytes2, _baseCache, base3 || base32$a.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$7(/^0\.0/, IS_CID_DEPRECATION$7);
    return !!(value && (value[cidSymbol$7] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$7) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$7(version2, code2, multihash, bytes2 || encodeCID$7(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$7] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$G(multihash);
      return CID$7.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$7) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$7}) block encoding`);
        } else {
          return new CID$7(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$7(version2, code2, digest2.bytes);
        return new CID$7(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$7.create(0, DAG_PB_CODE$7, digest2);
  }
  static createV1(code2, digest2) {
    return CID$7.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$7.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$7.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$7(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$7(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$7.createV0(digest2) : CID$7.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$H(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$7;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$7(source, base3);
    const cid = CID$7.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$7 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$7;
      return [
        base58btc$7.prefix,
        decoder.decode(`${base58btc$7.prefix}${source}`)
      ];
    }
    case base58btc$7.prefix: {
      const decoder = base3 || base58btc$7;
      return [
        base58btc$7.prefix,
        decoder.decode(source)
      ];
    }
    case base32$a.prefix: {
      const decoder = base3 || base32$a;
      return [
        base32$a.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$7 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$7.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$7 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$7 = 112;
const SHA_256_CODE$7 = 18;
const encodeCID$7 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$7(version2);
  const hashOffset = codeOffset + encodingLength$7(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$7(version2, bytes2, 0);
  encodeTo$7(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$7 = Symbol.for("@ipld/js-cid/CID");
const readonly$9 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$7 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$8 = "0.0.0-dev";
const deprecate$7 = (range, message) => {
  if (range.test(version$8)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$7 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const Kinds = {
  Null: (obj) => obj === null,
  Int: (obj) => Number.isInteger(obj),
  Float: (obj) => typeof obj === "number" && Number.isFinite(obj),
  String: (obj) => typeof obj === "string",
  Bool: (obj) => typeof obj === "boolean",
  Bytes: (obj) => obj instanceof Uint8Array,
  Link: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID === obj,
  List: (obj) => Array.isArray(obj),
  Map: (obj) => !Kinds.Null(obj) && typeof obj === "object" && obj.asCID !== obj && !Kinds.List(obj) && !Kinds.Bytes(obj)
};
const Types = {
  Int: Kinds.Int,
  "CarHeader > version": (obj) => Types.Int(obj),
  "CarHeader > roots (anon) > valueType (anon)": Kinds.Link,
  "CarHeader > roots (anon)": (obj) => Kinds.List(obj) && Array.prototype.every.call(obj, Types["CarHeader > roots (anon) > valueType (anon)"]),
  "CarHeader > roots": (obj) => Types["CarHeader > roots (anon)"](obj),
  CarHeader: (obj) => {
    const keys = obj && Object.keys(obj);
    return Kinds.Map(obj) && ["version"].every((k) => keys.includes(k)) && Object.entries(obj).every(([name2, value]) => Types["CarHeader > " + name2] && Types["CarHeader > " + name2](value));
  }
};
const CarHeader = Types.CarHeader;
const CIDV0_BYTES = {
  SHA2_256: 18,
  LENGTH: 32,
  DAG_PB: 112
};
const V2_HEADER_LENGTH = 16 + 8 + 8 + 8;
async function readVarint(reader2) {
  const bytes2 = await reader2.upTo(8);
  if (!bytes2.length) {
    throw new Error("Unexpected end of data");
  }
  const i2 = varint$9.decode(bytes2);
  reader2.seek(varint$9.decode.bytes);
  return i2;
}
async function readV2Header(reader2) {
  const bytes2 = await reader2.exactly(V2_HEADER_LENGTH);
  const dv = new DataView(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
  let offset = 0;
  const header = {
    version: 2,
    characteristics: [
      dv.getBigUint64(offset, true),
      dv.getBigUint64(offset += 8, true)
    ],
    dataOffset: Number(dv.getBigUint64(offset += 8, true)),
    dataSize: Number(dv.getBigUint64(offset += 8, true)),
    indexOffset: Number(dv.getBigUint64(offset += 8, true))
  };
  reader2.seek(V2_HEADER_LENGTH);
  return header;
}
async function readHeader$1(reader2, strictVersion) {
  const length2 = await readVarint(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader2.exactly(length2);
  reader2.seek(length2);
  const block = decode$J(header);
  if (!CarHeader(block)) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1 && block.version !== 2 || strictVersion !== void 0 && block.version !== strictVersion) {
    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== void 0 ? ` (expected ${strictVersion})` : ""}`);
  }
  const hasRoots = Array.isArray(block.roots);
  if (block.version === 1 && !hasRoots || block.version === 2 && hasRoots) {
    throw new Error("Invalid CAR header format");
  }
  if (block.version === 1) {
    return block;
  }
  const v2Header = await readV2Header(reader2);
  reader2.seek(v2Header.dataOffset - reader2.pos);
  const v1Header = await readHeader$1(reader2, 1);
  return Object.assign(v1Header, v2Header);
}
async function readMultihash(reader2) {
  const bytes2 = await reader2.upTo(8);
  varint$9.decode(bytes2);
  const codeLength = varint$9.decode.bytes;
  const length2 = varint$9.decode(bytes2.subarray(varint$9.decode.bytes));
  const lengthLength = varint$9.decode.bytes;
  const mhLength = codeLength + lengthLength + length2;
  const multihash = await reader2.exactly(mhLength);
  reader2.seek(mhLength);
  return multihash;
}
async function readCid(reader2) {
  const first2 = await reader2.exactly(2);
  if (first2[0] === CIDV0_BYTES.SHA2_256 && first2[1] === CIDV0_BYTES.LENGTH) {
    const bytes3 = await reader2.exactly(34);
    reader2.seek(34);
    const multihash2 = decode$G(bytes3);
    return CID$7.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version2 = await readVarint(reader2);
  if (version2 !== 1) {
    throw new Error(`Unexpected CID version (${version2})`);
  }
  const codec = await readVarint(reader2);
  const bytes2 = await readMultihash(reader2);
  const multihash = decode$G(bytes2);
  return CID$7.create(version2, codec, multihash);
}
async function readBlockHead(reader2) {
  const start = reader2.pos;
  let length2 = await readVarint(reader2);
  if (length2 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length2 += reader2.pos - start;
  const cid = await readCid(reader2);
  const blockLength2 = length2 - Number(reader2.pos - start);
  return {
    cid,
    length: length2,
    blockLength: blockLength2
  };
}
async function readBlock(reader2) {
  const { cid, blockLength: blockLength2 } = await readBlockHead(reader2);
  const bytes2 = await reader2.exactly(blockLength2);
  reader2.seek(blockLength2);
  return {
    bytes: bytes2,
    cid
  };
}
async function readBlockIndex(reader2) {
  const offset = reader2.pos;
  const { cid, length: length2, blockLength: blockLength2 } = await readBlockHead(reader2);
  const index = {
    cid,
    length: length2,
    blockLength: blockLength2,
    offset,
    blockOffset: reader2.pos
  };
  reader2.seek(index.blockLength);
  return index;
}
function createDecoder(reader2) {
  const headerPromise = (async () => {
    const header = await readHeader$1(reader2);
    if (header.version === 2) {
      const v1length = reader2.pos - header.dataOffset;
      reader2 = limitReader(reader2, header.dataSize - v1length);
    }
    return header;
  })();
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlock(reader2);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader2.upTo(8)).length > 0) {
        yield await readBlockIndex(reader2);
      }
    }
  };
}
function bytesReader(bytes2) {
  let pos = 0;
  return {
    async upTo(length2) {
      return bytes2.subarray(pos, pos + Math.min(length2, bytes2.length - pos));
    },
    async exactly(length2) {
      if (length2 > bytes2.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes2.subarray(pos, pos + length2);
    },
    seek(length2) {
      pos += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length2) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length2) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p2, c) => p2 + c.length, 0));
    let off2 = 0;
    for (const b2 of bufa) {
      currentChunk.set(b2, off2);
      off2 += b2.length;
    }
    offset = 0;
  };
  return {
    async upTo(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length2));
    },
    async exactly(length2) {
      if (currentChunk.length - offset < length2) {
        await read2(length2);
      }
      if (currentChunk.length - offset < length2) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length2);
    },
    seek(length2) {
      pos += length2;
      offset += length2;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator2 = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator2.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
function limitReader(reader2, byteLimit) {
  let bytesRead = 0;
  return {
    async upTo(length2) {
      let bytes2 = await reader2.upTo(length2);
      if (bytes2.length + bytesRead > byteLimit) {
        bytes2 = bytes2.subarray(0, byteLimit - bytesRead);
      }
      return bytes2;
    },
    async exactly(length2) {
      const bytes2 = await reader2.exactly(length2);
      if (bytes2.length + bytesRead > byteLimit) {
        throw new Error("Unexpected end of data");
      }
      return bytes2;
    },
    seek(length2) {
      bytesRead += length2;
      reader2.seek(length2);
    },
    get pos() {
      return reader2.pos;
    }
  };
}
class CarReader {
  constructor(header, blocks) {
    this._header = header;
    this._blocks = blocks;
    this._keys = blocks.map((b2) => b2.cid.toString());
  }
  get version() {
    return this._header.version;
  }
  async getRoots() {
    return this._header.roots;
  }
  async has(key) {
    return this._keys.indexOf(key.toString()) > -1;
  }
  async get(key) {
    const index = this._keys.indexOf(key.toString());
    return index > -1 ? this._blocks[index] : void 0;
  }
  async *blocks() {
    for (const block of this._blocks) {
      yield block;
    }
  }
  async *cids() {
    for (const block of this._blocks) {
      yield block.cid;
    }
  }
  static async fromBytes(bytes2) {
    if (!(bytes2 instanceof Uint8Array)) {
      throw new TypeError("fromBytes() requires a Uint8Array");
    }
    return decodeReaderComplete(bytesReader(bytes2));
  }
  static async fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
      throw new TypeError("fromIterable() requires an async iterable");
    }
    return decodeReaderComplete(asyncIterableReader(asyncIterable));
  }
}
async function decodeReaderComplete(reader2) {
  const decoder = createDecoder(reader2);
  const header = await decoder.header();
  const blocks = [];
  for await (const block of decoder.blocks()) {
    blocks.push(block);
  }
  return new CarReader(header, blocks);
}
var encode_1$6 = encode$v;
var MSB$7 = 128, REST$7 = 127, MSBALL$6 = ~REST$7, INT$6 = Math.pow(2, 31);
function encode$v(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$6) {
    out[offset++] = num & 255 | MSB$7;
    num /= 128;
  }
  while (num & MSBALL$6) {
    out[offset++] = num & 255 | MSB$7;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$v.bytes = offset - oldOffset + 1;
  return out;
}
var decode$E = read$6;
var MSB$1$6 = 128, REST$1$6 = 127;
function read$6(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$6.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$6) << shift : (b2 & REST$1$6) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$6);
  read$6.bytes = counter - offset;
  return res;
}
var N1$6 = Math.pow(2, 7);
var N2$6 = Math.pow(2, 14);
var N3$6 = Math.pow(2, 21);
var N4$6 = Math.pow(2, 28);
var N5$6 = Math.pow(2, 35);
var N6$6 = Math.pow(2, 42);
var N7$6 = Math.pow(2, 49);
var N8$6 = Math.pow(2, 56);
var N9$6 = Math.pow(2, 63);
var length$7 = function(value) {
  return value < N1$6 ? 1 : value < N2$6 ? 2 : value < N3$6 ? 3 : value < N4$6 ? 4 : value < N5$6 ? 5 : value < N6$6 ? 6 : value < N7$6 ? 7 : value < N8$6 ? 8 : value < N9$6 ? 9 : 10;
};
var varint$6 = {
  encode: encode_1$6,
  decode: decode$E,
  encodingLength: length$7
};
var _brrp_varint$6 = varint$6;
const decode$D = (data, offset = 0) => {
  const code2 = _brrp_varint$6.decode(data, offset);
  return [
    code2,
    _brrp_varint$6.decode.bytes
  ];
};
const encodeTo$6 = (int, target, offset = 0) => {
  _brrp_varint$6.encode(int, target, offset);
  return target;
};
const encodingLength$6 = (int) => {
  return _brrp_varint$6.encodingLength(int);
};
const empty = new Uint8Array(0);
const toHex = (d2) => d2.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
const fromHex = (hex) => {
  const hexes = hex.match(/../g);
  return hexes ? new Uint8Array(hexes.map((b2) => parseInt(b2, 16))) : empty;
};
const equals$e = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$6 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const isBinary$1 = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
const fromString$6 = (str) => new TextEncoder().encode(str);
const toString$6 = (b2) => new TextDecoder().decode(b2);
const byteslib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  equals: equals$e,
  coerce: coerce$6,
  isBinary: isBinary$1,
  fromHex,
  toHex,
  fromString: fromString$6,
  toString: toString$6,
  empty
}, Symbol.toStringTag, { value: "Module" }));
const create$9 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$6(code2);
  const digestOffset = sizeOffset + encodingLength$6(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$6(code2, bytes2, 0);
  encodeTo$6(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$6(code2, size, digest2, bytes2);
};
const decode$C = (multihash) => {
  const bytes2 = coerce$6(multihash);
  const [code2, sizeOffset] = decode$D(bytes2);
  const [size, digestOffset] = decode$D(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$6(code2, size, digest2, bytes2);
};
const equals$d = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$e(a2.bytes, b2.bytes);
  }
};
class Digest$6 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$6(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$6 = base$6;
var _brrp__multiformats_scope_baseX$6 = src$6;
class Encoder$6 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$6 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$6(this, decoder);
  }
}
class ComposedDecoder$6 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$6(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$6 = (left, right) => new ComposedDecoder$6({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$6 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$6(name2, prefix, baseEncode);
    this.decoder = new Decoder$6(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$b = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$6(name2, prefix, encode2, decode2);
const baseX$6 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$6(alphabet2, name2);
  return from$b({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$6(decode2(text))
  });
};
const decode$B = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$u = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$6 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$b({
    prefix,
    name: name2,
    encode(input) {
      return encode$u(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$B(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$6 = baseX$6({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr$2 = baseX$6({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: base58btc$6,
  base58flickr: base58flickr$2
}, Symbol.toStringTag, { value: "Module" }));
const base32$8 = rfc4648$6({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper$2 = rfc4648$6({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad$3 = rfc4648$6({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper$2 = rfc4648$6({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex$2 = rfc4648$6({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper$2 = rfc4648$6({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad$2 = rfc4648$6({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper$2 = rfc4648$6({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z$2 = rfc4648$6({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: base32$8,
  base32upper: base32upper$2,
  base32pad: base32pad$3,
  base32padupper: base32padupper$2,
  base32hex: base32hex$2,
  base32hexupper: base32hexupper$2,
  base32hexpad: base32hexpad$2,
  base32hexpadupper: base32hexpadupper$2,
  base32z: base32z$2
}, Symbol.toStringTag, { value: "Module" }));
class CID$6 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$6,
      byteLength: hidden$6,
      code: readonly$8,
      version: readonly$8,
      multihash: readonly$8,
      bytes: readonly$8,
      _baseCache: hidden$6,
      asCID: hidden$6
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$6) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$6) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$6.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$9(code2, digest2);
        return CID$6.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$d(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$6(bytes2, _baseCache, base3 || base58btc$6.encoder);
      default:
        return toStringV1$6(bytes2, _baseCache, base3 || base32$8.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$6(/^0\.0/, IS_CID_DEPRECATION$6);
    return !!(value && (value[cidSymbol$6] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$6) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$6(version2, code2, multihash, bytes2 || encodeCID$6(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$6] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$C(multihash);
      return CID$6.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$6) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$6}) block encoding`);
        } else {
          return new CID$6(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$6(version2, code2, digest2.bytes);
        return new CID$6(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$6.create(0, DAG_PB_CODE$6, digest2);
  }
  static createV1(code2, digest2) {
    return CID$6.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$6.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$6.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$6(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$6(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$6.createV0(digest2) : CID$6.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$D(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$6;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$6(source, base3);
    const cid = CID$6.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$6 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$6;
      return [
        base58btc$6.prefix,
        decoder.decode(`${base58btc$6.prefix}${source}`)
      ];
    }
    case base58btc$6.prefix: {
      const decoder = base3 || base58btc$6;
      return [
        base58btc$6.prefix,
        decoder.decode(source)
      ];
    }
    case base32$8.prefix: {
      const decoder = base3 || base32$8;
      return [
        base32$8.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$6 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$6.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$6 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$6 = 112;
const SHA_256_CODE$6 = 18;
const encodeCID$6 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$6(version2);
  const hashOffset = codeOffset + encodingLength$6(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$6(version2, bytes2, 0);
  encodeTo$6(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$6 = Symbol.for("@ipld/js-cid/CID");
const readonly$8 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$6 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$7 = "0.0.0-dev";
const deprecate$6 = (range, message) => {
  if (range.test(version$7)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$6 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const from$a = ({ name: name2, code: code2, encode: encode2 }) => new Hasher$3(name2, code2, encode2);
class Hasher$3 {
  constructor(name2, code2, encode2) {
    this.name = name2;
    this.code = code2;
    this.encode = encode2;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$9(this.code, result) : result.then((digest2) => create$9(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const name$7 = "raw";
const code$c = 85;
const encode$t = (node) => coerce$6(node);
const decode$A = (data) => coerce$6(data);
const raw = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$7,
  code: code$c,
  encode: encode$t,
  decode: decode$A
}, Symbol.toStringTag, { value: "Module" }));
const sha$3 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256$3 = from$a({
  name: "sha2-256",
  code: 18,
  encode: sha$3("SHA-256")
});
const sha512$3 = from$a({
  name: "sha2-512",
  code: 19,
  encode: sha$3("SHA-512")
});
const sha2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$3,
  sha512: sha512$3
}, Symbol.toStringTag, { value: "Module" }));
const readonly$7 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
const links$1 = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID$6.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links$1(element, elementPath);
          }
        }
      } else {
        const cid = CID$6.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links$1(value, path);
        }
      }
    }
  }
};
const tree$1 = function* (source, base3) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID$6.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID$6.asCID(element)) {
            yield* tree$1(element, elementPath);
          }
        }
      } else {
        yield* tree$1(value, path);
      }
    }
  }
};
const get$2 = (source, path) => {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID$6.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
class Block$1 {
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly$7(),
      bytes: readonly$7(),
      value: readonly$7(),
      asBlock: readonly$7()
    });
  }
  links() {
    return links$1(this.value, []);
  }
  tree() {
    return tree$1(this.value, []);
  }
  get(path = "/") {
    return get$2(this.value, path.split("/").filter(Boolean));
  }
}
const encode$s = async ({ value, codec, hasher }) => {
  if (typeof value === "undefined")
    throw new Error('Missing required argument "value"');
  if (!codec || !hasher)
    throw new Error("Missing required argument: codec or hasher");
  const bytes2 = codec.encode(value);
  const hash2 = await hasher.digest(bytes2);
  const cid = CID$6.create(1, codec.code, hash2);
  return new Block$1({
    value,
    bytes: bytes2,
    cid
  });
};
const createUnsafe$1 = ({
  bytes: bytes2,
  cid,
  value: maybeValue,
  codec
}) => {
  const value = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block$1({
    cid,
    bytes: bytes2,
    value
  });
};
const create$8 = async ({ bytes: bytes2, cid, hasher, codec }) => {
  if (!bytes2)
    throw new Error('Missing required argument "bytes"');
  if (!hasher)
    throw new Error('Missing required argument "hasher"');
  const value = codec.decode(bytes2);
  const hash2 = await hasher.digest(bytes2);
  if (!equals$e(cid.multihash.bytes, hash2.bytes)) {
    throw new Error("CID hash does not match bytes");
  }
  return createUnsafe$1({
    bytes: bytes2,
    cid,
    value,
    codec
  });
};
function mitt(n) {
  return { all: n = n || /* @__PURE__ */ new Map(), on: function(t, e) {
    var i2 = n.get(t);
    i2 ? i2.push(e) : n.set(t, [e]);
  }, off: function(t, e) {
    var i2 = n.get(t);
    i2 && (e ? i2.splice(i2.indexOf(e) >>> 0, 1) : n.set(t, []));
  }, emit: function(t, e) {
    var i2 = n.get(t);
    i2 && i2.slice().map(function(n2) {
      n2(e);
    }), (i2 = n.get("*")) && i2.slice().map(function(n2) {
      n2(t, e);
    });
  } };
}
const { isBinary } = byteslib;
const encode$r = (value) => {
  if (isBinary(value)) {
    return encode$s({ value, hasher: sha256$3, codec: raw });
  }
  return encode$s({ value, hasher: sha256$3, codec: dagCBOR });
};
const decode$z = ({ bytes: bytes2, cid }) => {
  let hasher, codec;
  const { code: code2 } = cid;
  const hashcode = cid.multihash.code || decode$C(cid.multihash).code;
  if (hashcode === 18) {
    hasher = sha256$3;
  } else {
    throw new Error("Unsupported hash function: " + hashcode);
  }
  if (code2 === 113) {
    codec = dagCBOR;
  } else if (code2 === 85) {
    codec = raw;
  } else {
    throw new Error("Unsupported codec: " + code2);
  }
  return create$8({ bytes: bytes2, cid, codec, hasher });
};
class Transaction {
  constructor() {
    Object.assign(this, mitt());
    this.blocks = [];
  }
  static create() {
    return new this();
  }
  static async load(buffer2) {
    const reader2 = await CarReader.fromBytes(buffer2);
    const [root] = await reader2.getRoots();
    const get2 = (cid) => reader2.get(cid).then((block) => decode$z(block)).then(({ value }) => value);
    return { root, get: get2 };
  }
  async add(obj) {
    const block = await encode$r(obj);
    this.last = block;
    this.blocks.push(block);
    this.emit("size", this.size);
    return block.cid;
  }
  async get(block) {
    const { cid, bytes: bytes2, value } = await decode$z(block);
    return { cid, bytes: bytes2, value };
  }
  undo() {
    return this.blocks.pop();
  }
  async commit() {
    const cid = this.last.cid;
    let size = 0;
    let headerSize = headerLength({ roots: [cid] });
    size += headerSize;
    for (const block of this.blocks) {
      size += blockLength(block);
    }
    const buffer2 = new Uint8Array(size);
    const writer2 = await createWriter(buffer2, { headerSize });
    writer2.addRoot(cid);
    for (const block of this.blocks) {
      writer2.write(block);
    }
    await writer2.close();
    return writer2.bytes;
  }
  get size() {
    if (!(this == null ? void 0 : this.last))
      return 0;
    const cid = this.last.cid;
    let size = 0;
    let headerSize = headerLength({ roots: [cid] });
    size += headerSize;
    for (const block of this.blocks) {
      size += blockLength(block);
    }
    return size;
  }
}
var objectSafeGet = get$1;
function get$1(obj, propsArg, defaultValue) {
  if (!obj) {
    return defaultValue;
  }
  var props, prop;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  while (props.length) {
    prop = props.shift();
    if (!obj) {
      return defaultValue;
    }
    obj = obj[prop];
    if (obj === void 0) {
      return defaultValue;
    }
  }
  return obj;
}
var encode_1$5 = encode$q;
var MSB$6 = 128, REST$6 = 127, MSBALL$5 = ~REST$6, INT$5 = Math.pow(2, 31);
function encode$q(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$5) {
    out[offset++] = num & 255 | MSB$6;
    num /= 128;
  }
  while (num & MSBALL$5) {
    out[offset++] = num & 255 | MSB$6;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$q.bytes = offset - oldOffset + 1;
  return out;
}
var decode$y = read$5;
var MSB$1$5 = 128, REST$1$5 = 127;
function read$5(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$5.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$5) << shift : (b2 & REST$1$5) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$5);
  read$5.bytes = counter - offset;
  return res;
}
var N1$5 = Math.pow(2, 7);
var N2$5 = Math.pow(2, 14);
var N3$5 = Math.pow(2, 21);
var N4$5 = Math.pow(2, 28);
var N5$5 = Math.pow(2, 35);
var N6$5 = Math.pow(2, 42);
var N7$5 = Math.pow(2, 49);
var N8$5 = Math.pow(2, 56);
var N9$5 = Math.pow(2, 63);
var length$6 = function(value) {
  return value < N1$5 ? 1 : value < N2$5 ? 2 : value < N3$5 ? 3 : value < N4$5 ? 4 : value < N5$5 ? 5 : value < N6$5 ? 6 : value < N7$5 ? 7 : value < N8$5 ? 8 : value < N9$5 ? 9 : 10;
};
var varint$5 = {
  encode: encode_1$5,
  decode: decode$y,
  encodingLength: length$6
};
var _brrp_varint$5 = varint$5;
const decode$x = (data, offset = 0) => {
  const code2 = _brrp_varint$5.decode(data, offset);
  return [
    code2,
    _brrp_varint$5.decode.bytes
  ];
};
const encodeTo$5 = (int, target, offset = 0) => {
  _brrp_varint$5.encode(int, target, offset);
  return target;
};
const encodingLength$5 = (int) => {
  return _brrp_varint$5.encodingLength(int);
};
const equals$c = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$5 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$5 = (str) => new TextEncoder().encode(str);
const toString$5 = (b2) => new TextDecoder().decode(b2);
const create$7 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$5(code2);
  const digestOffset = sizeOffset + encodingLength$5(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$5(code2, bytes2, 0);
  encodeTo$5(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$5(code2, size, digest2, bytes2);
};
const decode$w = (multihash) => {
  const bytes2 = coerce$5(multihash);
  const [code2, sizeOffset] = decode$x(bytes2);
  const [size, digestOffset] = decode$x(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$5(code2, size, digest2, bytes2);
};
const equals$b = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$c(a2.bytes, b2.bytes);
  }
};
class Digest$5 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$5(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$5 = base$5;
var _brrp__multiformats_scope_baseX$5 = src$5;
class Encoder$5 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$5 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$5(this, decoder);
  }
}
class ComposedDecoder$5 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$5(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$5 = (left, right) => new ComposedDecoder$5({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$5 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$5(name2, prefix, baseEncode);
    this.decoder = new Decoder$5(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$9 = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$5(name2, prefix, encode2, decode2);
const baseX$5 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$5(alphabet2, name2);
  return from$9({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$5(decode2(text))
  });
};
const decode$v = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$p = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$5 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$9({
    prefix,
    name: name2,
    encode(input) {
      return encode$p(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$v(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$5 = baseX$5({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr$1 = baseX$5({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: base58btc$5,
  base58flickr: base58flickr$1
}, Symbol.toStringTag, { value: "Module" }));
const base32$6 = rfc4648$5({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper$1 = rfc4648$5({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad$2 = rfc4648$5({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper$1 = rfc4648$5({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex$1 = rfc4648$5({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper$1 = rfc4648$5({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad$1 = rfc4648$5({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper$1 = rfc4648$5({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z$1 = rfc4648$5({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: base32$6,
  base32upper: base32upper$1,
  base32pad: base32pad$2,
  base32padupper: base32padupper$1,
  base32hex: base32hex$1,
  base32hexupper: base32hexupper$1,
  base32hexpad: base32hexpad$1,
  base32hexpadupper: base32hexpadupper$1,
  base32z: base32z$1
}, Symbol.toStringTag, { value: "Module" }));
class CID$5 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$5,
      byteLength: hidden$5,
      code: readonly$6,
      version: readonly$6,
      multihash: readonly$6,
      bytes: readonly$6,
      _baseCache: hidden$5,
      asCID: hidden$5
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$5) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$5) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$5.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$7(code2, digest2);
        return CID$5.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$b(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$5(bytes2, _baseCache, base3 || base58btc$5.encoder);
      default:
        return toStringV1$5(bytes2, _baseCache, base3 || base32$6.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$5(/^0\.0/, IS_CID_DEPRECATION$5);
    return !!(value && (value[cidSymbol$5] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$5) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$5(version2, code2, multihash, bytes2 || encodeCID$5(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$5] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$w(multihash);
      return CID$5.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$5) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$5}) block encoding`);
        } else {
          return new CID$5(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$5(version2, code2, digest2.bytes);
        return new CID$5(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$5.create(0, DAG_PB_CODE$5, digest2);
  }
  static createV1(code2, digest2) {
    return CID$5.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$5.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$5.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$5(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$5(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$5.createV0(digest2) : CID$5.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$x(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$5;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$5(source, base3);
    const cid = CID$5.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$5 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$5;
      return [
        base58btc$5.prefix,
        decoder.decode(`${base58btc$5.prefix}${source}`)
      ];
    }
    case base58btc$5.prefix: {
      const decoder = base3 || base58btc$5;
      return [
        base58btc$5.prefix,
        decoder.decode(source)
      ];
    }
    case base32$6.prefix: {
      const decoder = base3 || base32$6;
      return [
        base32$6.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$5 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$5.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$5 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$5 = 112;
const SHA_256_CODE$5 = 18;
const encodeCID$5 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$5(version2);
  const hashOffset = codeOffset + encodingLength$5(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$5(version2, bytes2, 0);
  encodeTo$5(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$5 = Symbol.for("@ipld/js-cid/CID");
const readonly$6 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$5 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$6 = "0.0.0-dev";
const deprecate$5 = (range, message) => {
  if (range.test(version$6)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$5 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
let nanoid$1 = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");
const identity$c = from$e({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$8(buf2),
  decode: (str) => fromString$8(str)
});
const identityBase$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$c
}, Symbol.toStringTag, { value: "Module" }));
const base2$6 = rfc4648$9({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: base2$6
}, Symbol.toStringTag, { value: "Module" }));
const base8$6 = rfc4648$9({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: base8$6
}, Symbol.toStringTag, { value: "Module" }));
const base10$6 = baseX$9({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: base10$6
}, Symbol.toStringTag, { value: "Module" }));
const base16$6 = rfc4648$9({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper$3 = rfc4648$9({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: base16$6,
  base16upper: base16upper$3
}, Symbol.toStringTag, { value: "Module" }));
const base36$6 = baseX$9({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper$3 = baseX$9({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: base36$6,
  base36upper: base36upper$3
}, Symbol.toStringTag, { value: "Module" }));
const base64$9 = rfc4648$9({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad$3 = rfc4648$9({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url$4 = rfc4648$9({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad$3 = rfc4648$9({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$a = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$9,
  base64pad: base64pad$3,
  base64url: base64url$4,
  base64urlpad: base64urlpad$3
}, Symbol.toStringTag, { value: "Module" }));
const alphabet$3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars$3 = alphabet$3.reduce((p2, c, i2) => {
  p2[i2] = c;
  return p2;
}, []);
const alphabetCharsToBytes$3 = alphabet$3.reduce((p2, c, i2) => {
  p2[c.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$o(data) {
  return data.reduce((p2, c) => {
    p2 += alphabetBytesToChars$3[c];
    return p2;
  }, "");
}
function decode$u(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes$3[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji$6 = from$e({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$o,
  decode: decode$u
});
const base256emoji$7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: base256emoji$6
}, Symbol.toStringTag, { value: "Module" }));
const from$8 = ({ name: name2, code: code2, encode: encode2 }) => new Hasher$2(name2, code2, encode2);
class Hasher$2 {
  constructor(name2, code2, encode2) {
    this.name = name2;
    this.code = code2;
    this.encode = encode2;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$c(this.code, result) : result.then((digest2) => create$c(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha$2 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256$2 = from$8({
  name: "sha2-256",
  code: 18,
  encode: sha$2("SHA-256")
});
const sha512$2 = from$8({
  name: "sha2-512",
  code: 19,
  encode: sha$2("SHA-512")
});
const sha2$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$2,
  sha512: sha512$2
}, Symbol.toStringTag, { value: "Module" }));
const code$b = 0;
const name$6 = "identity";
const encode$n = coerce$9;
const digest$3 = (input) => create$c(code$b, encode$n(input));
const identity$a = { code: code$b, name: name$6, encode: encode$n, digest: digest$3 };
const identity$b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$a
}, Symbol.toStringTag, { value: "Module" }));
const code$a = 85;
new TextEncoder();
new TextDecoder();
const bases$2 = { ...identityBase$3, ...base2$7, ...base8$7, ...base10$7, ...base16$7, ...base32$c, ...base36$7, ...base58$3, ...base64$a, ...base256emoji$7 };
({ ...sha2$2, ...identity$b });
function asUint8Array$2(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function allocUnsafe$2(size = 0) {
  var _a2;
  if (((_a2 = globalThis.Buffer) == null ? void 0 : _a2.allocUnsafe) != null) {
    return asUint8Array$2(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
function createCodec$2(name2, prefix, encode2, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode2
    },
    decoder: {
      decode: decode2
    }
  };
}
const string$2 = createCodec$2("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii$2 = createCodec$2("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe$2(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
const BASES$2 = {
  utf8: string$2,
  "utf-8": string$2,
  hex: bases$2.base16,
  latin1: ascii$2,
  ascii: ascii$2,
  binary: ascii$2,
  ...bases$2
};
function toString$4(array, encoding2 = "utf8") {
  const base3 = BASES$2[encoding2];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
function fromString$4(string2, encoding2 = "utf8") {
  const base3 = BASES$2[encoding2];
  if (base3 == null) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array$2(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
const pathSepS = "/";
const pathSepB = new TextEncoder().encode(pathSepS);
const pathSep = pathSepB[0];
class Key {
  constructor(s, clean) {
    if (typeof s === "string") {
      this._buf = fromString$4(s);
    } else if (s instanceof Uint8Array) {
      this._buf = s;
    } else {
      throw new Error("Invalid key, should be String of Uint8Array");
    }
    if (clean == null) {
      clean = true;
    }
    if (clean) {
      this.clean();
    }
    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
      throw new Error("Invalid key");
    }
  }
  toString(encoding2 = "utf8") {
    return toString$4(this._buf, encoding2);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(list) {
    return new Key(list.join(pathSepS));
  }
  static random() {
    return new Key(nanoid$1().replace(/-/g, ""));
  }
  static asKey(other) {
    if (other instanceof Uint8Array || typeof other === "string") {
      return new Key(other);
    }
    if (typeof other.uint8Array === "function") {
      return new Key(other.uint8Array());
    }
    return null;
  }
  clean() {
    if (this._buf == null || this._buf.byteLength === 0) {
      this._buf = pathSepB;
    }
    if (this._buf[0] !== pathSep) {
      const bytes2 = new Uint8Array(this._buf.byteLength + 1);
      bytes2.fill(pathSep, 0, 1);
      bytes2.set(this._buf, 1);
      this._buf = bytes2;
    }
    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
      this._buf = this._buf.subarray(0, -1);
    }
  }
  less(key) {
    const list1 = this.list();
    const list2 = key.list();
    for (let i2 = 0; i2 < list1.length; i2++) {
      if (list2.length < i2 + 1) {
        return false;
      }
      const c1 = list1[i2];
      const c2 = list2[i2];
      if (c1 < c2) {
        return true;
      } else if (c1 > c2) {
        return false;
      }
    }
    return list1.length < list2.length;
  }
  reverse() {
    return Key.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    const ns2 = this.namespaces();
    return ns2[ns2.length - 1];
  }
  list() {
    return this.toString().split(pathSepS).slice(1);
  }
  type() {
    return namespaceType(this.baseNamespace());
  }
  name() {
    return namespaceValue(this.baseNamespace());
  }
  instance(s) {
    return new Key(this.toString() + ":" + s);
  }
  path() {
    let p2 = this.parent().toString();
    if (!p2.endsWith(pathSepS)) {
      p2 += pathSepS;
    }
    p2 += this.type();
    return new Key(p2);
  }
  parent() {
    const list = this.list();
    if (list.length === 1) {
      return new Key(pathSepS);
    }
    return new Key(list.slice(0, -1).join(pathSepS));
  }
  child(key) {
    if (this.toString() === pathSepS) {
      return key;
    } else if (key.toString() === pathSepS) {
      return this;
    }
    return new Key(this.toString() + key.toString(), false);
  }
  isAncestorOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return other.toString().startsWith(this.toString());
  }
  isDecendantOf(other) {
    if (other.toString() === this.toString()) {
      return false;
    }
    return this.toString().startsWith(other.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...keys) {
    return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
  }
}
function namespaceType(ns2) {
  const parts = ns2.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns2) {
  const parts = ns2.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
const length$5 = async (iterator2) => {
  let count = 0;
  for await (const _2 of iterator2) {
    count++;
  }
  return count;
};
var itLength = length$5;
const code$9 = 85;
const log$7 = debug$1("ipfs:repo:migrator:migration-8");
function unwrap$1(blockstore) {
  if (blockstore.child) {
    return unwrap$1(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash$1(key) {
  try {
    const buf2 = base32$6.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID$5.decode(buf2).multihash.bytes;
    const multihashStr = base32$6.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err) {
    return key;
  }
}
function keyToCid$1(key) {
  try {
    const buf2 = base32$6.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest2 = decode$w(buf2);
    const multihash = base32$6.encode(CID$5.createV1(code$9, digest2).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process$3(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap$1(blockstore);
  const blockCount = await itLength(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log$7(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
const migration$4 = {
  version: 8,
  description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
  migrate: (backends, onProgress = () => {
  }) => {
    return process$3(backends, onProgress, keyToMultihash$1);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process$3(backends, onProgress, keyToCid$1);
  }
};
var encode_1$4 = encode$m;
var MSB$5 = 128, REST$5 = 127, MSBALL$4 = ~REST$5, INT$4 = Math.pow(2, 31);
function encode$m(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$4) {
    out[offset++] = num & 255 | MSB$5;
    num /= 128;
  }
  while (num & MSBALL$4) {
    out[offset++] = num & 255 | MSB$5;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$m.bytes = offset - oldOffset + 1;
  return out;
}
var decode$t = read$4;
var MSB$1$4 = 128, REST$1$4 = 127;
function read$4(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$4.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$4) << shift : (b2 & REST$1$4) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$4);
  read$4.bytes = counter - offset;
  return res;
}
var N1$4 = Math.pow(2, 7);
var N2$4 = Math.pow(2, 14);
var N3$4 = Math.pow(2, 21);
var N4$4 = Math.pow(2, 28);
var N5$4 = Math.pow(2, 35);
var N6$4 = Math.pow(2, 42);
var N7$4 = Math.pow(2, 49);
var N8$4 = Math.pow(2, 56);
var N9$4 = Math.pow(2, 63);
var length$4 = function(value) {
  return value < N1$4 ? 1 : value < N2$4 ? 2 : value < N3$4 ? 3 : value < N4$4 ? 4 : value < N5$4 ? 5 : value < N6$4 ? 6 : value < N7$4 ? 7 : value < N8$4 ? 8 : value < N9$4 ? 9 : 10;
};
var varint$4 = {
  encode: encode_1$4,
  decode: decode$t,
  encodingLength: length$4
};
var _brrp_varint$4 = varint$4;
const decode$s = (data, offset = 0) => {
  const code2 = _brrp_varint$4.decode(data, offset);
  return [
    code2,
    _brrp_varint$4.decode.bytes
  ];
};
const encodeTo$4 = (int, target, offset = 0) => {
  _brrp_varint$4.encode(int, target, offset);
  return target;
};
const encodingLength$4 = (int) => {
  return _brrp_varint$4.encodingLength(int);
};
const equals$a = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$4 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const create$6 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$4(code2);
  const digestOffset = sizeOffset + encodingLength$4(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$4(code2, bytes2, 0);
  encodeTo$4(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$4(code2, size, digest2, bytes2);
};
const decode$r = (multihash) => {
  const bytes2 = coerce$4(multihash);
  const [code2, sizeOffset] = decode$s(bytes2);
  const [size, digestOffset] = decode$s(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$4(code2, size, digest2, bytes2);
};
const equals$9 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$a(a2.bytes, b2.bytes);
  }
};
class Digest$4 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$4(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$4 = base$4;
var _brrp__multiformats_scope_baseX$4 = src$4;
class Encoder$4 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$4 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$4(this, decoder);
  }
}
class ComposedDecoder$4 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$4(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$4 = (left, right) => new ComposedDecoder$4({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$4 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$4(name2, prefix, baseEncode);
    this.decoder = new Decoder$4(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$7 = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$4(name2, prefix, encode2, decode2);
const baseX$4 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$4(alphabet2, name2);
  return from$7({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$4(decode2(text))
  });
};
const decode$q = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$l = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$4 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$7({
    prefix,
    name: name2,
    encode(input) {
      return encode$l(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$q(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$4 = baseX$4({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX$4({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base32$5 = rfc4648$4({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648$4({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class CID$4 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$4,
      byteLength: hidden$4,
      code: readonly$5,
      version: readonly$5,
      multihash: readonly$5,
      bytes: readonly$5,
      _baseCache: hidden$4,
      asCID: hidden$4
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$4) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$4) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$4.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$6(code2, digest2);
        return CID$4.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$9(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$4(bytes2, _baseCache, base3 || base58btc$4.encoder);
      default:
        return toStringV1$4(bytes2, _baseCache, base3 || base32$5.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$4(/^0\.0/, IS_CID_DEPRECATION$4);
    return !!(value && (value[cidSymbol$4] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$4) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$4(version2, code2, multihash, bytes2 || encodeCID$4(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$4] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$r(multihash);
      return CID$4.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$4) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$4}) block encoding`);
        } else {
          return new CID$4(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$4(version2, code2, digest2.bytes);
        return new CID$4(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$4.create(0, DAG_PB_CODE$4, digest2);
  }
  static createV1(code2, digest2) {
    return CID$4.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$4.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$4.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$4(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$4(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$4.createV0(digest2) : CID$4.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$s(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$4;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$4(source, base3);
    const cid = CID$4.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$4 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$4;
      return [
        base58btc$4.prefix,
        decoder.decode(`${base58btc$4.prefix}${source}`)
      ];
    }
    case base58btc$4.prefix: {
      const decoder = base3 || base58btc$4;
      return [
        base58btc$4.prefix,
        decoder.decode(source)
      ];
    }
    case base32$5.prefix: {
      const decoder = base3 || base32$5;
      return [
        base32$5.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$4 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$4.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$4 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$4 = 112;
const SHA_256_CODE$4 = 18;
const encodeCID$4 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$4(version2);
  const hashOffset = codeOffset + encodingLength$4(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$4(version2, bytes2, 0);
  encodeTo$4(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$4 = Symbol.for("@ipld/js-cid/CID");
const readonly$5 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$4 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$5 = "0.0.0-dev";
const deprecate$4 = (range, message) => {
  if (range.test(version$5)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$4 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const textDecoder$2 = new TextDecoder();
function decodeVarint(bytes2, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes2.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b2 = bytes2[offset++];
    v += shift < 28 ? (b2 & 127) << shift : (b2 & 127) * 2 ** shift;
    if (b2 < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes2, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes2, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes2.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes2.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes2, index) {
  let wire;
  [wire, index] = decodeVarint(bytes2, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes2) {
  const link = {};
  const l2 = bytes2.length;
  let index = 0;
  while (index < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      [link.Hash, index] = decodeBytes(bytes2, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      link.Name = textDecoder$2.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      [link.Tsize, index] = decodeVarint(bytes2, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l2) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes2) {
  const l2 = bytes2.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l2) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes2, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      [data, index] = decodeBytes(bytes2, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes2, index);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l2) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}
const textEncoder$4 = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
function encodeLink(link, bytes2) {
  let i2 = bytes2.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i2 = encodeVarint(bytes2, i2, link.Tsize) - 1;
    bytes2[i2] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder$4.encode(link.Name);
    i2 -= nameBytes.length;
    bytes2.set(nameBytes, i2);
    i2 = encodeVarint(bytes2, i2, nameBytes.length) - 1;
    bytes2[i2] = 18;
  }
  if (link.Hash) {
    i2 -= link.Hash.length;
    bytes2.set(link.Hash, i2);
    i2 = encodeVarint(bytes2, i2, link.Hash.length) - 1;
    bytes2[i2] = 10;
  }
  return bytes2.length - i2;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes2 = new Uint8Array(size);
  let i2 = size;
  if (node.Data) {
    i2 -= node.Data.length;
    bytes2.set(node.Data, i2);
    i2 = encodeVarint(bytes2, i2, node.Data.length) - 1;
    bytes2[i2] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes2.subarray(0, i2));
      i2 -= size2;
      i2 = encodeVarint(bytes2, i2, size2) - 1;
      bytes2[i2] = 18;
    }
  }
  return bytes2;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l2 = link.Hash.length;
    n += 1 + l2 + sov(l2);
  }
  if (typeof link.Name === "string") {
    const l2 = textEncoder$4.encode(link.Name).length;
    n += 1 + l2 + sov(l2);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l2 = node.Data.length;
    n += 1 + l2 + sov(l2);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l2 = sizeLink(link);
      n += 1 + l2 + sov(l2);
    }
  }
  return n;
}
function encodeVarint(bytes2, offset, v) {
  offset -= sov(v);
  const base3 = offset;
  while (v >= maxUInt32) {
    bytes2[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes2[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes2[offset] = v;
  return base3;
}
function sov(x2) {
  if (x2 % 2 === 0) {
    x2++;
  }
  return Math.floor((len64(x2) + 6) / 7);
}
function len64(x2) {
  let n = 0;
  if (x2 >= maxInt32) {
    x2 = Math.floor(x2 / maxInt32);
    n = 32;
  }
  if (x2 >= 1 << 16) {
    x2 >>>= 16;
    n += 16;
  }
  if (x2 >= 1 << 8) {
    x2 >>>= 8;
    n += 8;
  }
  return n + len8tab[x2];
}
const len8tab = [
  0,
  1,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8,
  8
];
const pbNodeProperties = [
  "Data",
  "Links"
];
const pbLinkProperties = [
  "Hash",
  "Name",
  "Tsize"
];
const textEncoder$3 = new TextEncoder();
function linkComparator(a2, b2) {
  if (a2 === b2) {
    return 0;
  }
  const abuf = a2.Name ? textEncoder$3.encode(a2.Name) : [];
  const bbuf = b2.Name ? textEncoder$3.encode(b2.Name) : [];
  let x2 = abuf.length;
  let y = bbuf.length;
  for (let i2 = 0, len2 = Math.min(x2, y); i2 < len2; ++i2) {
    if (abuf[i2] !== bbuf[i2]) {
      x2 = abuf[i2];
      y = bbuf[i2];
      break;
    }
  }
  return x2 < y ? -1 : y < x2 ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p2) => !properties.includes(p2));
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i2 = 0; i2 < node.Links.length; i2++) {
    const link = node.Links[i2];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i2 > 0 && linkComparator(link, node.Links[i2 - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
const code$8 = 112;
function encode$k(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l2) => {
      const link = {};
      if (l2.Hash) {
        link.Hash = l2.Hash.bytes;
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode$p(bytes2) {
  const pbn = decodeNode(bytes2);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l2) => {
      const link = {};
      try {
        link.Hash = CID$4.decode(l2.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l2.Name !== void 0) {
        link.Name = l2.Name;
      }
      if (l2.Tsize !== void 0) {
        link.Tsize = l2.Tsize;
      }
      return link;
    });
  }
  return node;
}
var minimal$1 = { exports: {} };
var indexMinimal = {};
var minimal = {};
var aspromise = asPromise;
function asPromise(fn2, ctx) {
  var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
  while (index < arguments.length)
    params[offset++] = arguments[index++];
  return new Promise(function executor(resolve, reject) {
    params[offset] = function callback(err) {
      if (pending) {
        pending = false;
        if (err)
          reject(err);
        else {
          var params2 = new Array(arguments.length - 1), offset2 = 0;
          while (offset2 < params2.length)
            params2[offset2++] = arguments[offset2];
          resolve.apply(null, params2);
        }
      }
    };
    try {
      fn2.apply(ctx || null, params);
    } catch (err) {
      if (pending) {
        pending = false;
        reject(err);
      }
    }
  });
}
var base64$8 = {};
(function(exports) {
  var base642 = exports;
  base642.length = function length2(string2) {
    var p2 = string2.length;
    if (!p2)
      return 0;
    var n = 0;
    while (--p2 % 4 > 1 && string2.charAt(p2) === "=")
      ++n;
    return Math.ceil(string2.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i2 = 0; i2 < 64; )
    s64[b64[i2] = i2 < 26 ? i2 + 65 : i2 < 52 ? i2 + 71 : i2 < 62 ? i2 - 4 : i2 - 59 | 43] = i2++;
  base642.encode = function encode2(buffer2, start, end2) {
    var parts = null, chunk = [];
    var i3 = 0, j = 0, t;
    while (start < end2) {
      var b2 = buffer2[start++];
      switch (j) {
        case 0:
          chunk[i3++] = b64[b2 >> 2];
          t = (b2 & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i3++] = b64[t | b2 >> 4];
          t = (b2 & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i3++] = b64[t | b2 >> 6];
          chunk[i3++] = b64[b2 & 63];
          j = 0;
          break;
      }
      if (i3 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i3 = 0;
      }
    }
    if (j) {
      chunk[i3++] = b64[t];
      chunk[i3++] = 61;
      if (j === 1)
        chunk[i3++] = 61;
    }
    if (parts) {
      if (i3)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i3)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i3));
  };
  var invalidEncoding = "invalid encoding";
  base642.decode = function decode2(string2, buffer2, offset) {
    var start = offset;
    var j = 0, t;
    for (var i3 = 0; i3 < string2.length; ) {
      var c = string2.charCodeAt(i3++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer2[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer2[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base642.test = function test(string2) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
  };
})(base64$8);
var eventemitter = EventEmitter$2;
function EventEmitter$2() {
  this._listeners = {};
}
EventEmitter$2.prototype.on = function on(evt, fn2, ctx) {
  (this._listeners[evt] || (this._listeners[evt] = [])).push({
    fn: fn2,
    ctx: ctx || this
  });
  return this;
};
EventEmitter$2.prototype.off = function off(evt, fn2) {
  if (evt === void 0)
    this._listeners = {};
  else {
    if (fn2 === void 0)
      this._listeners[evt] = [];
    else {
      var listeners2 = this._listeners[evt];
      for (var i2 = 0; i2 < listeners2.length; )
        if (listeners2[i2].fn === fn2)
          listeners2.splice(i2, 1);
        else
          ++i2;
    }
  }
  return this;
};
EventEmitter$2.prototype.emit = function emit2(evt) {
  var listeners2 = this._listeners[evt];
  if (listeners2) {
    var args = [], i2 = 1;
    for (; i2 < arguments.length; )
      args.push(arguments[i2++]);
    for (i2 = 0; i2 < listeners2.length; )
      listeners2[i2].fn.apply(listeners2[i2++].ctx, args);
  }
  return this;
};
var float = factory(factory);
function factory(exports) {
  if (typeof Float32Array !== "undefined")
    (function() {
      var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le2 = f8b[3] === 128;
      function writeFloat_f32_cpy(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
      }
      function writeFloat_f32_rev(val, buf2, pos) {
        f32[0] = val;
        buf2[pos] = f8b[3];
        buf2[pos + 1] = f8b[2];
        buf2[pos + 2] = f8b[1];
        buf2[pos + 3] = f8b[0];
      }
      exports.writeFloatLE = le2 ? writeFloat_f32_cpy : writeFloat_f32_rev;
      exports.writeFloatBE = le2 ? writeFloat_f32_rev : writeFloat_f32_cpy;
      function readFloat_f32_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        return f32[0];
      }
      function readFloat_f32_rev(buf2, pos) {
        f8b[3] = buf2[pos];
        f8b[2] = buf2[pos + 1];
        f8b[1] = buf2[pos + 2];
        f8b[0] = buf2[pos + 3];
        return f32[0];
      }
      exports.readFloatLE = le2 ? readFloat_f32_cpy : readFloat_f32_rev;
      exports.readFloatBE = le2 ? readFloat_f32_rev : readFloat_f32_cpy;
    })();
  else
    (function() {
      function writeFloat_ieee754(writeUint, val, buf2, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0)
          writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos);
        else if (isNaN(val))
          writeUint(2143289344, buf2, pos);
        else if (val > 34028234663852886e22)
          writeUint((sign << 31 | 2139095040) >>> 0, buf2, pos);
        else if (val < 11754943508222875e-54)
          writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
        else {
          var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
          writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
        }
      }
      exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
      exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
      function readFloat_ieee754(readUint, buf2, pos) {
        var uint = readUint(buf2, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
        return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
      }
      exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
      exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
  if (typeof Float64Array !== "undefined")
    (function() {
      var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le2 = f8b[7] === 128;
      function writeDouble_f64_cpy(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[0];
        buf2[pos + 1] = f8b[1];
        buf2[pos + 2] = f8b[2];
        buf2[pos + 3] = f8b[3];
        buf2[pos + 4] = f8b[4];
        buf2[pos + 5] = f8b[5];
        buf2[pos + 6] = f8b[6];
        buf2[pos + 7] = f8b[7];
      }
      function writeDouble_f64_rev(val, buf2, pos) {
        f64[0] = val;
        buf2[pos] = f8b[7];
        buf2[pos + 1] = f8b[6];
        buf2[pos + 2] = f8b[5];
        buf2[pos + 3] = f8b[4];
        buf2[pos + 4] = f8b[3];
        buf2[pos + 5] = f8b[2];
        buf2[pos + 6] = f8b[1];
        buf2[pos + 7] = f8b[0];
      }
      exports.writeDoubleLE = le2 ? writeDouble_f64_cpy : writeDouble_f64_rev;
      exports.writeDoubleBE = le2 ? writeDouble_f64_rev : writeDouble_f64_cpy;
      function readDouble_f64_cpy(buf2, pos) {
        f8b[0] = buf2[pos];
        f8b[1] = buf2[pos + 1];
        f8b[2] = buf2[pos + 2];
        f8b[3] = buf2[pos + 3];
        f8b[4] = buf2[pos + 4];
        f8b[5] = buf2[pos + 5];
        f8b[6] = buf2[pos + 6];
        f8b[7] = buf2[pos + 7];
        return f64[0];
      }
      function readDouble_f64_rev(buf2, pos) {
        f8b[7] = buf2[pos];
        f8b[6] = buf2[pos + 1];
        f8b[5] = buf2[pos + 2];
        f8b[4] = buf2[pos + 3];
        f8b[3] = buf2[pos + 4];
        f8b[2] = buf2[pos + 5];
        f8b[1] = buf2[pos + 6];
        f8b[0] = buf2[pos + 7];
        return f64[0];
      }
      exports.readDoubleLE = le2 ? readDouble_f64_cpy : readDouble_f64_rev;
      exports.readDoubleBE = le2 ? readDouble_f64_rev : readDouble_f64_cpy;
    })();
  else
    (function() {
      function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
        var sign = val < 0 ? 1 : 0;
        if (sign)
          val = -val;
        if (val === 0) {
          writeUint(0, buf2, pos + off0);
          writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos + off1);
        } else if (isNaN(val)) {
          writeUint(0, buf2, pos + off0);
          writeUint(2146959360, buf2, pos + off1);
        } else if (val > 17976931348623157e292) {
          writeUint(0, buf2, pos + off0);
          writeUint((sign << 31 | 2146435072) >>> 0, buf2, pos + off1);
        } else {
          var mantissa;
          if (val < 22250738585072014e-324) {
            mantissa = val / 5e-324;
            writeUint(mantissa >>> 0, buf2, pos + off0);
            writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
          } else {
            var exponent = Math.floor(Math.log(val) / Math.LN2);
            if (exponent === 1024)
              exponent = 1023;
            mantissa = val * Math.pow(2, -exponent);
            writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
            writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
          }
        }
      }
      exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
      exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
      function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
        var lo2 = readUint(buf2, pos + off0), hi2 = readUint(buf2, pos + off1);
        var sign = (hi2 >> 31) * 2 + 1, exponent = hi2 >>> 20 & 2047, mantissa = 4294967296 * (hi2 & 1048575) + lo2;
        return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
      }
      exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
      exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
  return exports;
}
function writeUintLE(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf2, pos) {
  buf2[pos] = val >>> 24;
  buf2[pos + 1] = val >>> 16 & 255;
  buf2[pos + 2] = val >>> 8 & 255;
  buf2[pos + 3] = val & 255;
}
function readUintLE(buf2, pos) {
  return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
}
function readUintBE(buf2, pos) {
  return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
}
var inquire_1 = inquire;
function inquire(moduleName) {
  try {
    var mod = eval("quire".replace(/^/, "re"))(moduleName);
    if (mod && (mod.length || Object.keys(mod).length))
      return mod;
  } catch (e) {
  }
  return null;
}
var utf8$2 = {};
(function(exports) {
  var utf82 = exports;
  utf82.length = function utf8_length(string2) {
    var len2 = 0, c = 0;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c = string2.charCodeAt(i2);
      if (c < 128)
        len2 += 1;
      else if (c < 2048)
        len2 += 2;
      else if ((c & 64512) === 55296 && (string2.charCodeAt(i2 + 1) & 64512) === 56320) {
        ++i2;
        len2 += 4;
      } else
        len2 += 3;
    }
    return len2;
  };
  utf82.read = function utf8_read(buffer2, start, end2) {
    var len2 = end2 - start;
    if (len2 < 1)
      return "";
    var parts = null, chunk = [], i2 = 0, t;
    while (start < end2) {
      t = buffer2[start++];
      if (t < 128)
        chunk[i2++] = t;
      else if (t > 191 && t < 224)
        chunk[i2++] = (t & 31) << 6 | buffer2[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
        chunk[i2++] = 55296 + (t >> 10);
        chunk[i2++] = 56320 + (t & 1023);
      } else
        chunk[i2++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  utf82.write = function utf8_write(string2, buffer2, offset) {
    var start = offset, c1, c2;
    for (var i2 = 0; i2 < string2.length; ++i2) {
      c1 = string2.charCodeAt(i2);
      if (c1 < 128) {
        buffer2[offset++] = c1;
      } else if (c1 < 2048) {
        buffer2[offset++] = c1 >> 6 | 192;
        buffer2[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i2 + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i2;
        buffer2[offset++] = c1 >> 18 | 240;
        buffer2[offset++] = c1 >> 12 & 63 | 128;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      } else {
        buffer2[offset++] = c1 >> 12 | 224;
        buffer2[offset++] = c1 >> 6 & 63 | 128;
        buffer2[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
})(utf8$2);
var pool_1 = pool;
function pool(alloc3, slice2, size) {
  var SIZE = size || 8192;
  var MAX = SIZE >>> 1;
  var slab = null;
  var offset = SIZE;
  return function pool_alloc(size2) {
    if (size2 < 1 || size2 > MAX)
      return alloc3(size2);
    if (offset + size2 > SIZE) {
      slab = alloc3(SIZE);
      offset = 0;
    }
    var buf2 = slice2.call(slab, offset, offset += size2);
    if (offset & 7)
      offset = (offset | 7) + 1;
    return buf2;
  };
}
var longbits;
var hasRequiredLongbits;
function requireLongbits() {
  if (hasRequiredLongbits)
    return longbits;
  hasRequiredLongbits = 1;
  longbits = LongBits2;
  var util2 = requireMinimal();
  function LongBits2(lo2, hi2) {
    this.lo = lo2 >>> 0;
    this.hi = hi2 >>> 0;
  }
  var zero = LongBits2.zero = new LongBits2(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits2.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits2.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo2 = value >>> 0, hi2 = (value - lo2) / 4294967296 >>> 0;
    if (sign) {
      hi2 = ~hi2 >>> 0;
      lo2 = ~lo2 >>> 0;
      if (++lo2 > 4294967295) {
        lo2 = 0;
        if (++hi2 > 4294967295)
          hi2 = 0;
      }
    }
    return new LongBits2(lo2, hi2);
  };
  LongBits2.from = function from2(value) {
    if (typeof value === "number")
      return LongBits2.fromNumber(value);
    if (util2.isString(value)) {
      if (util2.Long)
        value = util2.Long.fromString(value);
      else
        return LongBits2.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits2(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits2.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo2 = ~this.lo + 1 >>> 0, hi2 = ~this.hi >>> 0;
      if (!lo2)
        hi2 = hi2 + 1 >>> 0;
      return -(lo2 + hi2 * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits2.prototype.toLong = function toLong(unsigned) {
    return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits2.fromHash = function fromHash(hash2) {
    if (hash2 === zeroHash)
      return zero;
    return new LongBits2(
      (charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0,
      (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0
    );
  };
  LongBits2.prototype.toHash = function toHash() {
    return String.fromCharCode(
      this.lo & 255,
      this.lo >>> 8 & 255,
      this.lo >>> 16 & 255,
      this.lo >>> 24,
      this.hi & 255,
      this.hi >>> 8 & 255,
      this.hi >>> 16 & 255,
      this.hi >>> 24
    );
  };
  LongBits2.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits2.prototype.length = function length2() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
  return longbits;
}
var hasRequiredMinimal;
function requireMinimal() {
  if (hasRequiredMinimal)
    return minimal;
  hasRequiredMinimal = 1;
  (function(exports) {
    var util2 = exports;
    util2.asPromise = aspromise;
    util2.base64 = base64$8;
    util2.EventEmitter = eventemitter;
    util2.float = float;
    util2.inquire = inquire_1;
    util2.utf8 = utf8$2;
    util2.pool = pool_1;
    util2.LongBits = requireLongbits();
    util2.isNode = Boolean(typeof {} !== "undefined" && {} && {}.process && {}.process.versions && {}.process.versions.node);
    util2.global = util2.isNode && {} || typeof window !== "undefined" && window || typeof self !== "undefined" && self || commonjsGlobal;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util2.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util2.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util2.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util2.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util2.isset = util2.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = util2.global.dcodeIO && util2.global.dcodeIO.Long || util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = function longToHash(value) {
      return value ? util2.LongBits.from(value).toHash() : util2.LongBits.zeroHash;
    };
    util2.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util2.LongBits.fromHash(hash2);
      if (util2.Long)
        return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge2(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i2 = 0; i2 < keys.length; ++i2)
        if (dst[keys[i2]] === void 0 || !ifNotSet)
          dst[keys[i2]] = src2[keys[i2]];
      return dst;
    }
    util2.merge = merge2;
    util2.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name2) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge2(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name2;
          },
          set: void 0,
          enumerable: false,
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i2 = 0; i2 < fieldNames.length; ++i2)
        fieldMap[fieldNames[i2]] = 1;
      return function() {
        for (var keys = Object.keys(this), i3 = keys.length - 1; i3 > -1; --i3)
          if (fieldMap[keys[i3]] === 1 && this[keys[i3]] !== void 0 && this[keys[i3]] !== null)
            return keys[i3];
      };
    };
    util2.oneOfSetter = function setOneOf(fieldNames) {
      return function(name2) {
        for (var i2 = 0; i2 < fieldNames.length; ++i2)
          if (fieldNames[i2] !== name2)
            delete this[fieldNames[i2]];
      };
    };
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding2) {
        return new Buffer2(value, encoding2);
      };
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  })(minimal);
  return minimal;
}
var writer = Writer$1;
var util$4 = requireMinimal();
var BufferWriter$1;
var LongBits$1 = util$4.LongBits, base64$7 = util$4.base64, utf8$1 = util$4.utf8;
function Op(fn2, len2, val) {
  this.fn = fn2;
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
function noop$2() {
}
function State(writer2) {
  this.head = writer2.head;
  this.tail = writer2.tail;
  this.len = writer2.len;
  this.next = writer2.states;
}
function Writer$1() {
  this.len = 0;
  this.head = new Op(noop$2, 0, 0);
  this.tail = this.head;
  this.states = null;
}
var create$5 = function create2() {
  return util$4.Buffer ? function create_buffer_setup() {
    return (Writer$1.create = function create_buffer() {
      return new BufferWriter$1();
    })();
  } : function create_array3() {
    return new Writer$1();
  };
};
Writer$1.create = create$5();
Writer$1.alloc = function alloc2(size) {
  return new util$4.Array(size);
};
if (util$4.Array !== Array)
  Writer$1.alloc = util$4.pool(Writer$1.alloc, util$4.Array.prototype.subarray);
Writer$1.prototype._push = function push(fn2, len2, val) {
  this.tail = this.tail.next = new Op(fn2, len2, val);
  this.len += len2;
  return this;
};
function writeByte(val, buf2, pos) {
  buf2[pos] = val & 255;
}
function writeVarint32(val, buf2, pos) {
  while (val > 127) {
    buf2[pos++] = val & 127 | 128;
    val >>>= 7;
  }
  buf2[pos] = val;
}
function VarintOp(len2, val) {
  this.len = len2;
  this.next = void 0;
  this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
Writer$1.prototype.uint32 = function write_uint32(value) {
  this.len += (this.tail = this.tail.next = new VarintOp(
    (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
    value
  )).len;
  return this;
};
Writer$1.prototype.int32 = function write_int32(value) {
  return value < 0 ? this._push(writeVarint64, 10, LongBits$1.fromNumber(value)) : this.uint32(value);
};
Writer$1.prototype.sint32 = function write_sint32(value) {
  return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf2, pos) {
  while (val.hi) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
    val.hi >>>= 7;
  }
  while (val.lo > 127) {
    buf2[pos++] = val.lo & 127 | 128;
    val.lo = val.lo >>> 7;
  }
  buf2[pos++] = val.lo;
}
Writer$1.prototype.uint64 = function write_uint64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.int64 = Writer$1.prototype.uint64;
Writer$1.prototype.sint64 = function write_sint64(value) {
  var bits = LongBits$1.from(value).zzEncode();
  return this._push(writeVarint64, bits.length(), bits);
};
Writer$1.prototype.bool = function write_bool(value) {
  return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf2, pos) {
  buf2[pos] = val & 255;
  buf2[pos + 1] = val >>> 8 & 255;
  buf2[pos + 2] = val >>> 16 & 255;
  buf2[pos + 3] = val >>> 24;
}
Writer$1.prototype.fixed32 = function write_fixed32(value) {
  return this._push(writeFixed32, 4, value >>> 0);
};
Writer$1.prototype.sfixed32 = Writer$1.prototype.fixed32;
Writer$1.prototype.fixed64 = function write_fixed64(value) {
  var bits = LongBits$1.from(value);
  return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
Writer$1.prototype.sfixed64 = Writer$1.prototype.fixed64;
Writer$1.prototype.float = function write_float(value) {
  return this._push(util$4.float.writeFloatLE, 4, value);
};
Writer$1.prototype.double = function write_double(value) {
  return this._push(util$4.float.writeDoubleLE, 8, value);
};
var writeBytes = util$4.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
  buf2.set(val, pos);
} : function writeBytes_for(val, buf2, pos) {
  for (var i2 = 0; i2 < val.length; ++i2)
    buf2[pos + i2] = val[i2];
};
Writer$1.prototype.bytes = function write_bytes(value) {
  var len2 = value.length >>> 0;
  if (!len2)
    return this._push(writeByte, 1, 0);
  if (util$4.isString(value)) {
    var buf2 = Writer$1.alloc(len2 = base64$7.length(value));
    base64$7.decode(value, buf2, 0);
    value = buf2;
  }
  return this.uint32(len2)._push(writeBytes, len2, value);
};
Writer$1.prototype.string = function write_string(value) {
  var len2 = utf8$1.length(value);
  return len2 ? this.uint32(len2)._push(utf8$1.write, len2, value) : this._push(writeByte, 1, 0);
};
Writer$1.prototype.fork = function fork() {
  this.states = new State(this);
  this.head = this.tail = new Op(noop$2, 0, 0);
  this.len = 0;
  return this;
};
Writer$1.prototype.reset = function reset() {
  if (this.states) {
    this.head = this.states.head;
    this.tail = this.states.tail;
    this.len = this.states.len;
    this.states = this.states.next;
  } else {
    this.head = this.tail = new Op(noop$2, 0, 0);
    this.len = 0;
  }
  return this;
};
Writer$1.prototype.ldelim = function ldelim() {
  var head = this.head, tail = this.tail, len2 = this.len;
  this.reset().uint32(len2);
  if (len2) {
    this.tail.next = head.next;
    this.tail = tail;
    this.len += len2;
  }
  return this;
};
Writer$1.prototype.finish = function finish() {
  var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
  while (head) {
    head.fn(head.val, buf2, pos);
    pos += head.len;
    head = head.next;
  }
  return buf2;
};
Writer$1._configure = function(BufferWriter_) {
  BufferWriter$1 = BufferWriter_;
  Writer$1.create = create$5();
  BufferWriter$1._configure();
};
var writer_buffer = BufferWriter;
var Writer = writer;
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util$3 = requireMinimal();
function BufferWriter() {
  Writer.call(this);
}
BufferWriter._configure = function() {
  BufferWriter.alloc = util$3._Buffer_allocUnsafe;
  BufferWriter.writeBytesBuffer = util$3.Buffer && util$3.Buffer.prototype instanceof Uint8Array && util$3.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
    buf2.set(val, pos);
  } : function writeBytesBuffer_copy(val, buf2, pos) {
    if (val.copy)
      val.copy(buf2, pos, 0, val.length);
    else
      for (var i2 = 0; i2 < val.length; )
        buf2[pos++] = val[i2++];
  };
};
BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
  if (util$3.isString(value))
    value = util$3._Buffer_from(value, "base64");
  var len2 = value.length >>> 0;
  this.uint32(len2);
  if (len2)
    this._push(BufferWriter.writeBytesBuffer, len2, value);
  return this;
};
function writeStringBuffer(val, buf2, pos) {
  if (val.length < 40)
    util$3.utf8.write(val, buf2, pos);
  else if (buf2.utf8Write)
    buf2.utf8Write(val, pos);
  else
    buf2.write(val, pos);
}
BufferWriter.prototype.string = function write_string_buffer(value) {
  var len2 = util$3.Buffer.byteLength(value);
  this.uint32(len2);
  if (len2)
    this._push(writeStringBuffer, len2, value);
  return this;
};
BufferWriter._configure();
var reader = Reader$1;
var util$2 = requireMinimal();
var BufferReader$1;
var LongBits = util$2.LongBits, utf8 = util$2.utf8;
function indexOutOfRange(reader2, writeLength) {
  return RangeError("index out of range: " + reader2.pos + " + " + (writeLength || 1) + " > " + reader2.len);
}
function Reader$1(buffer2) {
  this.buf = buffer2;
  this.pos = 0;
  this.len = buffer2.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
  if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
} : function create_array2(buffer2) {
  if (Array.isArray(buffer2))
    return new Reader$1(buffer2);
  throw Error("illegal buffer");
};
var create$4 = function create3() {
  return util$2.Buffer ? function create_buffer_setup(buffer2) {
    return (Reader$1.create = function create_buffer(buffer3) {
      return util$2.Buffer.isBuffer(buffer3) ? new BufferReader$1(buffer3) : create_array(buffer3);
    })(buffer2);
  } : create_array;
};
Reader$1.create = create$4();
Reader$1.prototype._slice = util$2.Array.prototype.subarray || util$2.Array.prototype.slice;
Reader$1.prototype.uint32 = function read_uint32_setup() {
  var value = 4294967295;
  return function read_uint32() {
    value = (this.buf[this.pos] & 127) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
    if (this.buf[this.pos++] < 128)
      return value;
    if ((this.pos += 5) > this.len) {
      this.pos = this.len;
      throw indexOutOfRange(this, 10);
    }
    return value;
  };
}();
Reader$1.prototype.int32 = function read_int32() {
  return this.uint32() | 0;
};
Reader$1.prototype.sint32 = function read_sint32() {
  var value = this.uint32();
  return value >>> 1 ^ -(value & 1) | 0;
};
function readLongVarint() {
  var bits = new LongBits(0, 0);
  var i2 = 0;
  if (this.len - this.pos > 4) {
    for (; i2 < 4; ++i2) {
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
    bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
    if (this.buf[this.pos++] < 128)
      return bits;
    i2 = 0;
  } else {
    for (; i2 < 3; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i2 * 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
    bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i2 * 7) >>> 0;
    return bits;
  }
  if (this.len - this.pos > 4) {
    for (; i2 < 5; ++i2) {
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  } else {
    for (; i2 < 5; ++i2) {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i2 * 7 + 3) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
    }
  }
  throw Error("invalid varint encoding");
}
Reader$1.prototype.bool = function read_bool() {
  return this.uint32() !== 0;
};
function readFixed32_end(buf2, end2) {
  return (buf2[end2 - 4] | buf2[end2 - 3] << 8 | buf2[end2 - 2] << 16 | buf2[end2 - 1] << 24) >>> 0;
}
Reader$1.prototype.fixed32 = function read_fixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4);
};
Reader$1.prototype.sfixed32 = function read_sfixed32() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  return readFixed32_end(this.buf, this.pos += 4) | 0;
};
function readFixed64() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 8);
  return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
Reader$1.prototype.float = function read_float() {
  if (this.pos + 4 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readFloatLE(this.buf, this.pos);
  this.pos += 4;
  return value;
};
Reader$1.prototype.double = function read_double() {
  if (this.pos + 8 > this.len)
    throw indexOutOfRange(this, 4);
  var value = util$2.float.readDoubleLE(this.buf, this.pos);
  this.pos += 8;
  return value;
};
Reader$1.prototype.bytes = function read_bytes() {
  var length2 = this.uint32(), start = this.pos, end2 = this.pos + length2;
  if (end2 > this.len)
    throw indexOutOfRange(this, length2);
  this.pos += length2;
  if (Array.isArray(this.buf))
    return this.buf.slice(start, end2);
  return start === end2 ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end2);
};
Reader$1.prototype.string = function read_string() {
  var bytes2 = this.bytes();
  return utf8.read(bytes2, 0, bytes2.length);
};
Reader$1.prototype.skip = function skip(length2) {
  if (typeof length2 === "number") {
    if (this.pos + length2 > this.len)
      throw indexOutOfRange(this, length2);
    this.pos += length2;
  } else {
    do {
      if (this.pos >= this.len)
        throw indexOutOfRange(this);
    } while (this.buf[this.pos++] & 128);
  }
  return this;
};
Reader$1.prototype.skipType = function(wireType) {
  switch (wireType) {
    case 0:
      this.skip();
      break;
    case 1:
      this.skip(8);
      break;
    case 2:
      this.skip(this.uint32());
      break;
    case 3:
      while ((wireType = this.uint32() & 7) !== 4) {
        this.skipType(wireType);
      }
      break;
    case 5:
      this.skip(4);
      break;
    default:
      throw Error("invalid wire type " + wireType + " at offset " + this.pos);
  }
  return this;
};
Reader$1._configure = function(BufferReader_) {
  BufferReader$1 = BufferReader_;
  Reader$1.create = create$4();
  BufferReader$1._configure();
  var fn2 = util$2.Long ? "toLong" : "toNumber";
  util$2.merge(Reader$1.prototype, {
    int64: function read_int64() {
      return readLongVarint.call(this)[fn2](false);
    },
    uint64: function read_uint64() {
      return readLongVarint.call(this)[fn2](true);
    },
    sint64: function read_sint64() {
      return readLongVarint.call(this).zzDecode()[fn2](false);
    },
    fixed64: function read_fixed64() {
      return readFixed64.call(this)[fn2](true);
    },
    sfixed64: function read_sfixed64() {
      return readFixed64.call(this)[fn2](false);
    }
  });
};
var reader_buffer = BufferReader;
var Reader = reader;
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util$1 = requireMinimal();
function BufferReader(buffer2) {
  Reader.call(this, buffer2);
}
BufferReader._configure = function() {
  if (util$1.Buffer)
    BufferReader.prototype._slice = util$1.Buffer.prototype.slice;
};
BufferReader.prototype.string = function read_string_buffer() {
  var len2 = this.uint32();
  return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len2, this.len));
};
BufferReader._configure();
var rpc = {};
var service = Service;
var util = requireMinimal();
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
function Service(rpcImpl, requestDelimited, responseDelimited) {
  if (typeof rpcImpl !== "function")
    throw TypeError("rpcImpl must be a function");
  util.EventEmitter.call(this);
  this.rpcImpl = rpcImpl;
  this.requestDelimited = Boolean(requestDelimited);
  this.responseDelimited = Boolean(responseDelimited);
}
Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
  if (!request)
    throw TypeError("request must be specified");
  var self2 = this;
  if (!callback)
    return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
  if (!self2.rpcImpl) {
    setTimeout(function() {
      callback(Error("already ended"));
    }, 0);
    return void 0;
  }
  try {
    return self2.rpcImpl(
      method,
      requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
      function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      }
    );
  } catch (err) {
    self2.emit("error", err, method);
    setTimeout(function() {
      callback(err);
    }, 0);
    return void 0;
  }
};
Service.prototype.end = function end(endedByRPC) {
  if (this.rpcImpl) {
    if (!endedByRPC)
      this.rpcImpl(null, null, null);
    this.rpcImpl = null;
    this.emit("end").off();
  }
  return this;
};
(function(exports) {
  var rpc2 = exports;
  rpc2.Service = service;
})(rpc);
var roots = {};
(function(exports) {
  var protobuf = exports;
  protobuf.build = "minimal";
  protobuf.Writer = writer;
  protobuf.BufferWriter = writer_buffer;
  protobuf.Reader = reader;
  protobuf.BufferReader = reader_buffer;
  protobuf.util = requireMinimal();
  protobuf.rpc = rpc;
  protobuf.roots = roots;
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
})(indexMinimal);
(function(module) {
  module.exports = indexMinimal;
})(minimal$1);
const $protobuf = /* @__PURE__ */ getDefaultExportFromCjs(minimal$1.exports);
const $Reader$5 = $protobuf.Reader, $Writer$5 = $protobuf.Writer;
$protobuf.util;
const $root$5 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const ipfs = $root$5.ipfs = (() => {
  const ipfs2 = {};
  ipfs2.pin = function() {
    const pin = {};
    pin.Set = function() {
      function Set2(p2) {
        if (p2) {
          for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
            if (p2[ks2[i2]] != null)
              this[ks2[i2]] = p2[ks2[i2]];
        }
      }
      Set2.prototype.version = 0;
      Set2.prototype.fanout = 0;
      Set2.prototype.seed = 0;
      Set2.encode = function encode2(m, w) {
        if (!w)
          w = $Writer$5.create();
        if (m.version != null && Object.hasOwnProperty.call(m, "version"))
          w.uint32(8).uint32(m.version);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(16).uint32(m.fanout);
        if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
          w.uint32(29).fixed32(m.seed);
        return w;
      };
      Set2.decode = function decode2(r, l2) {
        if (!(r instanceof $Reader$5))
          r = $Reader$5.create(r);
        var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$5.ipfs.pin.Set();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.version = r.uint32();
              break;
            case 2:
              m.fanout = r.uint32();
              break;
            case 3:
              m.seed = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Set2.fromObject = function fromObject(d2) {
        if (d2 instanceof $root$5.ipfs.pin.Set)
          return d2;
        var m = new $root$5.ipfs.pin.Set();
        if (d2.version != null) {
          m.version = d2.version >>> 0;
        }
        if (d2.fanout != null) {
          m.fanout = d2.fanout >>> 0;
        }
        if (d2.seed != null) {
          m.seed = d2.seed >>> 0;
        }
        return m;
      };
      Set2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d2 = {};
        if (o.defaults) {
          d2.version = 0;
          d2.fanout = 0;
          d2.seed = 0;
        }
        if (m.version != null && m.hasOwnProperty("version")) {
          d2.version = m.version;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          d2.fanout = m.fanout;
        }
        if (m.seed != null && m.hasOwnProperty("seed")) {
          d2.seed = m.seed;
        }
        return d2;
      };
      Set2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Set2;
    }();
    return pin;
  }();
  return ipfs2;
})();
var fnv1a$1 = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  hash2.BASE = 2166136261;
  function hash2(s, h = hash2.BASE) {
    const l2 = s.length;
    for (let i2 = 0; i2 < l2; i2++) {
      h ^= s.charCodeAt(i2);
      h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    return h >>> 0;
  }
  exports.default = hash2;
  module.exports = hash2;
})(fnv1a$1, fnv1a$1.exports);
const fnv1a = /* @__PURE__ */ getDefaultExportFromCjs(fnv1a$1.exports);
const PIN_DS_KEY = new Key("/local/pins");
const DEFAULT_FANOUT = 256;
const MAX_ITEMS = 8192;
const EMPTY_KEY = CID$5.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
const PinTypes$1 = {
  direct: "direct",
  recursive: "recursive"
};
function cidToKey$2(cid) {
  return new Key(`/${base32$6.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}
function asUint8Array$1(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function allocUnsafe$1(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array$1(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
function concat$1(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe$1(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array$1(output);
}
function compare(a2, b2) {
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] < b2[i2]) {
      return -1;
    }
    if (a2[i2] > b2[i2]) {
      return 1;
    }
  }
  if (a2.byteLength > b2.byteLength) {
    return 1;
  }
  if (a2.byteLength < b2.byteLength) {
    return -1;
  }
  return 0;
}
const identity$9 = from$9({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$5(buf2),
  decode: (str) => fromString$5(str)
});
const identityBase$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$9
}, Symbol.toStringTag, { value: "Module" }));
const base2$4 = rfc4648$5({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: base2$4
}, Symbol.toStringTag, { value: "Module" }));
const base8$4 = rfc4648$5({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: base8$4
}, Symbol.toStringTag, { value: "Module" }));
const base10$4 = baseX$5({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: base10$4
}, Symbol.toStringTag, { value: "Module" }));
const base16$4 = rfc4648$5({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper$2 = rfc4648$5({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: base16$4,
  base16upper: base16upper$2
}, Symbol.toStringTag, { value: "Module" }));
const base36$4 = baseX$5({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper$2 = baseX$5({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: base36$4,
  base36upper: base36upper$2
}, Symbol.toStringTag, { value: "Module" }));
const base64$5 = rfc4648$5({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad$2 = rfc4648$5({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url$3 = rfc4648$5({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad$2 = rfc4648$5({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$5,
  base64pad: base64pad$2,
  base64url: base64url$3,
  base64urlpad: base64urlpad$2
}, Symbol.toStringTag, { value: "Module" }));
const alphabet$2 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars$2 = alphabet$2.reduce((p2, c, i2) => {
  p2[i2] = c;
  return p2;
}, []);
const alphabetCharsToBytes$2 = alphabet$2.reduce((p2, c, i2) => {
  p2[c.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$j(data) {
  return data.reduce((p2, c) => {
    p2 += alphabetBytesToChars$2[c];
    return p2;
  }, "");
}
function decode$o(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes$2[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji$4 = from$9({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$j,
  decode: decode$o
});
const base256emoji$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: base256emoji$4
}, Symbol.toStringTag, { value: "Module" }));
const from$6 = ({ name: name2, code: code2, encode: encode2 }) => new Hasher$1(name2, code2, encode2);
class Hasher$1 {
  constructor(name2, code2, encode2) {
    this.name = name2;
    this.code = code2;
    this.encode = encode2;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$7(this.code, result) : result.then((digest2) => create$7(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha$1 = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256$1 = from$6({
  name: "sha2-256",
  code: 18,
  encode: sha$1("SHA-256")
});
const sha512$1 = from$6({
  name: "sha2-512",
  code: 19,
  encode: sha$1("SHA-512")
});
const sha2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: sha256$1,
  sha512: sha512$1
}, Symbol.toStringTag, { value: "Module" }));
const code$7 = 0;
const name$5 = "identity";
const encode$i = coerce$5;
const digest$2 = (input) => create$7(code$7, encode$i(input));
const identity$7 = {
  code: code$7,
  name: name$5,
  encode: encode$i,
  digest: digest$2
};
const identity$8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$7
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases$1 = {
  ...identityBase$2,
  ...base2$5,
  ...base8$5,
  ...base10$5,
  ...base16$5,
  ...base32$7,
  ...base36$5,
  ...base58$1,
  ...base64$6,
  ...base256emoji$5
};
({
  ...sha2$1,
  ...identity$8
});
function createCodec$1(name2, prefix, encode2, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode2
    },
    decoder: { decode: decode2 }
  };
}
const string$1 = createCodec$1("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii$1 = createCodec$1("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe$1(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
const BASES$1 = {
  utf8: string$1,
  "utf-8": string$1,
  hex: bases$1.base16,
  latin1: ascii$1,
  ascii: ascii$1,
  binary: ascii$1,
  ...bases$1
};
function toString$3(array, encoding2 = "utf8") {
  const base3 = BASES$1[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
function fromString$3(string2, encoding2 = "utf8") {
  const base3 = BASES$1[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array$1(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
const PinSet = ipfs.pin.Set;
function readHeader(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = varint$9.decode(rootData);
  const vBytes = varint$9.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed, true);
  const encodedKey = fromString$3(key.toString());
  const data = concat$1([buffer2, encodedKey], buffer2.byteLength + encodedKey.byteLength);
  return fnv1a(toString$3(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node2 = decode$p(buf2);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name2) {
  const link = rootNode.Links.find((l2) => l2.Name === name2);
  if (!link) {
    throw new Error("No link found with name " + name2);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node = decode$p(buf2);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = varint$9.encode(pbHeader.length);
    const headerBuf = concat$1([header, pbHeader]);
    const fanoutLinks = [];
    for (let i2 = 0; i2 < DEFAULT_FANOUT; i2++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a2, b2) => {
        return compare(a2.link.Hash.bytes, b2.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat$1([headerBuf, ...nodes.map((item) => item.data)]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode$k(child);
      const digest2 = await sha256$1.digest(buf2);
      const cid = CID$5.createV0(digest2);
      await blockstore.put(cid, buf2);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return {
      key: cid2
    };
  }));
  const buf2 = encode$k(rootNode);
  const digest2 = await sha256$1.digest(buf2);
  const cid = CID$5.createV0(digest2);
  await blockstore.put(cid, buf2);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(PIN_DS_KEY);
  const cid = CID$5.decode(mh);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode$p(pinRootBuf);
  let counter = 0;
  const pinCount = await itLength(loadSet(blockstore, pinRoot, PinTypes$1.recursive)) + await itLength(loadSet(blockstore, pinRoot, PinTypes$1.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes$1.recursive)) {
    counter++;
    const pin = {
      depth: Infinity
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code$8) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey$2(cid2), encode$B(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes$1.direct)) {
    counter++;
    const pin = {
      depth: 0
    };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code$8) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey$2(cid2), encode$B(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await itLength(pinstore.queryKeys({}));
  for await (const { key, value } of pinstore.query({})) {
    counter++;
    const pin = decode$O(value);
    const cid2 = CID$5.create(
      pin.version || 0,
      pin.codec || code$8,
      decode$w(base32$6.decode("b" + key.toString().toLowerCase().split("/").pop()))
    );
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes$1.direct, directPins),
      await storeSet(blockstore, PinTypes$1.recursive, recursivePins)
    ]
  };
  const buf2 = encode$k(pinRoot);
  const digest2 = await sha256$1.digest(buf2);
  const cid = CID$5.createV0(digest2);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process$2(backends, onProgress, fn2) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn2(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
const migration$3 = {
  version: 9,
  description: "Migrates pins to datastore",
  migrate: (backends, onProgress = () => {
  }) => {
    return process$2(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process$2(backends, onProgress, pinsToDAG);
  }
};
function dbOpenFailedError(err) {
  err = err || new Error("Cannot open database");
  return errCode$1(err, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err) {
  err = err || new Error("Delete failed");
  return errCode$1(err, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err) {
  err = err || new Error("Write failed");
  return errCode$1(err, "ERR_DB_WRITE_FAILED");
}
function notFoundError$1(err) {
  err = err || new Error("Not Found");
  return errCode$1(err, "ERR_NOT_FOUND");
}
const CONFIG_KEY = new Key("/config");
const VERSION_KEY = new Key("/version");
function findLevelJs$1(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback$1(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs$1(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve(Boolean(req.result));
    };
  });
}
async function getWithFallback$1(key, get2, has, store) {
  if (await has(key)) {
    return get2(key);
  }
  const levelJs = findLevelJs$1(store);
  if (!levelJs) {
    throw notFoundError$1();
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve(req.result);
      }
      reject(notFoundError$1());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback$1(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback$1(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}
async function keysToBinary(name2, store, onProgress = () => {
}) {
  const db = findLevelJs$1(store);
  if (!db) {
    onProgress(`${name2} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name2}`);
  const upgrade = (key, value) => {
    return [
      { type: "del", key },
      { type: "put", key: fromString$3(key), value }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name2, store, onProgress = () => {
}) {
  const db = findLevelJs$1(store);
  if (!db) {
    onProgress(`${name2} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name2}`);
  const downgrade = (key, value) => {
    return [
      { type: "del", key },
      { type: "put", key: toString$3(key), value }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap(store) {
  if (store.child) {
    return unwrap(store.child);
  }
  return store;
}
async function process$1(backends, onProgress, fn2) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({ key, backend: unwrap(backend) })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message) => {
    onProgress(Math.round(migrated / datastores.length * 100), message);
  };
  for (const { name: name2, store } of datastores) {
    await store.open();
    try {
      await fn2(name2, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
const migration$2 = {
  version: 10,
  description: "Migrates datastore-level keys to binary",
  migrate: (backends, onProgress = () => {
  }) => {
    return process$1(backends, onProgress, keysToBinary);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process$1(backends, onProgress, keysToStrings);
  }
};
function withEach(db, fn2) {
  function batch2(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err) {
        error = err;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err, key, value) => {
        if (err || key === void 0) {
          const handleEnd = (err2) => {
            if (err2) {
              reject(err2);
              return;
            }
            resolve();
          };
          it.end(handleEnd);
          return;
        }
        batch2(fn2(key, value), next);
      };
      it.next(handleNext);
    }
  });
}
const MFS_ROOT_KEY$1 = new Key("/local/filesroot");
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY$1)) {
    const root = await backends.root.get(MFS_ROOT_KEY$1);
    await backends.datastore.put(MFS_ROOT_KEY$1, root);
    await backends.root.delete(MFS_ROOT_KEY$1);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY$1)) {
    const root = await backends.datastore.get(MFS_ROOT_KEY$1);
    await backends.root.put(MFS_ROOT_KEY$1, root);
    await backends.datastore.delete(MFS_ROOT_KEY$1);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
const migration$1 = {
  version: 11,
  description: "Store mfs root in the datastore",
  migrate: storeMfsRootInDatastore,
  revert: storeMfsRootInRoot
};
const $Reader$4 = $protobuf.Reader, $Writer$4 = $protobuf.Writer, $util$4 = $protobuf.util;
const $root$4 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Protocols = $root$4.Protocols = (() => {
  function Protocols2(p2) {
    this.protocols = [];
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  Protocols2.prototype.protocols = $util$4.emptyArray;
  Protocols2.encode = function encode2(m, w) {
    if (!w)
      w = $Writer$4.create();
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(10).string(m.protocols[i2]);
    }
    return w;
  };
  Protocols2.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader$4))
      r = $Reader$4.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$4.Protocols();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Protocols2.fromObject = function fromObject(d2) {
    if (d2 instanceof $root$4.Protocols)
      return d2;
    var m = new $root$4.Protocols();
    if (d2.protocols) {
      if (!Array.isArray(d2.protocols))
        throw TypeError(".Protocols.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d2.protocols.length; ++i2) {
        m.protocols[i2] = String(d2.protocols[i2]);
      }
    }
    return m;
  };
  Protocols2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.arrays || o.defaults) {
      d2.protocols = [];
    }
    if (m.protocols && m.protocols.length) {
      d2.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d2.protocols[j] = m.protocols[j];
      }
    }
    return d2;
  };
  Protocols2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Protocols2;
})();
const $Reader$3 = $protobuf.Reader, $Writer$3 = $protobuf.Writer, $util$3 = $protobuf.util;
const $root$3 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Addresses = $root$3.Addresses = (() => {
  function Addresses2(p2) {
    this.addrs = [];
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  Addresses2.prototype.addrs = $util$3.emptyArray;
  Addresses2.prototype.certifiedRecord = null;
  Addresses2.encode = function encode2(m, w) {
    if (!w)
      w = $Writer$3.create();
    if (m.addrs != null && m.addrs.length) {
      for (var i2 = 0; i2 < m.addrs.length; ++i2)
        $root$3.Addresses.Address.encode(m.addrs[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
      $root$3.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
    return w;
  };
  Addresses2.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader$3))
      r = $Reader$3.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$3.Addresses();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addrs && m.addrs.length))
            m.addrs = [];
          m.addrs.push($root$3.Addresses.Address.decode(r, r.uint32()));
          break;
        case 2:
          m.certifiedRecord = $root$3.Addresses.CertifiedRecord.decode(r, r.uint32());
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Addresses2.fromObject = function fromObject(d2) {
    if (d2 instanceof $root$3.Addresses)
      return d2;
    var m = new $root$3.Addresses();
    if (d2.addrs) {
      if (!Array.isArray(d2.addrs))
        throw TypeError(".Addresses.addrs: array expected");
      m.addrs = [];
      for (var i2 = 0; i2 < d2.addrs.length; ++i2) {
        if (typeof d2.addrs[i2] !== "object")
          throw TypeError(".Addresses.addrs: object expected");
        m.addrs[i2] = $root$3.Addresses.Address.fromObject(d2.addrs[i2]);
      }
    }
    if (d2.certifiedRecord != null) {
      if (typeof d2.certifiedRecord !== "object")
        throw TypeError(".Addresses.certifiedRecord: object expected");
      m.certifiedRecord = $root$3.Addresses.CertifiedRecord.fromObject(d2.certifiedRecord);
    }
    return m;
  };
  Addresses2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.arrays || o.defaults) {
      d2.addrs = [];
    }
    if (o.defaults) {
      d2.certifiedRecord = null;
    }
    if (m.addrs && m.addrs.length) {
      d2.addrs = [];
      for (var j = 0; j < m.addrs.length; ++j) {
        d2.addrs[j] = $root$3.Addresses.Address.toObject(m.addrs[j], o);
      }
    }
    if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
      d2.certifiedRecord = $root$3.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
    }
    return d2;
  };
  Addresses2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Addresses2.Address = function() {
    function Address(p2) {
      if (p2) {
        for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
          if (p2[ks2[i2]] != null)
            this[ks2[i2]] = p2[ks2[i2]];
      }
    }
    Address.prototype.multiaddr = $util$3.newBuffer([]);
    Address.prototype.isCertified = null;
    let $oneOfFields;
    Object.defineProperty(Address.prototype, "_isCertified", {
      get: $util$3.oneOfGetter($oneOfFields = ["isCertified"]),
      set: $util$3.oneOfSetter($oneOfFields)
    });
    Address.encode = function encode2(m, w) {
      if (!w)
        w = $Writer$3.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
        w.uint32(16).bool(m.isCertified);
      return w;
    };
    Address.decode = function decode2(r, l2) {
      if (!(r instanceof $Reader$3))
        r = $Reader$3.create(r);
      var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$3.Addresses.Address();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          case 2:
            m.isCertified = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    Address.fromObject = function fromObject(d2) {
      if (d2 instanceof $root$3.Addresses.Address)
        return d2;
      var m = new $root$3.Addresses.Address();
      if (d2.multiaddr != null) {
        if (typeof d2.multiaddr === "string")
          $util$3.base64.decode(d2.multiaddr, m.multiaddr = $util$3.newBuffer($util$3.base64.length(d2.multiaddr)), 0);
        else if (d2.multiaddr.length)
          m.multiaddr = d2.multiaddr;
      }
      if (d2.isCertified != null) {
        m.isCertified = Boolean(d2.isCertified);
      }
      return m;
    };
    Address.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d2 = {};
      if (o.defaults) {
        if (o.bytes === String)
          d2.multiaddr = "";
        else {
          d2.multiaddr = [];
          if (o.bytes !== Array)
            d2.multiaddr = $util$3.newBuffer(d2.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d2.multiaddr = o.bytes === String ? $util$3.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
        d2.isCertified = m.isCertified;
        if (o.oneofs)
          d2._isCertified = "isCertified";
      }
      return d2;
    };
    Address.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Address;
  }();
  Addresses2.CertifiedRecord = function() {
    function CertifiedRecord(p2) {
      if (p2) {
        for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
          if (p2[ks2[i2]] != null)
            this[ks2[i2]] = p2[ks2[i2]];
      }
    }
    CertifiedRecord.prototype.seq = $util$3.Long ? $util$3.Long.fromBits(0, 0, true) : 0;
    CertifiedRecord.prototype.raw = $util$3.newBuffer([]);
    CertifiedRecord.encode = function encode2(m, w) {
      if (!w)
        w = $Writer$3.create();
      if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
        w.uint32(8).uint64(m.seq);
      if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
        w.uint32(18).bytes(m.raw);
      return w;
    };
    CertifiedRecord.decode = function decode2(r, l2) {
      if (!(r instanceof $Reader$3))
        r = $Reader$3.create(r);
      var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$3.Addresses.CertifiedRecord();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.seq = r.uint64();
            break;
          case 2:
            m.raw = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    CertifiedRecord.fromObject = function fromObject(d2) {
      if (d2 instanceof $root$3.Addresses.CertifiedRecord)
        return d2;
      var m = new $root$3.Addresses.CertifiedRecord();
      if (d2.seq != null) {
        if ($util$3.Long)
          (m.seq = $util$3.Long.fromValue(d2.seq)).unsigned = true;
        else if (typeof d2.seq === "string")
          m.seq = parseInt(d2.seq, 10);
        else if (typeof d2.seq === "number")
          m.seq = d2.seq;
        else if (typeof d2.seq === "object")
          m.seq = new $util$3.LongBits(d2.seq.low >>> 0, d2.seq.high >>> 0).toNumber(true);
      }
      if (d2.raw != null) {
        if (typeof d2.raw === "string")
          $util$3.base64.decode(d2.raw, m.raw = $util$3.newBuffer($util$3.base64.length(d2.raw)), 0);
        else if (d2.raw.length)
          m.raw = d2.raw;
      }
      return m;
    };
    CertifiedRecord.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d2 = {};
      if (o.defaults) {
        if ($util$3.Long) {
          var n = new $util$3.Long(0, 0, true);
          d2.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
        } else
          d2.seq = o.longs === String ? "0" : 0;
        if (o.bytes === String)
          d2.raw = "";
        else {
          d2.raw = [];
          if (o.bytes !== Array)
            d2.raw = $util$3.newBuffer(d2.raw);
        }
      }
      if (m.seq != null && m.hasOwnProperty("seq")) {
        if (typeof m.seq === "number")
          d2.seq = o.longs === String ? String(m.seq) : m.seq;
        else
          d2.seq = o.longs === String ? $util$3.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util$3.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
      }
      if (m.raw != null && m.hasOwnProperty("raw")) {
        d2.raw = o.bytes === String ? $util$3.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
      }
      return d2;
    };
    CertifiedRecord.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return CertifiedRecord;
  }();
  return Addresses2;
})();
const $Reader$2 = $protobuf.Reader, $Writer$2 = $protobuf.Writer, $util$2 = $protobuf.util;
const $root$2 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Peer = $root$2.Peer = (() => {
  function Peer2(p2) {
    this.addresses = [];
    this.protocols = [];
    this.metadata = [];
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  Peer2.prototype.addresses = $util$2.emptyArray;
  Peer2.prototype.protocols = $util$2.emptyArray;
  Peer2.prototype.metadata = $util$2.emptyArray;
  Peer2.prototype.pubKey = null;
  Peer2.prototype.peerRecordEnvelope = null;
  let $oneOfFields;
  Object.defineProperty(Peer2.prototype, "_pubKey", {
    get: $util$2.oneOfGetter($oneOfFields = ["pubKey"]),
    set: $util$2.oneOfSetter($oneOfFields)
  });
  Object.defineProperty(Peer2.prototype, "_peerRecordEnvelope", {
    get: $util$2.oneOfGetter($oneOfFields = ["peerRecordEnvelope"]),
    set: $util$2.oneOfSetter($oneOfFields)
  });
  Peer2.encode = function encode2(m, w) {
    if (!w)
      w = $Writer$2.create();
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root$2.Address.encode(m.addresses[i2], w.uint32(10).fork()).ldelim();
    }
    if (m.protocols != null && m.protocols.length) {
      for (var i2 = 0; i2 < m.protocols.length; ++i2)
        w.uint32(18).string(m.protocols[i2]);
    }
    if (m.metadata != null && m.metadata.length) {
      for (var i2 = 0; i2 < m.metadata.length; ++i2)
        $root$2.Metadata.encode(m.metadata[i2], w.uint32(26).fork()).ldelim();
    }
    if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
      w.uint32(34).bytes(m.pubKey);
    if (m.peerRecordEnvelope != null && Object.hasOwnProperty.call(m, "peerRecordEnvelope"))
      w.uint32(42).bytes(m.peerRecordEnvelope);
    return w;
  };
  Peer2.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader$2))
      r = $Reader$2.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$2.Peer();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root$2.Address.decode(r, r.uint32()));
          break;
        case 2:
          if (!(m.protocols && m.protocols.length))
            m.protocols = [];
          m.protocols.push(r.string());
          break;
        case 3:
          if (!(m.metadata && m.metadata.length))
            m.metadata = [];
          m.metadata.push($root$2.Metadata.decode(r, r.uint32()));
          break;
        case 4:
          m.pubKey = r.bytes();
          break;
        case 5:
          m.peerRecordEnvelope = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Peer2.fromObject = function fromObject(d2) {
    if (d2 instanceof $root$2.Peer)
      return d2;
    var m = new $root$2.Peer();
    if (d2.addresses) {
      if (!Array.isArray(d2.addresses))
        throw TypeError(".Peer.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d2.addresses.length; ++i2) {
        if (typeof d2.addresses[i2] !== "object")
          throw TypeError(".Peer.addresses: object expected");
        m.addresses[i2] = $root$2.Address.fromObject(d2.addresses[i2]);
      }
    }
    if (d2.protocols) {
      if (!Array.isArray(d2.protocols))
        throw TypeError(".Peer.protocols: array expected");
      m.protocols = [];
      for (var i2 = 0; i2 < d2.protocols.length; ++i2) {
        m.protocols[i2] = String(d2.protocols[i2]);
      }
    }
    if (d2.metadata) {
      if (!Array.isArray(d2.metadata))
        throw TypeError(".Peer.metadata: array expected");
      m.metadata = [];
      for (var i2 = 0; i2 < d2.metadata.length; ++i2) {
        if (typeof d2.metadata[i2] !== "object")
          throw TypeError(".Peer.metadata: object expected");
        m.metadata[i2] = $root$2.Metadata.fromObject(d2.metadata[i2]);
      }
    }
    if (d2.pubKey != null) {
      if (typeof d2.pubKey === "string")
        $util$2.base64.decode(d2.pubKey, m.pubKey = $util$2.newBuffer($util$2.base64.length(d2.pubKey)), 0);
      else if (d2.pubKey.length)
        m.pubKey = d2.pubKey;
    }
    if (d2.peerRecordEnvelope != null) {
      if (typeof d2.peerRecordEnvelope === "string")
        $util$2.base64.decode(d2.peerRecordEnvelope, m.peerRecordEnvelope = $util$2.newBuffer($util$2.base64.length(d2.peerRecordEnvelope)), 0);
      else if (d2.peerRecordEnvelope.length)
        m.peerRecordEnvelope = d2.peerRecordEnvelope;
    }
    return m;
  };
  Peer2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.arrays || o.defaults) {
      d2.addresses = [];
      d2.protocols = [];
      d2.metadata = [];
    }
    if (m.addresses && m.addresses.length) {
      d2.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d2.addresses[j] = $root$2.Address.toObject(m.addresses[j], o);
      }
    }
    if (m.protocols && m.protocols.length) {
      d2.protocols = [];
      for (var j = 0; j < m.protocols.length; ++j) {
        d2.protocols[j] = m.protocols[j];
      }
    }
    if (m.metadata && m.metadata.length) {
      d2.metadata = [];
      for (var j = 0; j < m.metadata.length; ++j) {
        d2.metadata[j] = $root$2.Metadata.toObject(m.metadata[j], o);
      }
    }
    if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
      d2.pubKey = o.bytes === String ? $util$2.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
      if (o.oneofs)
        d2._pubKey = "pubKey";
    }
    if (m.peerRecordEnvelope != null && m.hasOwnProperty("peerRecordEnvelope")) {
      d2.peerRecordEnvelope = o.bytes === String ? $util$2.base64.encode(m.peerRecordEnvelope, 0, m.peerRecordEnvelope.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerRecordEnvelope) : m.peerRecordEnvelope;
      if (o.oneofs)
        d2._peerRecordEnvelope = "peerRecordEnvelope";
    }
    return d2;
  };
  Peer2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Peer2;
})();
$root$2.Address = (() => {
  function Address(p2) {
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  Address.prototype.multiaddr = $util$2.newBuffer([]);
  Address.prototype.isCertified = null;
  let $oneOfFields;
  Object.defineProperty(Address.prototype, "_isCertified", {
    get: $util$2.oneOfGetter($oneOfFields = ["isCertified"]),
    set: $util$2.oneOfSetter($oneOfFields)
  });
  Address.encode = function encode2(m, w) {
    if (!w)
      w = $Writer$2.create();
    if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
      w.uint32(10).bytes(m.multiaddr);
    if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
      w.uint32(16).bool(m.isCertified);
    return w;
  };
  Address.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader$2))
      r = $Reader$2.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$2.Address();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.multiaddr = r.bytes();
          break;
        case 2:
          m.isCertified = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Address.fromObject = function fromObject(d2) {
    if (d2 instanceof $root$2.Address)
      return d2;
    var m = new $root$2.Address();
    if (d2.multiaddr != null) {
      if (typeof d2.multiaddr === "string")
        $util$2.base64.decode(d2.multiaddr, m.multiaddr = $util$2.newBuffer($util$2.base64.length(d2.multiaddr)), 0);
      else if (d2.multiaddr.length)
        m.multiaddr = d2.multiaddr;
    }
    if (d2.isCertified != null) {
      m.isCertified = Boolean(d2.isCertified);
    }
    return m;
  };
  Address.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.defaults) {
      if (o.bytes === String)
        d2.multiaddr = "";
      else {
        d2.multiaddr = [];
        if (o.bytes !== Array)
          d2.multiaddr = $util$2.newBuffer(d2.multiaddr);
      }
    }
    if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
      d2.multiaddr = o.bytes === String ? $util$2.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
    }
    if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
      d2.isCertified = m.isCertified;
      if (o.oneofs)
        d2._isCertified = "isCertified";
    }
    return d2;
  };
  Address.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Address;
})();
$root$2.Metadata = (() => {
  function Metadata(p2) {
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  Metadata.prototype.key = "";
  Metadata.prototype.value = $util$2.newBuffer([]);
  Metadata.encode = function encode2(m, w) {
    if (!w)
      w = $Writer$2.create();
    if (m.key != null && Object.hasOwnProperty.call(m, "key"))
      w.uint32(10).string(m.key);
    if (m.value != null && Object.hasOwnProperty.call(m, "value"))
      w.uint32(18).bytes(m.value);
    return w;
  };
  Metadata.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader$2))
      r = $Reader$2.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$2.Metadata();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.key = r.string();
          break;
        case 2:
          m.value = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Metadata.fromObject = function fromObject(d2) {
    if (d2 instanceof $root$2.Metadata)
      return d2;
    var m = new $root$2.Metadata();
    if (d2.key != null) {
      m.key = String(d2.key);
    }
    if (d2.value != null) {
      if (typeof d2.value === "string")
        $util$2.base64.decode(d2.value, m.value = $util$2.newBuffer($util$2.base64.length(d2.value)), 0);
      else if (d2.value.length)
        m.value = d2.value;
    }
    return m;
  };
  Metadata.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.defaults) {
      d2.key = "";
      if (o.bytes === String)
        d2.value = "";
      else {
        d2.value = [];
        if (o.bytes !== Array)
          d2.value = $util$2.newBuffer(d2.value);
      }
    }
    if (m.key != null && m.hasOwnProperty("key")) {
      d2.key = m.key;
    }
    if (m.value != null && m.hasOwnProperty("value")) {
      d2.value = o.bytes === String ? $util$2.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
    }
    return d2;
  };
  Metadata.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Metadata;
})();
const $Reader$1 = $protobuf.Reader, $Writer$1 = $protobuf.Writer, $util$1 = $protobuf.util;
const $root$1 = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const Envelope = $root$1.Envelope = (() => {
  function Envelope2(p2) {
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  Envelope2.prototype.publicKey = $util$1.newBuffer([]);
  Envelope2.prototype.payloadType = $util$1.newBuffer([]);
  Envelope2.prototype.payload = $util$1.newBuffer([]);
  Envelope2.prototype.signature = $util$1.newBuffer([]);
  Envelope2.encode = function encode2(m, w) {
    if (!w)
      w = $Writer$1.create();
    if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
      w.uint32(10).bytes(m.publicKey);
    if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
      w.uint32(18).bytes(m.payloadType);
    if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
      w.uint32(26).bytes(m.payload);
    if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
      w.uint32(42).bytes(m.signature);
    return w;
  };
  Envelope2.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader$1))
      r = $Reader$1.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root$1.Envelope();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.publicKey = r.bytes();
          break;
        case 2:
          m.payloadType = r.bytes();
          break;
        case 3:
          m.payload = r.bytes();
          break;
        case 5:
          m.signature = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  Envelope2.fromObject = function fromObject(d2) {
    if (d2 instanceof $root$1.Envelope)
      return d2;
    var m = new $root$1.Envelope();
    if (d2.publicKey != null) {
      if (typeof d2.publicKey === "string")
        $util$1.base64.decode(d2.publicKey, m.publicKey = $util$1.newBuffer($util$1.base64.length(d2.publicKey)), 0);
      else if (d2.publicKey.length)
        m.publicKey = d2.publicKey;
    }
    if (d2.payloadType != null) {
      if (typeof d2.payloadType === "string")
        $util$1.base64.decode(d2.payloadType, m.payloadType = $util$1.newBuffer($util$1.base64.length(d2.payloadType)), 0);
      else if (d2.payloadType.length)
        m.payloadType = d2.payloadType;
    }
    if (d2.payload != null) {
      if (typeof d2.payload === "string")
        $util$1.base64.decode(d2.payload, m.payload = $util$1.newBuffer($util$1.base64.length(d2.payload)), 0);
      else if (d2.payload.length)
        m.payload = d2.payload;
    }
    if (d2.signature != null) {
      if (typeof d2.signature === "string")
        $util$1.base64.decode(d2.signature, m.signature = $util$1.newBuffer($util$1.base64.length(d2.signature)), 0);
      else if (d2.signature.length)
        m.signature = d2.signature;
    }
    return m;
  };
  Envelope2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.defaults) {
      if (o.bytes === String)
        d2.publicKey = "";
      else {
        d2.publicKey = [];
        if (o.bytes !== Array)
          d2.publicKey = $util$1.newBuffer(d2.publicKey);
      }
      if (o.bytes === String)
        d2.payloadType = "";
      else {
        d2.payloadType = [];
        if (o.bytes !== Array)
          d2.payloadType = $util$1.newBuffer(d2.payloadType);
      }
      if (o.bytes === String)
        d2.payload = "";
      else {
        d2.payload = [];
        if (o.bytes !== Array)
          d2.payload = $util$1.newBuffer(d2.payload);
      }
      if (o.bytes === String)
        d2.signature = "";
      else {
        d2.signature = [];
        if (o.bytes !== Array)
          d2.signature = $util$1.newBuffer(d2.signature);
      }
    }
    if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
      d2.publicKey = o.bytes === String ? $util$1.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
    }
    if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
      d2.payloadType = o.bytes === String ? $util$1.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
    }
    if (m.payload != null && m.hasOwnProperty("payload")) {
      d2.payload = o.bytes === String ? $util$1.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
    }
    if (m.signature != null && m.hasOwnProperty("signature")) {
      d2.signature = o.bytes === String ? $util$1.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
    }
    return d2;
  };
  Envelope2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  return Envelope2;
})();
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
const PeerRecord = $root.PeerRecord = (() => {
  function PeerRecord2(p2) {
    this.addresses = [];
    if (p2) {
      for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
        if (p2[ks2[i2]] != null)
          this[ks2[i2]] = p2[ks2[i2]];
    }
  }
  PeerRecord2.prototype.peerId = $util.newBuffer([]);
  PeerRecord2.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
  PeerRecord2.prototype.addresses = $util.emptyArray;
  PeerRecord2.encode = function encode2(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
      w.uint32(10).bytes(m.peerId);
    if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
      w.uint32(16).uint64(m.seq);
    if (m.addresses != null && m.addresses.length) {
      for (var i2 = 0; i2 < m.addresses.length; ++i2)
        $root.PeerRecord.AddressInfo.encode(m.addresses[i2], w.uint32(26).fork()).ldelim();
    }
    return w;
  };
  PeerRecord2.decode = function decode2(r, l2) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root.PeerRecord();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
        case 1:
          m.peerId = r.bytes();
          break;
        case 2:
          m.seq = r.uint64();
          break;
        case 3:
          if (!(m.addresses && m.addresses.length))
            m.addresses = [];
          m.addresses.push($root.PeerRecord.AddressInfo.decode(r, r.uint32()));
          break;
        default:
          r.skipType(t & 7);
          break;
      }
    }
    return m;
  };
  PeerRecord2.fromObject = function fromObject(d2) {
    if (d2 instanceof $root.PeerRecord)
      return d2;
    var m = new $root.PeerRecord();
    if (d2.peerId != null) {
      if (typeof d2.peerId === "string")
        $util.base64.decode(d2.peerId, m.peerId = $util.newBuffer($util.base64.length(d2.peerId)), 0);
      else if (d2.peerId.length)
        m.peerId = d2.peerId;
    }
    if (d2.seq != null) {
      if ($util.Long)
        (m.seq = $util.Long.fromValue(d2.seq)).unsigned = true;
      else if (typeof d2.seq === "string")
        m.seq = parseInt(d2.seq, 10);
      else if (typeof d2.seq === "number")
        m.seq = d2.seq;
      else if (typeof d2.seq === "object")
        m.seq = new $util.LongBits(d2.seq.low >>> 0, d2.seq.high >>> 0).toNumber(true);
    }
    if (d2.addresses) {
      if (!Array.isArray(d2.addresses))
        throw TypeError(".PeerRecord.addresses: array expected");
      m.addresses = [];
      for (var i2 = 0; i2 < d2.addresses.length; ++i2) {
        if (typeof d2.addresses[i2] !== "object")
          throw TypeError(".PeerRecord.addresses: object expected");
        m.addresses[i2] = $root.PeerRecord.AddressInfo.fromObject(d2.addresses[i2]);
      }
    }
    return m;
  };
  PeerRecord2.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d2 = {};
    if (o.arrays || o.defaults) {
      d2.addresses = [];
    }
    if (o.defaults) {
      if (o.bytes === String)
        d2.peerId = "";
      else {
        d2.peerId = [];
        if (o.bytes !== Array)
          d2.peerId = $util.newBuffer(d2.peerId);
      }
      if ($util.Long) {
        var n = new $util.Long(0, 0, true);
        d2.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
      } else
        d2.seq = o.longs === String ? "0" : 0;
    }
    if (m.peerId != null && m.hasOwnProperty("peerId")) {
      d2.peerId = o.bytes === String ? $util.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
    }
    if (m.seq != null && m.hasOwnProperty("seq")) {
      if (typeof m.seq === "number")
        d2.seq = o.longs === String ? String(m.seq) : m.seq;
      else
        d2.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
    }
    if (m.addresses && m.addresses.length) {
      d2.addresses = [];
      for (var j = 0; j < m.addresses.length; ++j) {
        d2.addresses[j] = $root.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
      }
    }
    return d2;
  };
  PeerRecord2.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  PeerRecord2.AddressInfo = function() {
    function AddressInfo(p2) {
      if (p2) {
        for (var ks2 = Object.keys(p2), i2 = 0; i2 < ks2.length; ++i2)
          if (p2[ks2[i2]] != null)
            this[ks2[i2]] = p2[ks2[i2]];
      }
    }
    AddressInfo.prototype.multiaddr = $util.newBuffer([]);
    AddressInfo.encode = function encode2(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
        w.uint32(10).bytes(m.multiaddr);
      return w;
    };
    AddressInfo.decode = function decode2(r, l2) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l2 === void 0 ? r.len : r.pos + l2, m = new $root.PeerRecord.AddressInfo();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
          case 1:
            m.multiaddr = r.bytes();
            break;
          default:
            r.skipType(t & 7);
            break;
        }
      }
      return m;
    };
    AddressInfo.fromObject = function fromObject(d2) {
      if (d2 instanceof $root.PeerRecord.AddressInfo)
        return d2;
      var m = new $root.PeerRecord.AddressInfo();
      if (d2.multiaddr != null) {
        if (typeof d2.multiaddr === "string")
          $util.base64.decode(d2.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d2.multiaddr)), 0);
        else if (d2.multiaddr.length)
          m.multiaddr = d2.multiaddr;
      }
      return m;
    };
    AddressInfo.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d2 = {};
      if (o.defaults) {
        if (o.bytes === String)
          d2.multiaddr = "";
        else {
          d2.multiaddr = [];
          if (o.bytes !== Array)
            d2.multiaddr = $util.newBuffer(d2.multiaddr);
        }
      }
      if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
        d2.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
      }
      return d2;
    };
    AddressInfo.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return AddressInfo;
  }();
  return PeerRecord2;
})();
class Parser {
  constructor() {
    __publicField(this, "index", 0);
    __publicField(this, "input", "");
  }
  new(input) {
    this.index = 0;
    this.input = input;
    return this;
  }
  readAtomically(fn2) {
    const index = this.index;
    const result = fn2();
    if (result === void 0) {
      this.index = index;
    }
    return result;
  }
  parseWith(fn2) {
    const result = fn2();
    if (this.index !== this.input.length) {
      return void 0;
    }
    return result;
  }
  peekChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index];
  }
  readChar() {
    if (this.index >= this.input.length) {
      return void 0;
    }
    return this.input[this.index++];
  }
  readGivenChar(target) {
    return this.readAtomically(() => {
      const char = this.readChar();
      if (char !== target) {
        return void 0;
      }
      return char;
    });
  }
  readSeparator(sep, index, inner) {
    return this.readAtomically(() => {
      if (index > 0) {
        if (this.readGivenChar(sep) === void 0) {
          return void 0;
        }
      }
      return inner();
    });
  }
  readNumber(radix, maxDigits, allowZeroPrefix, maxBytes) {
    return this.readAtomically(() => {
      let result = 0;
      let digitCount = 0;
      const leadingChar = this.peekChar();
      if (leadingChar === void 0) {
        return void 0;
      }
      const hasLeadingZero = leadingChar === "0";
      const maxValue = 2 ** (8 * maxBytes) - 1;
      while (true) {
        const digit = this.readAtomically(() => {
          const char = this.readChar();
          if (char === void 0) {
            return void 0;
          }
          const num = Number.parseInt(char, radix);
          if (Number.isNaN(num)) {
            return void 0;
          }
          return num;
        });
        if (digit === void 0) {
          break;
        }
        result *= radix;
        result += digit;
        if (result > maxValue) {
          return void 0;
        }
        digitCount += 1;
        if (maxDigits !== void 0) {
          if (digitCount > maxDigits) {
            return void 0;
          }
        }
      }
      if (digitCount === 0) {
        return void 0;
      } else if (!allowZeroPrefix && hasLeadingZero && digitCount > 1) {
        return void 0;
      } else {
        return result;
      }
    });
  }
  readIPv4Addr() {
    return this.readAtomically(() => {
      const out = new Uint8Array(4);
      for (let i2 = 0; i2 < out.length; i2++) {
        const ix = this.readSeparator(".", i2, () => this.readNumber(10, 3, false, 1));
        if (ix === void 0) {
          return void 0;
        }
        out[i2] = ix;
      }
      return out;
    });
  }
  readIPv6Addr() {
    const readGroups = (groups) => {
      for (let i2 = 0; i2 < groups.length / 2; i2++) {
        const ix = i2 * 2;
        if (i2 < groups.length - 3) {
          const ipv4 = this.readSeparator(":", i2, () => this.readIPv4Addr());
          if (ipv4 !== void 0) {
            groups[ix] = ipv4[0];
            groups[ix + 1] = ipv4[1];
            groups[ix + 2] = ipv4[2];
            groups[ix + 3] = ipv4[3];
            return [ix + 4, true];
          }
        }
        const group = this.readSeparator(":", i2, () => this.readNumber(16, 4, true, 2));
        if (group === void 0) {
          return [ix, false];
        }
        groups[ix] = group >> 8;
        groups[ix + 1] = group & 255;
      }
      return [groups.length, false];
    };
    return this.readAtomically(() => {
      const head = new Uint8Array(16);
      const [headSize, headIp4] = readGroups(head);
      if (headSize === 16) {
        return head;
      }
      if (headIp4) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      if (this.readGivenChar(":") === void 0) {
        return void 0;
      }
      const tail = new Uint8Array(14);
      const limit = 16 - (headSize + 2);
      const [tailSize] = readGroups(tail.subarray(0, limit));
      head.set(tail.subarray(0, tailSize), 16 - tailSize);
      return head;
    });
  }
  readIPAddr() {
    var _a2;
    return (_a2 = this.readIPv4Addr()) != null ? _a2 : this.readIPv6Addr();
  }
}
const MAX_IPV6_LENGTH = 45;
const MAX_IPV4_LENGTH = 15;
const parser = new Parser();
function parseIPv4(input) {
  if (input.length > MAX_IPV4_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv4Addr());
}
function parseIPv6(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPv6Addr());
}
function parseIP(input) {
  if (input.length > MAX_IPV6_LENGTH) {
    return void 0;
  }
  return parser.new(input).parseWith(() => parser.readIPAddr());
}
function isIPv4(input) {
  return Boolean(parseIPv4(input));
}
function isIPv6(input) {
  return Boolean(parseIPv6(input));
}
function isIP(input) {
  return Boolean(parseIP(input));
}
const isV4 = isIPv4;
const isV6 = isIPv6;
const toBytes = function(ip) {
  let offset = 0;
  ip = ip.toString().trim();
  if (isV4(ip)) {
    const bytes2 = new Uint8Array(offset + 4);
    ip.split(/\./g).forEach((byte) => {
      bytes2[offset++] = parseInt(byte, 10) & 255;
    });
    return bytes2;
  }
  if (isV6(ip)) {
    const sections = ip.split(":", 8);
    let i2;
    for (i2 = 0; i2 < sections.length; i2++) {
      const isv4 = isV4(sections[i2]);
      let v4Buffer;
      if (isv4) {
        v4Buffer = toBytes(sections[i2]);
        sections[i2] = toString$4(v4Buffer.slice(0, 2), "base16");
      }
      if (v4Buffer != null && ++i2 < 8) {
        sections.splice(i2, 0, toString$4(v4Buffer.slice(2, 4), "base16"));
      }
    }
    if (sections[0] === "") {
      while (sections.length < 8)
        sections.unshift("0");
    } else if (sections[sections.length - 1] === "") {
      while (sections.length < 8)
        sections.push("0");
    } else if (sections.length < 8) {
      for (i2 = 0; i2 < sections.length && sections[i2] !== ""; i2++)
        ;
      const argv = [i2, 1];
      for (i2 = 9 - sections.length; i2 > 0; i2--) {
        argv.push("0");
      }
      sections.splice.apply(sections, argv);
    }
    const bytes2 = new Uint8Array(offset + 16);
    for (i2 = 0; i2 < sections.length; i2++) {
      const word = parseInt(sections[i2], 16);
      bytes2[offset++] = word >> 8 & 255;
      bytes2[offset++] = word & 255;
    }
    return bytes2;
  }
  throw new Error("invalid ip address");
};
const toString$2 = function(buf2, offset = 0, length2) {
  offset = ~~offset;
  length2 = length2 != null ? length2 : buf2.length - offset;
  const view = new DataView(buf2.buffer);
  if (length2 === 4) {
    const result = [];
    for (let i2 = 0; i2 < length2; i2++) {
      result.push(buf2[offset + i2]);
    }
    return result.join(".");
  }
  if (length2 === 16) {
    const result = [];
    for (let i2 = 0; i2 < length2; i2 += 2) {
      result.push(view.getUint16(offset + i2).toString(16));
    }
    return result.join(":").replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3").replace(/:{3,4}/, "::");
  }
  return "";
};
const V = -1;
const names = {};
const codes = {};
const table = [
  [4, 32, "ip4"],
  [6, 16, "tcp"],
  [33, 16, "dccp"],
  [41, 128, "ip6"],
  [42, V, "ip6zone"],
  [53, V, "dns", true],
  [54, V, "dns4", true],
  [55, V, "dns6", true],
  [56, V, "dnsaddr", true],
  [132, 16, "sctp"],
  [273, 16, "udp"],
  [275, 0, "p2p-webrtc-star"],
  [276, 0, "p2p-webrtc-direct"],
  [277, 0, "p2p-stardust"],
  [280, 0, "webrtc"],
  [290, 0, "p2p-circuit"],
  [301, 0, "udt"],
  [302, 0, "utp"],
  [400, V, "unix", false, true],
  [421, V, "ipfs"],
  [421, V, "p2p"],
  [443, 0, "https"],
  [444, 96, "onion"],
  [445, 296, "onion3"],
  [446, V, "garlic64"],
  [460, 0, "quic"],
  [465, 0, "webtransport"],
  [466, V, "certhash"],
  [477, 0, "ws"],
  [478, 0, "wss"],
  [479, 0, "p2p-websocket-star"],
  [480, 0, "http"],
  [777, V, "memory"]
];
table.forEach((row) => {
  const proto = createProtocol(...row);
  codes[proto.code] = proto;
  names[proto.name] = proto;
});
function createProtocol(code2, size, name2, resolvable, path) {
  return {
    code: code2,
    size,
    name: name2,
    resolvable: Boolean(resolvable),
    path: Boolean(path)
  };
}
function getProtocol(proto) {
  if (typeof proto === "number") {
    if (codes[proto] != null) {
      return codes[proto];
    }
    throw new Error(`no protocol with code: ${proto}`);
  } else if (typeof proto === "string") {
    if (names[proto] != null) {
      return names[proto];
    }
    throw new Error(`no protocol with name: ${proto}`);
  }
  throw new Error(`invalid protocol id type: ${typeof proto}`);
}
function concat(arrays, length2) {
  if (length2 == null) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = allocUnsafe$2(length2);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array$2(output);
}
function convertToString(proto, buf2) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
    case 41:
      return bytes2ip(buf2);
    case 6:
    case 273:
    case 33:
    case 132:
      return bytes2port(buf2).toString();
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return bytes2str(buf2);
    case 421:
      return bytes2mh(buf2);
    case 444:
      return bytes2onion(buf2);
    case 445:
      return bytes2onion(buf2);
    case 466:
      return bytes2mb(buf2);
    default:
      return toString$4(buf2, "base16");
  }
}
function convertToBytes(proto, str) {
  const protocol = getProtocol(proto);
  switch (protocol.code) {
    case 4:
      return ip2bytes(str);
    case 41:
      return ip2bytes(str);
    case 6:
    case 273:
    case 33:
    case 132:
      return port2bytes(parseInt(str, 10));
    case 53:
    case 54:
    case 55:
    case 56:
    case 400:
    case 777:
      return str2bytes(str);
    case 421:
      return mh2bytes(str);
    case 444:
      return onion2bytes(str);
    case 445:
      return onion32bytes(str);
    case 466:
      return mb2bytes(str);
    default:
      return fromString$4(str, "base16");
  }
}
const decoders = Object.values(bases$2).map((c) => c.decoder);
const anybaseDecoder = function() {
  let acc = decoders[0].or(decoders[1]);
  decoders.slice(2).forEach((d2) => acc = acc.or(d2));
  return acc;
}();
function ip2bytes(ipString) {
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return toBytes(ipString);
}
function bytes2ip(ipBuff) {
  const ipString = toString$2(ipBuff, 0, ipBuff.length);
  if (ipString == null) {
    throw new Error("ipBuff is required");
  }
  if (!isIP(ipString)) {
    throw new Error("invalid ip address");
  }
  return ipString;
}
function port2bytes(port) {
  const buf2 = new ArrayBuffer(2);
  const view = new DataView(buf2);
  view.setUint16(0, port);
  return new Uint8Array(buf2);
}
function bytes2port(buf2) {
  const view = new DataView(buf2.buffer);
  return view.getUint16(buf2.byteOffset);
}
function str2bytes(str) {
  const buf2 = fromString$4(str);
  const size = Uint8Array.from(varint$9.encode(buf2.length));
  return concat([size, buf2], size.length + buf2.length);
}
function bytes2str(buf2) {
  const size = varint$9.decode(buf2);
  buf2 = buf2.slice(varint$9.decode.bytes);
  if (buf2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString$4(buf2);
}
function mh2bytes(hash2) {
  let mh;
  if (hash2[0] === "Q" || hash2[0] === "1") {
    mh = decode$R(base58btc$9.decode(`z${hash2}`)).bytes;
  } else {
    mh = CID$9.parse(hash2).multihash.bytes;
  }
  const size = Uint8Array.from(varint$9.encode(mh.length));
  return concat([size, mh], size.length + mh.length);
}
function mb2bytes(mbstr) {
  const mb = anybaseDecoder.decode(mbstr);
  const size = Uint8Array.from(varint$9.encode(mb.length));
  return concat([size, mb], size.length + mb.length);
}
function bytes2mb(buf2) {
  const size = varint$9.decode(buf2);
  const hash2 = buf2.slice(varint$9.decode.bytes);
  if (hash2.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return "u" + toString$4(hash2, "base64url");
}
function bytes2mh(buf2) {
  const size = varint$9.decode(buf2);
  const address = buf2.slice(varint$9.decode.bytes);
  if (address.length !== size) {
    throw new Error("inconsistent lengths");
  }
  return toString$4(address, "base58btc");
}
function onion2bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 16) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion address.`);
  }
  const buf2 = base32$d.decode("b" + addr[0]);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function onion32bytes(str) {
  const addr = str.split(":");
  if (addr.length !== 2) {
    throw new Error(`failed to parse onion addr: ["'${addr.join('", "')}'"]' does not contain a port number`);
  }
  if (addr[0].length !== 56) {
    throw new Error(`failed to parse onion addr: ${addr[0]} not a Tor onion3 address.`);
  }
  const buf2 = base32$d.decode(`b${addr[0]}`);
  const port = parseInt(addr[1], 10);
  if (port < 1 || port > 65536) {
    throw new Error("Port number is not in range(1, 65536)");
  }
  const portBuf = port2bytes(port);
  return concat([buf2, portBuf], buf2.length + portBuf.length);
}
function bytes2onion(buf2) {
  const addrBytes = buf2.slice(0, buf2.length - 2);
  const portBytes = buf2.slice(buf2.length - 2);
  const addr = toString$4(addrBytes, "base32");
  const port = bytes2port(portBytes);
  return `${addr}:${port}`;
}
function stringToStringTuples(str) {
  const tuples = [];
  const parts = str.split("/").slice(1);
  if (parts.length === 1 && parts[0] === "") {
    return [];
  }
  for (let p2 = 0; p2 < parts.length; p2++) {
    const part = parts[p2];
    const proto = getProtocol(part);
    if (proto.size === 0) {
      tuples.push([part]);
      continue;
    }
    p2++;
    if (p2 >= parts.length) {
      throw ParseError("invalid address: " + str);
    }
    if (proto.path === true) {
      tuples.push([
        part,
        cleanPath(parts.slice(p2).join("/"))
      ]);
      break;
    }
    tuples.push([part, parts[p2]]);
  }
  return tuples;
}
function stringTuplesToString(tuples) {
  const parts = [];
  tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    parts.push(proto.name);
    if (tup.length > 1 && tup[1] != null) {
      parts.push(tup[1]);
    }
    return null;
  });
  return cleanPath(parts.join("/"));
}
function stringTuplesToTuples(tuples) {
  return tuples.map((tup) => {
    if (!Array.isArray(tup)) {
      tup = [tup];
    }
    const proto = protoFromTuple(tup);
    if (tup.length > 1) {
      return [proto.code, convertToBytes(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToStringTuples(tuples) {
  return tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    if (tup[1] != null) {
      return [proto.code, convertToString(proto.code, tup[1])];
    }
    return [proto.code];
  });
}
function tuplesToBytes(tuples) {
  return fromBytes(concat(tuples.map((tup) => {
    const proto = protoFromTuple(tup);
    let buf2 = Uint8Array.from(varint$9.encode(proto.code));
    if (tup.length > 1 && tup[1] != null) {
      buf2 = concat([buf2, tup[1]]);
    }
    return buf2;
  })));
}
function sizeForAddr(p2, addr) {
  if (p2.size > 0) {
    return p2.size / 8;
  } else if (p2.size === 0) {
    return 0;
  } else {
    const size = varint$9.decode(addr);
    return size + varint$9.decode.bytes;
  }
}
function bytesToTuples(buf2) {
  const tuples = [];
  let i2 = 0;
  while (i2 < buf2.length) {
    const code2 = varint$9.decode(buf2, i2);
    const n = varint$9.decode.bytes;
    const p2 = getProtocol(code2);
    const size = sizeForAddr(p2, buf2.slice(i2 + n));
    if (size === 0) {
      tuples.push([code2]);
      i2 += n;
      continue;
    }
    const addr = buf2.slice(i2 + n, i2 + n + size);
    i2 += size + n;
    if (i2 > buf2.length) {
      throw ParseError("Invalid address Uint8Array: " + toString$4(buf2, "base16"));
    }
    tuples.push([code2, addr]);
  }
  return tuples;
}
function bytesToString(buf2) {
  const a2 = bytesToTuples(buf2);
  const b2 = tuplesToStringTuples(a2);
  return stringTuplesToString(b2);
}
function stringToBytes(str) {
  str = cleanPath(str);
  const a2 = stringToStringTuples(str);
  const b2 = stringTuplesToTuples(a2);
  return tuplesToBytes(b2);
}
function fromString$2(str) {
  return stringToBytes(str);
}
function fromBytes(buf2) {
  const err = validateBytes(buf2);
  if (err != null) {
    throw err;
  }
  return Uint8Array.from(buf2);
}
function validateBytes(buf2) {
  try {
    bytesToTuples(buf2);
  } catch (err) {
    return err;
  }
}
function cleanPath(str) {
  return "/" + str.trim().split("/").filter((a2) => a2).join("/");
}
function ParseError(str) {
  return new Error("Error parsing address: " + str);
}
function protoFromTuple(tup) {
  const proto = getProtocol(tup[0]);
  return proto;
}
function equals$8(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (a2.byteLength !== b2.byteLength) {
    return false;
  }
  for (let i2 = 0; i2 < a2.byteLength; i2++) {
    if (a2[i2] !== b2[i2]) {
      return false;
    }
  }
  return true;
}
var __classPrivateFieldGet$2 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet$1 = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _DefaultMultiaddr_string, _DefaultMultiaddr_tuples, _DefaultMultiaddr_stringTuples, _a$1;
const inspect = Symbol.for("nodejs.util.inspect.custom");
const DNS_CODES = [
  getProtocol("dns").code,
  getProtocol("dns4").code,
  getProtocol("dns6").code,
  getProtocol("dnsaddr").code
];
const P2P_CODES = [
  getProtocol("p2p").code,
  getProtocol("ipfs").code
];
const resolvers = /* @__PURE__ */ new Map();
const symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
function isMultiaddr(value) {
  return Boolean(value == null ? void 0 : value[symbol]);
}
class DefaultMultiaddr {
  constructor(addr) {
    _DefaultMultiaddr_string.set(this, void 0);
    _DefaultMultiaddr_tuples.set(this, void 0);
    _DefaultMultiaddr_stringTuples.set(this, void 0);
    this[_a$1] = true;
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = fromBytes(addr);
    } else if (typeof addr === "string") {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = fromString$2(addr);
    } else if (isMultiaddr(addr)) {
      this.bytes = fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }
  toString() {
    if (__classPrivateFieldGet$2(this, _DefaultMultiaddr_string, "f") == null) {
      __classPrivateFieldSet$1(this, _DefaultMultiaddr_string, bytesToString(this.bytes), "f");
    }
    return __classPrivateFieldGet$2(this, _DefaultMultiaddr_string, "f");
  }
  toJSON() {
    return this.toString();
  }
  toOptions() {
    const codes2 = this.protoCodes();
    const parts = this.toString().split("/").slice(1);
    let transport;
    let port;
    if (parts.length > 2) {
      if (DNS_CODES.includes(codes2[0]) && P2P_CODES.includes(codes2[1])) {
        transport = getProtocol("tcp").name;
        port = 443;
      } else {
        transport = getProtocol(parts[2]).name;
        port = parseInt(parts[3]);
      }
    } else if (DNS_CODES.includes(codes2[0])) {
      transport = getProtocol("tcp").name;
      port = 443;
    } else {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');
    }
    const opts = {
      family: codes2[0] === 41 || codes2[0] === 55 ? 6 : 4,
      host: parts[1],
      transport,
      port
    };
    return opts;
  }
  protos() {
    return this.protoCodes().map((code2) => Object.assign({}, getProtocol(code2)));
  }
  protoCodes() {
    const codes2 = [];
    const buf2 = this.bytes;
    let i2 = 0;
    while (i2 < buf2.length) {
      const code2 = varint$9.decode(buf2, i2);
      const n = varint$9.decode.bytes;
      const p2 = getProtocol(code2);
      const size = sizeForAddr(p2, buf2.slice(i2 + n));
      i2 += size + n;
      codes2.push(code2);
    }
    return codes2;
  }
  protoNames() {
    return this.protos().map((proto) => proto.name);
  }
  tuples() {
    if (__classPrivateFieldGet$2(this, _DefaultMultiaddr_tuples, "f") == null) {
      __classPrivateFieldSet$1(this, _DefaultMultiaddr_tuples, bytesToTuples(this.bytes), "f");
    }
    return __classPrivateFieldGet$2(this, _DefaultMultiaddr_tuples, "f");
  }
  stringTuples() {
    if (__classPrivateFieldGet$2(this, _DefaultMultiaddr_stringTuples, "f") == null) {
      __classPrivateFieldSet$1(this, _DefaultMultiaddr_stringTuples, tuplesToStringTuples(this.tuples()), "f");
    }
    return __classPrivateFieldGet$2(this, _DefaultMultiaddr_stringTuples, "f");
  }
  encapsulate(addr) {
    addr = new DefaultMultiaddr(addr);
    return new DefaultMultiaddr(this.toString() + addr.toString());
  }
  decapsulate(addr) {
    const addrString = addr.toString();
    const s = this.toString();
    const i2 = s.lastIndexOf(addrString);
    if (i2 < 0) {
      throw new Error(`Address ${this.toString()} does not contain subaddress: ${addr.toString()}`);
    }
    return new DefaultMultiaddr(s.slice(0, i2));
  }
  decapsulateCode(code2) {
    const tuples = this.tuples();
    for (let i2 = tuples.length - 1; i2 >= 0; i2--) {
      if (tuples[i2][0] === code2) {
        return new DefaultMultiaddr(tuplesToBytes(tuples.slice(0, i2)));
      }
    }
    return this;
  }
  getPeerId() {
    try {
      const tuples = this.stringTuples().filter((tuple2) => {
        if (tuple2[0] === names.ipfs.code) {
          return true;
        }
        return false;
      });
      const tuple = tuples.pop();
      if ((tuple == null ? void 0 : tuple[1]) != null) {
        const peerIdStr = tuple[1];
        if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
          return toString$4(base58btc$9.decode(`z${peerIdStr}`), "base58btc");
        }
        return toString$4(CID$9.parse(peerIdStr).multihash.bytes, "base58btc");
      }
      return null;
    } catch (e) {
      return null;
    }
  }
  getPath() {
    let path = null;
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = getProtocol(tuple[0]);
        if (proto.path === true) {
          return true;
        }
        return false;
      })[0][1];
      if (path == null) {
        path = null;
      }
    } catch {
      path = null;
    }
    return path;
  }
  equals(addr) {
    return equals$8(this.bytes, addr.bytes);
  }
  async resolve(options) {
    const resolvableProto = this.protos().find((p2) => p2.resolvable);
    if (resolvableProto == null) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (resolver == null) {
      throw errCode$1(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this, options);
    return addresses.map((a2) => new DefaultMultiaddr(a2));
  }
  nodeAddress() {
    const options = this.toOptions();
    if (options.transport !== "tcp" && options.transport !== "udp") {
      throw new Error(`multiaddr must have a valid format - no protocol with name: "${options.transport}". Must have a valid transport protocol: "{tcp, udp}"`);
    }
    return {
      family: options.family,
      address: options.host,
      port: options.port
    };
  }
  isThinWaistAddress(addr) {
    const protos = (addr != null ? addr : this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  }
  [(_DefaultMultiaddr_string = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_tuples = /* @__PURE__ */ new WeakMap(), _DefaultMultiaddr_stringTuples = /* @__PURE__ */ new WeakMap(), _a$1 = symbol, inspect)]() {
    return this.inspect();
  }
  inspect() {
    return "<Multiaddr " + toString$4(this.bytes, "base16") + " - " + bytesToString(this.bytes) + ">";
  }
}
function multiaddr(addr) {
  return new DefaultMultiaddr(addr);
}
$protobuf.util.Long = void 0;
$protobuf.configure();
async function storePeerUnderSingleDatastoreKey(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a single datastore key");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_2, prefix, type, peerId, metadataKey] = keyStr.split("/");
    if (prefix !== "peers") {
      continue;
    }
    if (!["protos", "addrs", "metadata", "keys"].includes(type)) {
      continue;
    }
    if (!peerId) {
      continue;
    }
    peers[peerId] = peers[peerId] || {
      addresses: [],
      protocols: [],
      metadata: []
    };
    if (type === "protos") {
      const protos = Protocols.decode(value);
      peers[peerId].protocols = protos.protocols.sort();
    } else if (type === "addrs") {
      const addrs = Addresses.decode(value);
      peers[peerId].addresses = addrs.addrs.sort((a2, b2) => {
        return multiaddr(a2.multiaddr).toString().localeCompare(multiaddr(b2.multiaddr).toString());
      });
      if (addrs.certifiedRecord && addrs.certifiedRecord.raw) {
        peers[peerId].peerRecordEnvelope = addrs.certifiedRecord.raw;
      }
    } else if (type === "metadata") {
      peers[peerId].metadata.push({ key: metadataKey, value });
    } else if (type === "keys") {
      peers[peerId].pubKey = value;
    }
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const peerId of Object.keys(peers)) {
    const peer = peers[peerId];
    peer.metadata = peer.metadata.sort((a2, b2) => a2.key.localeCompare(b2.key));
    const data = Peer.encode(peer).finish();
    await backends.datastore.put(new Key(`/peers/${peerId}`), data);
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under a single datastore key");
}
async function storePeerUnderMultipleDatastoreKeys(backends, onProgress = () => {
}) {
  onProgress(0, "Storing each peerstore key under a multiple datastore keys");
  await backends.datastore.open();
  const peers = {};
  const keys = [];
  for await (const { key, value } of backends.datastore.query({
    prefix: "/peers"
  })) {
    keys.push(key);
    const keyStr = key.toString();
    const [_2, _prefix, peerId] = keyStr.split("/");
    peers[peerId] = Peer.decode(value);
  }
  onProgress(33, "Read peer data from store");
  for (const key of keys) {
    await backends.datastore.delete(key);
  }
  onProgress(66, "Removed existing peer data from store");
  for (const [peerId, peer] of Object.entries(peers)) {
    if (peer.protocols && peer.protocols.length > 0) {
      await backends.datastore.put(new Key(`/peers/protos/${peerId}`), Protocols.encode({
        protocols: peer.protocols
      }).finish());
    }
    if (peer.addresses && peer.addresses.length > 0) {
      const peerRecordEnvelope = peer.peerRecordEnvelope;
      let certifiedRecord;
      if (peerRecordEnvelope) {
        const envelope = Envelope.decode(peerRecordEnvelope);
        const record = PeerRecord.decode(envelope.payload);
        certifiedRecord = {
          raw: peerRecordEnvelope,
          seq: record.seq
        };
      }
      await backends.datastore.put(new Key(`/peers/addrs/${peerId}`), Addresses.encode({
        addrs: peer.addresses,
        certifiedRecord
      }).finish());
    }
    if (peer.metadata && peer.metadata.length > 0) {
      for (const { key, value } of peer.metadata) {
        await backends.datastore.put(new Key(`/peers/metadata/${peerId}/${key}`), value);
      }
    }
    if (peer.pubKey) {
      await backends.datastore.put(new Key(`/peers/keys/${peerId}`), peer.pubKey);
    }
  }
  await backends.datastore.close();
  onProgress(100, "Stored each peerstore key under multiple datastore keys");
}
const migration = {
  version: 12,
  description: "Store each peerstore peer under a single datastore key",
  migrate: storePeerUnderSingleDatastoreKey,
  revert: storePeerUnderMultipleDatastoreKeys
};
const emptyMigration = {
  description: "Empty migration.",
  migrate: () => {
  },
  revert: () => {
  },
  empty: true
};
const defaultMigrations = [
  Object.assign({ version: 1 }, emptyMigration),
  Object.assign({ version: 2 }, emptyMigration),
  Object.assign({ version: 3 }, emptyMigration),
  Object.assign({ version: 4 }, emptyMigration),
  Object.assign({ version: 5 }, emptyMigration),
  Object.assign({ version: 6 }, emptyMigration),
  Object.assign({ version: 7 }, emptyMigration),
  migration$4,
  migration$3,
  migration$2,
  migration$1,
  migration
];
class NonReversibleMigrationError extends Error {
  constructor(message) {
    super(message);
    this.name = "NonReversibleMigrationError";
    this.code = NonReversibleMigrationError.code;
    this.message = message;
  }
}
NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
class NotInitializedRepoError extends Error {
  constructor(message) {
    super(message);
    this.name = "NotInitializedRepoError";
    this.code = NotInitializedRepoError.code;
    this.message = message;
  }
}
NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
class RequiredParameterError extends Error {
  constructor(message) {
    super(message);
    this.name = "RequiredParameterError";
    this.code = RequiredParameterError.code;
    this.message = message;
  }
}
RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
class InvalidValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidValueError";
    this.code = InvalidValueError.code;
    this.message = message;
  }
}
InvalidValueError.code = "ERR_INVALID_VALUE";
class MissingRepoOptionsError extends Error {
  constructor(message) {
    super(message);
    this.name = "MissingRepoOptionsError";
    this.code = MissingRepoOptionsError.code;
    this.message = message;
  }
}
MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";
const Errors = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NonReversibleMigrationError,
  NotInitializedRepoError,
  RequiredParameterError,
  InvalidValueError,
  MissingRepoOptionsError
}, Symbol.toStringTag, { value: "Module" }));
const log$6 = debug$1("ipfs:repo:migrator:repo:init");
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root = backends.root;
  try {
    await root.open();
    const versionCheck = await root.has(VERSION_KEY);
    const configCheck = await root.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log$6(`Version entry present: ${versionCheck}`);
      log$6(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log$6("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root !== void 0) {
      try {
        await root.close();
      } catch {
      }
    }
  }
}
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString$3(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version2, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString$3(String(version2)));
  await store.close();
}
const log$5 = debug$1("ipfs:repo:migrator");
function getLatestMigrationVersion(migrations) {
  migrations = migrations || defaultMigrations;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path, backends, repoOptions, toVersion, options = {}) {
  var _a2, _b, _c;
  const ignoreLock = (_a2 = options.ignoreLock) != null ? _a2 : false;
  const onProgress = options.onProgress;
  const isDryRun = (_b = options.isDryRun) != null ? _b : false;
  const migrations = (_c = options.migrations) != null ? _c : defaultMigrations;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log$5("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path);
  }
  try {
    for (const migration2 of migrations) {
      if (toVersion !== void 0 && migration2.version > toVersion) {
        break;
      }
      if (migration2.version <= currentVersion) {
        continue;
      }
      log$5(`Migrating version ${migration2.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration2.version, percent.toFixed(2), message);
          }
          await migration2.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration2.version - 1;
        log$5(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration2.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log$5(`Migrating to version ${migration2.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log$5("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
async function revert(path, backends, repoOptions, toVersion, options = {}) {
  var _a2, _b, _c;
  const ignoreLock = (_a2 = options.ignoreLock) != null ? _a2 : false;
  const onProgress = options.onProgress;
  const isDryRun = (_b = options.isDryRun) != null ? _b : false;
  const migrations = (_c = options.migrations) != null ? _c : defaultMigrations;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log$5("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path);
  }
  log$5(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration2 of reversedMigrationArray) {
      if (migration2.version <= toVersion) {
        break;
      }
      if (migration2.version > currentVersion) {
        continue;
      }
      log$5(`Reverting migration version ${migration2.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration2.version, percent.toFixed(2), message);
          }
          await migration2.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration2.version;
        log$5(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration2.version} exception was raised: ${e.message}`;
        throw e;
      }
      log$5(`Reverting to version ${migration2.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log$5(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration2 of migrations) {
    if (migration2.version > toVersion) {
      break;
    }
    if (migration2.version > fromVersion) {
      if (checkReversibility && !migration2.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration2.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
const errors = Errors;
var bytes$1 = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
bytes$1.exports = bytes;
bytes$1.exports.format = format;
bytes$1.exports.parse = parse;
var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
var map$2 = {
  b: 1,
  kb: 1 << 10,
  mb: 1 << 20,
  gb: 1 << 30,
  tb: Math.pow(1024, 4),
  pb: Math.pow(1024, 5)
};
var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
function bytes(value, options) {
  if (typeof value === "string") {
    return parse(value);
  }
  if (typeof value === "number") {
    return format(value, options);
  }
  return null;
}
function format(value, options) {
  if (!Number.isFinite(value)) {
    return null;
  }
  var mag = Math.abs(value);
  var thousandsSeparator = options && options.thousandsSeparator || "";
  var unitSeparator = options && options.unitSeparator || "";
  var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
  var fixedDecimals = Boolean(options && options.fixedDecimals);
  var unit = options && options.unit || "";
  if (!unit || !map$2[unit.toLowerCase()]) {
    if (mag >= map$2.pb) {
      unit = "PB";
    } else if (mag >= map$2.tb) {
      unit = "TB";
    } else if (mag >= map$2.gb) {
      unit = "GB";
    } else if (mag >= map$2.mb) {
      unit = "MB";
    } else if (mag >= map$2.kb) {
      unit = "KB";
    } else {
      unit = "B";
    }
  }
  var val = value / map$2[unit.toLowerCase()];
  var str = val.toFixed(decimalPlaces);
  if (!fixedDecimals) {
    str = str.replace(formatDecimalsRegExp, "$1");
  }
  if (thousandsSeparator) {
    str = str.split(".").map(function(s, i2) {
      return i2 === 0 ? s.replace(formatThousandsRegExp, thousandsSeparator) : s;
    }).join(".");
  }
  return str + unitSeparator + unit;
}
function parse(val) {
  if (typeof val === "number" && !isNaN(val)) {
    return val;
  }
  if (typeof val !== "string") {
    return null;
  }
  var results = parseRegExp.exec(val);
  var floatValue;
  var unit = "b";
  if (!results) {
    floatValue = parseInt(val, 10);
    unit = "b";
  } else {
    floatValue = parseFloat(results[1]);
    unit = results[4].toLowerCase();
  }
  if (isNaN(floatValue)) {
    return null;
  }
  return Math.floor(map$2[unit] * floatValue);
}
var isPlainObj = (value) => {
  if (Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
};
const isOptionObject = isPlainObj;
const { hasOwnProperty: hasOwnProperty$1 } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name2, value) => Object.defineProperty(object, name2, {
  value,
  writable: true,
  enumerable: true,
  configurable: true
});
const globalThis$1 = commonjsGlobal;
const defaultMergeOptions = {
  concatArrays: false,
  ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value) => {
  const keys = [];
  for (const key in value) {
    if (hasOwnProperty$1.call(value, key)) {
      keys.push(key);
    }
  }
  if (Object.getOwnPropertySymbols) {
    const symbols = Object.getOwnPropertySymbols(value);
    for (const symbol2 of symbols) {
      if (propertyIsEnumerable.call(value, symbol2)) {
        keys.push(symbol2);
      }
    }
  }
  return keys;
};
function clone(value) {
  if (Array.isArray(value)) {
    return cloneArray(value);
  }
  if (isOptionObject(value)) {
    return cloneOptionObject(value);
  }
  return value;
}
function cloneArray(array) {
  const result = array.slice(0, 0);
  getEnumerableOwnPropertyKeys(array).forEach((key) => {
    defineProperty(result, key, clone(array[key]));
  });
  return result;
}
function cloneOptionObject(object) {
  const result = Object.getPrototypeOf(object) === null ? /* @__PURE__ */ Object.create(null) : {};
  getEnumerableOwnPropertyKeys(object).forEach((key) => {
    defineProperty(result, key, clone(object[key]));
  });
  return result;
}
const mergeKeys = (merged, source, keys, config2) => {
  keys.forEach((key) => {
    if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
      return;
    }
    if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
      defineProperty(merged, key, merge$1(merged[key], source[key], config2));
    } else {
      defineProperty(merged, key, clone(source[key]));
    }
  });
  return merged;
};
const concatArrays = (merged, source, config2) => {
  let result = merged.slice(0, 0);
  let resultIndex = 0;
  [merged, source].forEach((array) => {
    const indices = [];
    for (let k = 0; k < array.length; k++) {
      if (!hasOwnProperty$1.call(array, k)) {
        continue;
      }
      indices.push(String(k));
      if (array === merged) {
        defineProperty(result, resultIndex++, array[k]);
      } else {
        defineProperty(result, resultIndex++, clone(array[k]));
      }
    }
    result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config2);
  });
  return result;
};
function merge$1(merged, source, config2) {
  if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
    return concatArrays(merged, source, config2);
  }
  if (!isOptionObject(source) || !isOptionObject(merged)) {
    return clone(source);
  }
  return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
}
var mergeOptions = function(...options) {
  const config2 = merge$1(clone(defaultMergeOptions), this !== globalThis$1 && this || {}, defaultMergeOptions);
  let merged = { _: {} };
  for (const option of options) {
    if (option === void 0) {
      continue;
    }
    if (!isOptionObject(option)) {
      throw new TypeError("`" + option + "` is not an Option Object");
    }
    merged = merge$1(merged, { _: option }, config2);
  }
  return merged._;
};
const repoVersion = 12;
function base$3(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$3 = base$3;
var _brrp__multiformats_scope_baseX$3 = src$3;
const equals$7 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$3 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$1 = (str) => new TextEncoder().encode(str);
const toString$1 = (b2) => new TextDecoder().decode(b2);
class Encoder$3 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$3 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$3(this, decoder);
  }
}
class ComposedDecoder$3 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$3(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$3 = (left, right) => new ComposedDecoder$3({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$3 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$3(name2, prefix, baseEncode);
    this.decoder = new Decoder$3(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$5 = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$3(name2, prefix, encode2, decode2);
const baseX$3 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$3(alphabet2, name2);
  return from$5({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$3(decode2(text))
  });
};
const decode$n = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$h = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$3 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$5({
    prefix,
    name: name2,
    encode(input) {
      return encode$h(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$n(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const identity$6 = from$5({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$1(buf2),
  decode: (str) => fromString$1(str)
});
const identityBase$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$6
}, Symbol.toStringTag, { value: "Module" }));
const base2$2 = rfc4648$3({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: base2$2
}, Symbol.toStringTag, { value: "Module" }));
const base8$2 = rfc4648$3({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: base8$2
}, Symbol.toStringTag, { value: "Module" }));
const base10$2 = baseX$3({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: base10$2
}, Symbol.toStringTag, { value: "Module" }));
const base16$2 = rfc4648$3({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper$1 = rfc4648$3({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: base16$2,
  base16upper: base16upper$1
}, Symbol.toStringTag, { value: "Module" }));
const base32$3 = rfc4648$3({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648$3({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad$1 = rfc4648$3({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648$3({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648$3({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648$3({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648$3({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648$3({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648$3({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: base32$3,
  base32upper,
  base32pad: base32pad$1,
  base32padupper,
  base32hex,
  base32hexupper,
  base32hexpad,
  base32hexpadupper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36$2 = baseX$3({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper$1 = baseX$3({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: base36$2,
  base36upper: base36upper$1
}, Symbol.toStringTag, { value: "Module" }));
const base58btc$3 = baseX$3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX$3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: base58btc$3,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64$3 = rfc4648$3({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad$1 = rfc4648$3({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url$2 = rfc4648$3({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad$1 = rfc4648$3({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$3,
  base64pad: base64pad$1,
  base64url: base64url$2,
  base64urlpad: base64urlpad$1
}, Symbol.toStringTag, { value: "Module" }));
const alphabet$1 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars$1 = alphabet$1.reduce((p2, c, i2) => {
  p2[i2] = c;
  return p2;
}, []);
const alphabetCharsToBytes$1 = alphabet$1.reduce((p2, c, i2) => {
  p2[c.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$g(data) {
  return data.reduce((p2, c) => {
    p2 += alphabetBytesToChars$1[c];
    return p2;
  }, "");
}
function decode$m(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes$1[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji$2 = from$5({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$g,
  decode: decode$m
});
const base256emoji$3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: base256emoji$2
}, Symbol.toStringTag, { value: "Module" }));
var encode_1$3 = encode$f;
var MSB$4 = 128, REST$4 = 127, MSBALL$3 = ~REST$4, INT$3 = Math.pow(2, 31);
function encode$f(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$3) {
    out[offset++] = num & 255 | MSB$4;
    num /= 128;
  }
  while (num & MSBALL$3) {
    out[offset++] = num & 255 | MSB$4;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$f.bytes = offset - oldOffset + 1;
  return out;
}
var decode$l = read$3;
var MSB$1$3 = 128, REST$1$3 = 127;
function read$3(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$3.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$3) << shift : (b2 & REST$1$3) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$3);
  read$3.bytes = counter - offset;
  return res;
}
var N1$3 = Math.pow(2, 7);
var N2$3 = Math.pow(2, 14);
var N3$3 = Math.pow(2, 21);
var N4$3 = Math.pow(2, 28);
var N5$3 = Math.pow(2, 35);
var N6$3 = Math.pow(2, 42);
var N7$3 = Math.pow(2, 49);
var N8$3 = Math.pow(2, 56);
var N9$3 = Math.pow(2, 63);
var length$3 = function(value) {
  return value < N1$3 ? 1 : value < N2$3 ? 2 : value < N3$3 ? 3 : value < N4$3 ? 4 : value < N5$3 ? 5 : value < N6$3 ? 6 : value < N7$3 ? 7 : value < N8$3 ? 8 : value < N9$3 ? 9 : 10;
};
var varint$3 = {
  encode: encode_1$3,
  decode: decode$l,
  encodingLength: length$3
};
var _brrp_varint$3 = varint$3;
const decode$k = (data, offset = 0) => {
  const code2 = _brrp_varint$3.decode(data, offset);
  return [
    code2,
    _brrp_varint$3.decode.bytes
  ];
};
const encodeTo$3 = (int, target, offset = 0) => {
  _brrp_varint$3.encode(int, target, offset);
  return target;
};
const encodingLength$3 = (int) => {
  return _brrp_varint$3.encodingLength(int);
};
const create$3 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$3(code2);
  const digestOffset = sizeOffset + encodingLength$3(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$3(code2, bytes2, 0);
  encodeTo$3(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$3(code2, size, digest2, bytes2);
};
const decode$j = (multihash) => {
  const bytes2 = coerce$3(multihash);
  const [code2, sizeOffset] = decode$k(bytes2);
  const [size, digestOffset] = decode$k(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$3(code2, size, digest2, bytes2);
};
const equals$6 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$7(a2.bytes, b2.bytes);
  }
};
class Digest$3 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
const from$4 = ({ name: name2, code: code2, encode: encode2 }) => new Hasher(name2, code2, encode2);
class Hasher {
  constructor(name2, code2, encode2) {
    this.name = name2;
    this.code = code2;
    this.encode = encode2;
  }
  digest(input) {
    if (input instanceof Uint8Array) {
      const result = this.encode(input);
      return result instanceof Uint8Array ? create$3(this.code, result) : result.then((digest2) => create$3(this.code, digest2));
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
const sha = (name2) => async (data) => new Uint8Array(await crypto.subtle.digest(name2, data));
const sha256 = from$4({
  name: "sha2-256",
  code: 18,
  encode: sha("SHA-256")
});
const sha512 = from$4({
  name: "sha2-512",
  code: 19,
  encode: sha("SHA-512")
});
const sha2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256,
  sha512
}, Symbol.toStringTag, { value: "Module" }));
const code$6 = 0;
const name$4 = "identity";
const encode$e = coerce$3;
const digest$1 = (input) => create$3(code$6, encode$e(input));
const identity$4 = {
  code: code$6,
  name: name$4,
  encode: encode$e,
  digest: digest$1
};
const identity$5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$4
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
class CID$3 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$3,
      byteLength: hidden$3,
      code: readonly$4,
      version: readonly$4,
      multihash: readonly$4,
      bytes: readonly$4,
      _baseCache: hidden$3,
      asCID: hidden$3
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$3) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$3) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$3.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$3(code2, digest2);
        return CID$3.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$6(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$3(bytes2, _baseCache, base3 || base58btc$3.encoder);
      default:
        return toStringV1$3(bytes2, _baseCache, base3 || base32$3.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$3(/^0\.0/, IS_CID_DEPRECATION$3);
    return !!(value && (value[cidSymbol$3] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$3) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$3(version2, code2, multihash, bytes2 || encodeCID$3(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$3] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$j(multihash);
      return CID$3.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$3) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$3}) block encoding`);
        } else {
          return new CID$3(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$3(version2, code2, digest2.bytes);
        return new CID$3(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$3.create(0, DAG_PB_CODE$3, digest2);
  }
  static createV1(code2, digest2) {
    return CID$3.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$3.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$3.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$3(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$3(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$3.createV0(digest2) : CID$3.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$k(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$3;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$3(source, base3);
    const cid = CID$3.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$3 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$3;
      return [
        base58btc$3.prefix,
        decoder.decode(`${base58btc$3.prefix}${source}`)
      ];
    }
    case base58btc$3.prefix: {
      const decoder = base3 || base58btc$3;
      return [
        base58btc$3.prefix,
        decoder.decode(source)
      ];
    }
    case base32$3.prefix: {
      const decoder = base3 || base32$3;
      return [
        base32$3.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$3 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$3.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$3 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$3 = 112;
const SHA_256_CODE$3 = 18;
const encodeCID$3 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$3(version2);
  const hashOffset = codeOffset + encodingLength$3(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$3(version2, bytes2, 0);
  encodeTo$3(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$3 = Symbol.for("@ipld/js-cid/CID");
const readonly$4 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$3 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$4 = "0.0.0-dev";
const deprecate$3 = (range, message) => {
  if (range.test(version$4)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$3 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const bases = {
  ...identityBase$1,
  ...base2$3,
  ...base8$3,
  ...base10$3,
  ...base16$3,
  ...base32$4,
  ...base36$3,
  ...base58,
  ...base64$4,
  ...base256emoji$3
};
({
  ...sha2,
  ...identity$5
});
function asUint8Array(buf2) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength);
  }
  return buf2;
}
function allocUnsafe(size = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size));
  }
  return new Uint8Array(size);
}
function createCodec(name2, prefix, encode2, decode2) {
  return {
    name: name2,
    prefix,
    encoder: {
      name: name2,
      prefix,
      encode: encode2
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf2) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf2);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf2) => {
  let string2 = "a";
  for (let i2 = 0; i2 < buf2.length; i2++) {
    string2 += String.fromCharCode(buf2[i2]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf2 = allocUnsafe(str.length);
  for (let i2 = 0; i2 < str.length; i2++) {
    buf2[i2] = str.charCodeAt(i2);
  }
  return buf2;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function toString(array, encoding2 = "utf8") {
  const base3 = BASES[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
function fromString(string2, encoding2 = "utf8") {
  const base3 = BASES[encoding2];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding2}"`);
  }
  if ((encoding2 === "utf8" || encoding2 === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
class LockExistsError extends Error {
  constructor(message) {
    super(message);
    this.name = "LockExistsError";
    this.code = LockExistsError.code;
  }
}
LockExistsError.code = "ERR_LOCK_EXISTS";
class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.name = "NotFoundError";
    this.code = NotFoundError.code;
  }
}
NotFoundError.code = "ERR_NOT_FOUND";
class InvalidRepoVersionError extends Error {
  constructor(message) {
    super(message);
    this.name = "InvalidRepoVersionError";
    this.code = InvalidRepoVersionError.code;
  }
}
InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
const ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
const ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
const ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get2, has, store) {
  if (await has(key)) {
    return get2(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
const log$4 = debug$1("ipfs:repo:version");
const versionKey = new Key("version");
function version$3(store) {
  return {
    async exists() {
      return hasWithFallback(versionKey, store.has.bind(store), store);
    },
    async get() {
      const buf2 = await getWithFallback(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString(buf2), 10);
    },
    set(version2) {
      return store.put(versionKey, fromString(String(version2)));
    },
    async check(expected) {
      const version2 = await this.get();
      log$4("comparing version: %s and %s", version2, expected);
      const compatibleVersion = version2 === 6 && expected === 7 || expected === 6 && version2 === 7;
      return version2 === expected || compatibleVersion;
    }
  };
}
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn2, context, once3) {
    this.fn = fn2;
    this.context = context;
    this.once = once3 || false;
  }
  function addListener2(emitter, event, fn2, context, once3) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn2, context || emitter, once3), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames2() {
    var names2 = [], events2, name2;
    if (this._eventsCount === 0)
      return names2;
    for (name2 in events2 = this._events) {
      if (has.call(events2, name2))
        names2.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names2.concat(Object.getOwnPropertySymbols(events2));
    }
    return names2;
  };
  EventEmitter2.prototype.listeners = function listeners2(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i2 = 0, l2 = handlers.length, ee2 = new Array(l2); i2 < l2; i2++) {
      ee2[i2] = handlers[i2].fn;
    }
    return ee2;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount2(event) {
    var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
    if (!listeners2)
      return 0;
    if (listeners2.fn)
      return 1;
    return listeners2.length;
  };
  EventEmitter2.prototype.emit = function emit3(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners2 = this._events[evt], len2 = arguments.length, args, i2;
    if (listeners2.fn) {
      if (listeners2.once)
        this.removeListener(event, listeners2.fn, void 0, true);
      switch (len2) {
        case 1:
          return listeners2.fn.call(listeners2.context), true;
        case 2:
          return listeners2.fn.call(listeners2.context, a1), true;
        case 3:
          return listeners2.fn.call(listeners2.context, a1, a2), true;
        case 4:
          return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
        case 5:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
        case 6:
          return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
      }
      for (i2 = 1, args = new Array(len2 - 1); i2 < len2; i2++) {
        args[i2 - 1] = arguments[i2];
      }
      listeners2.fn.apply(listeners2.context, args);
    } else {
      var length2 = listeners2.length, j;
      for (i2 = 0; i2 < length2; i2++) {
        if (listeners2[i2].once)
          this.removeListener(event, listeners2[i2].fn, void 0, true);
        switch (len2) {
          case 1:
            listeners2[i2].fn.call(listeners2[i2].context);
            break;
          case 2:
            listeners2[i2].fn.call(listeners2[i2].context, a1);
            break;
          case 3:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2);
            break;
          case 4:
            listeners2[i2].fn.call(listeners2[i2].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len2 - 1); j < len2; j++) {
                args[j - 1] = arguments[j];
              }
            listeners2[i2].fn.apply(listeners2[i2].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on2(event, fn2, context) {
    return addListener2(this, event, fn2, context, false);
  };
  EventEmitter2.prototype.once = function once3(event, fn2, context) {
    return addListener2(this, event, fn2, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener2(event, fn2, context, once3) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn2) {
      clearEvent(this, evt);
      return this;
    }
    var listeners2 = this._events[evt];
    if (listeners2.fn) {
      if (listeners2.fn === fn2 && (!once3 || listeners2.once) && (!context || listeners2.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i2 = 0, events2 = [], length2 = listeners2.length; i2 < length2; i2++) {
        if (listeners2[i2].fn !== fn2 || once3 && !listeners2[i2].once || context && listeners2[i2].context !== context) {
          events2.push(listeners2[i2]);
        }
      }
      if (events2.length)
        this._events[evt] = events2.length === 1 ? events2[0] : events2;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners2(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
const EventEmitter$1 = eventemitter3.exports;
class TimeoutError$1 extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
}
class AbortError$2 extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
const getDOMException$1 = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError$2(errorMessage) : new DOMException(errorMessage);
const getAbortedReason$1 = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException$1("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException$1(reason);
};
function pTimeout$1(promise2, milliseconds, fallback, options) {
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise2);
      return;
    }
    options = {
      customTimers: { setTimeout, clearTimeout },
      ...options
    };
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason$1(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason$1(signal));
      });
    }
    timer = options.customTimers.setTimeout.call(void 0, () => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = fallback instanceof Error ? fallback : new TimeoutError$1(message);
      if (typeof promise2.cancel === "function") {
        promise2.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise2);
      } catch (error) {
        reject(error);
      } finally {
        options.customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    clearTimeout(timer);
    timer = void 0;
  };
  return cancelablePromise;
}
function lowerBound(array, value, comparator) {
  let first2 = 0;
  let count = array.length;
  while (count > 0) {
    const step = Math.trunc(count / 2);
    let it = first2 + step;
    if (comparator(array[it], value) <= 0) {
      first2 = ++it;
      count -= step + 1;
    } else {
      count = step;
    }
  }
  return first2;
}
var __classPrivateFieldGet$1 = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PriorityQueue_queue;
class PriorityQueue {
  constructor() {
    _PriorityQueue_queue.set(this, []);
  }
  enqueue(run, options) {
    options = {
      priority: 0,
      ...options
    };
    const element = {
      priority: options.priority,
      run
    };
    if (this.size && __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f")[this.size - 1].priority >= options.priority) {
      __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").push(element);
      return;
    }
    const index = lowerBound(__classPrivateFieldGet$1(this, _PriorityQueue_queue, "f"), element, (a2, b2) => b2.priority - a2.priority);
    __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").splice(index, 0, element);
  }
  dequeue() {
    const item = __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").shift();
    return item === null || item === void 0 ? void 0 : item.run;
  }
  filter(options) {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").filter((element) => element.priority === options.priority).map((element) => element.run);
  }
  get size() {
    return __classPrivateFieldGet$1(this, _PriorityQueue_queue, "f").length;
  }
}
_PriorityQueue_queue = /* @__PURE__ */ new WeakMap();
var __classPrivateFieldSet = globalThis && globalThis.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = globalThis && globalThis.__classPrivateFieldGet || function(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _PQueue_instances, _PQueue_carryoverConcurrencyCount, _PQueue_isIntervalIgnored, _PQueue_intervalCount, _PQueue_intervalCap, _PQueue_interval, _PQueue_intervalEnd, _PQueue_intervalId, _PQueue_timeoutId, _PQueue_queue, _PQueue_queueClass, _PQueue_pendingCount, _PQueue_concurrency, _PQueue_isPaused, _PQueue_throwOnTimeout, _PQueue_doesIntervalAllowAnother_get, _PQueue_doesConcurrentAllowAnother_get, _PQueue_next, _PQueue_emitEvents, _PQueue_onResumeInterval, _PQueue_isIntervalPaused_get, _PQueue_tryToStartAnother, _PQueue_initializeIntervalIfNeeded, _PQueue_onInterval, _PQueue_processQueue, _PQueue_onEvent;
const timeoutError = new TimeoutError$1();
class AbortError$1 extends Error {
}
class PQueue extends EventEmitter$1 {
  constructor(options) {
    var _a2, _b, _c, _d2;
    super();
    _PQueue_instances.add(this);
    _PQueue_carryoverConcurrencyCount.set(this, void 0);
    _PQueue_isIntervalIgnored.set(this, void 0);
    _PQueue_intervalCount.set(this, 0);
    _PQueue_intervalCap.set(this, void 0);
    _PQueue_interval.set(this, void 0);
    _PQueue_intervalEnd.set(this, 0);
    _PQueue_intervalId.set(this, void 0);
    _PQueue_timeoutId.set(this, void 0);
    _PQueue_queue.set(this, void 0);
    _PQueue_queueClass.set(this, void 0);
    _PQueue_pendingCount.set(this, 0);
    _PQueue_concurrency.set(this, void 0);
    _PQueue_isPaused.set(this, void 0);
    _PQueue_throwOnTimeout.set(this, void 0);
    Object.defineProperty(this, "timeout", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    options = {
      carryoverConcurrencyCount: false,
      intervalCap: Number.POSITIVE_INFINITY,
      interval: 0,
      concurrency: Number.POSITIVE_INFINITY,
      autoStart: true,
      queueClass: PriorityQueue,
      ...options
    };
    if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
      throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a2 = options.intervalCap) === null || _a2 === void 0 ? void 0 : _a2.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
    }
    if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
      throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d2 = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d2 !== void 0 ? _d2 : ""}\` (${typeof options.interval})`);
    }
    __classPrivateFieldSet(this, _PQueue_carryoverConcurrencyCount, options.carryoverConcurrencyCount, "f");
    __classPrivateFieldSet(this, _PQueue_isIntervalIgnored, options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0, "f");
    __classPrivateFieldSet(this, _PQueue_intervalCap, options.intervalCap, "f");
    __classPrivateFieldSet(this, _PQueue_interval, options.interval, "f");
    __classPrivateFieldSet(this, _PQueue_queue, new options.queueClass(), "f");
    __classPrivateFieldSet(this, _PQueue_queueClass, options.queueClass, "f");
    this.concurrency = options.concurrency;
    this.timeout = options.timeout;
    __classPrivateFieldSet(this, _PQueue_throwOnTimeout, options.throwOnTimeout === true, "f");
    __classPrivateFieldSet(this, _PQueue_isPaused, options.autoStart === false, "f");
  }
  get concurrency() {
    return __classPrivateFieldGet(this, _PQueue_concurrency, "f");
  }
  set concurrency(newConcurrency) {
    if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
      throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
    }
    __classPrivateFieldSet(this, _PQueue_concurrency, newConcurrency, "f");
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
  }
  async add(fn2, options = {}) {
    return new Promise((resolve, reject) => {
      const run = async () => {
        var _a2;
        var _b, _c;
        __classPrivateFieldSet(this, _PQueue_pendingCount, (_b = __classPrivateFieldGet(this, _PQueue_pendingCount, "f"), _b++, _b), "f");
        __classPrivateFieldSet(this, _PQueue_intervalCount, (_c = __classPrivateFieldGet(this, _PQueue_intervalCount, "f"), _c++, _c), "f");
        try {
          if ((_a2 = options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
            reject(new AbortError$1("The task was aborted."));
            return;
          }
          const operation = this.timeout === void 0 && options.timeout === void 0 ? fn2({ signal: options.signal }) : pTimeout$1(Promise.resolve(fn2({ signal: options.signal })), options.timeout === void 0 ? this.timeout : options.timeout, () => {
            if (options.throwOnTimeout === void 0 ? __classPrivateFieldGet(this, _PQueue_throwOnTimeout, "f") : options.throwOnTimeout) {
              reject(timeoutError);
            }
            return void 0;
          });
          const result = await operation;
          resolve(result);
          this.emit("completed", result);
        } catch (error) {
          reject(error);
          this.emit("error", error);
        }
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_next).call(this);
      };
      __classPrivateFieldGet(this, _PQueue_queue, "f").enqueue(run, options);
      __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
      this.emit("add");
    });
  }
  async addAll(functions, options) {
    return Promise.all(functions.map(async (function_) => this.add(function_, options)));
  }
  start() {
    if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
      return this;
    }
    __classPrivateFieldSet(this, _PQueue_isPaused, false, "f");
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
    return this;
  }
  pause() {
    __classPrivateFieldSet(this, _PQueue_isPaused, true, "f");
  }
  clear() {
    __classPrivateFieldSet(this, _PQueue_queue, new (__classPrivateFieldGet(this, _PQueue_queueClass, "f"))(), "f");
  }
  async onEmpty() {
    if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "empty");
  }
  async onSizeLessThan(limit) {
    if (__classPrivateFieldGet(this, _PQueue_queue, "f").size < limit) {
      return;
    }
    await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "next", () => __classPrivateFieldGet(this, _PQueue_queue, "f").size < limit);
  }
  async onIdle() {
    if (__classPrivateFieldGet(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_queue, "f").size === 0) {
      return;
    }
    await __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onEvent).call(this, "idle");
  }
  get size() {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").size;
  }
  sizeBy(options) {
    return __classPrivateFieldGet(this, _PQueue_queue, "f").filter(options).length;
  }
  get pending() {
    return __classPrivateFieldGet(this, _PQueue_pendingCount, "f");
  }
  get isPaused() {
    return __classPrivateFieldGet(this, _PQueue_isPaused, "f");
  }
}
_PQueue_carryoverConcurrencyCount = /* @__PURE__ */ new WeakMap(), _PQueue_isIntervalIgnored = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCount = /* @__PURE__ */ new WeakMap(), _PQueue_intervalCap = /* @__PURE__ */ new WeakMap(), _PQueue_interval = /* @__PURE__ */ new WeakMap(), _PQueue_intervalEnd = /* @__PURE__ */ new WeakMap(), _PQueue_intervalId = /* @__PURE__ */ new WeakMap(), _PQueue_timeoutId = /* @__PURE__ */ new WeakMap(), _PQueue_queue = /* @__PURE__ */ new WeakMap(), _PQueue_queueClass = /* @__PURE__ */ new WeakMap(), _PQueue_pendingCount = /* @__PURE__ */ new WeakMap(), _PQueue_concurrency = /* @__PURE__ */ new WeakMap(), _PQueue_isPaused = /* @__PURE__ */ new WeakMap(), _PQueue_throwOnTimeout = /* @__PURE__ */ new WeakMap(), _PQueue_instances = /* @__PURE__ */ new WeakSet(), _PQueue_doesIntervalAllowAnother_get = function _PQueue_doesIntervalAllowAnother_get2() {
  return __classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalCount, "f") < __classPrivateFieldGet(this, _PQueue_intervalCap, "f");
}, _PQueue_doesConcurrentAllowAnother_get = function _PQueue_doesConcurrentAllowAnother_get2() {
  return __classPrivateFieldGet(this, _PQueue_pendingCount, "f") < __classPrivateFieldGet(this, _PQueue_concurrency, "f");
}, _PQueue_next = function _PQueue_next2() {
  var _a2;
  __classPrivateFieldSet(this, _PQueue_pendingCount, (_a2 = __classPrivateFieldGet(this, _PQueue_pendingCount, "f"), _a2--, _a2), "f");
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this);
  this.emit("next");
}, _PQueue_emitEvents = function _PQueue_emitEvents2() {
  this.emit("empty");
  if (__classPrivateFieldGet(this, _PQueue_pendingCount, "f") === 0) {
    this.emit("idle");
  }
}, _PQueue_onResumeInterval = function _PQueue_onResumeInterval2() {
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
  __classPrivateFieldSet(this, _PQueue_timeoutId, void 0, "f");
}, _PQueue_isIntervalPaused_get = function _PQueue_isIntervalPaused_get2() {
  const now = Date.now();
  if (__classPrivateFieldGet(this, _PQueue_intervalId, "f") === void 0) {
    const delay = __classPrivateFieldGet(this, _PQueue_intervalEnd, "f") - now;
    if (delay < 0) {
      __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pendingCount, "f") : 0, "f");
    } else {
      if (__classPrivateFieldGet(this, _PQueue_timeoutId, "f") === void 0) {
        __classPrivateFieldSet(this, _PQueue_timeoutId, setTimeout(() => {
          __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onResumeInterval).call(this);
        }, delay), "f");
      }
      return true;
    }
  }
  return false;
}, _PQueue_tryToStartAnother = function _PQueue_tryToStartAnother2() {
  if (__classPrivateFieldGet(this, _PQueue_queue, "f").size === 0) {
    if (__classPrivateFieldGet(this, _PQueue_intervalId, "f")) {
      clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f"));
    }
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_emitEvents).call(this);
    return false;
  }
  if (!__classPrivateFieldGet(this, _PQueue_isPaused, "f")) {
    const canInitializeInterval = !__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_isIntervalPaused_get);
    if (__classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesIntervalAllowAnother_get) && __classPrivateFieldGet(this, _PQueue_instances, "a", _PQueue_doesConcurrentAllowAnother_get)) {
      const job = __classPrivateFieldGet(this, _PQueue_queue, "f").dequeue();
      if (!job) {
        return false;
      }
      this.emit("active");
      job();
      if (canInitializeInterval) {
        __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_initializeIntervalIfNeeded).call(this);
      }
      return true;
    }
  }
  return false;
}, _PQueue_initializeIntervalIfNeeded = function _PQueue_initializeIntervalIfNeeded2() {
  if (__classPrivateFieldGet(this, _PQueue_isIntervalIgnored, "f") || __classPrivateFieldGet(this, _PQueue_intervalId, "f") !== void 0) {
    return;
  }
  __classPrivateFieldSet(this, _PQueue_intervalId, setInterval(() => {
    __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_onInterval).call(this);
  }, __classPrivateFieldGet(this, _PQueue_interval, "f")), "f");
  __classPrivateFieldSet(this, _PQueue_intervalEnd, Date.now() + __classPrivateFieldGet(this, _PQueue_interval, "f"), "f");
}, _PQueue_onInterval = function _PQueue_onInterval2() {
  if (__classPrivateFieldGet(this, _PQueue_intervalCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_pendingCount, "f") === 0 && __classPrivateFieldGet(this, _PQueue_intervalId, "f")) {
    clearInterval(__classPrivateFieldGet(this, _PQueue_intervalId, "f"));
    __classPrivateFieldSet(this, _PQueue_intervalId, void 0, "f");
  }
  __classPrivateFieldSet(this, _PQueue_intervalCount, __classPrivateFieldGet(this, _PQueue_carryoverConcurrencyCount, "f") ? __classPrivateFieldGet(this, _PQueue_pendingCount, "f") : 0, "f");
  __classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_processQueue).call(this);
}, _PQueue_processQueue = function _PQueue_processQueue2() {
  while (__classPrivateFieldGet(this, _PQueue_instances, "m", _PQueue_tryToStartAnother).call(this)) {
  }
}, _PQueue_onEvent = async function _PQueue_onEvent2(event, filter2) {
  return new Promise((resolve) => {
    const listener = () => {
      if (filter2 && !filter2()) {
        return;
      }
      this.off(event, listener);
      resolve();
    };
    this.on(event, listener);
  });
};
var objectSafeSet = set;
function set(obj, propsArg, value) {
  var props, lastProp;
  if (Array.isArray(propsArg)) {
    props = propsArg.slice(0);
  }
  if (typeof propsArg == "string") {
    props = propsArg.split(".");
  }
  if (typeof propsArg == "symbol") {
    props = [propsArg];
  }
  if (!Array.isArray(props)) {
    throw new Error("props arg must be an array, a string or a symbol");
  }
  lastProp = props.pop();
  if (!lastProp) {
    return false;
  }
  prototypeCheck(lastProp);
  var thisProp;
  while (thisProp = props.shift()) {
    prototypeCheck(thisProp);
    if (typeof obj[thisProp] == "undefined") {
      obj[thisProp] = {};
    }
    obj = obj[thisProp];
    if (!obj || typeof obj != "object") {
      return false;
    }
  }
  obj[lastProp] = value;
  return true;
}
function prototypeCheck(prop) {
  if (prop == "__proto__" || prop == "constructor" || prop == "prototype") {
    throw new Error("setting of prototype values not supported");
  }
}
const Queue = PQueue.default ? PQueue.default : PQueue;
const configKey = new Key("config");
function config(store) {
  const setQueue = new Queue({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value = objectSafeGet(config2, key);
      if (value === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value;
    },
    set(key, value, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw errCode$1(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value === void 0 || value instanceof Uint8Array) {
        throw errCode$1(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value
      }, options.signal));
    },
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw errCode$1(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value
      }, options.signal));
    },
    async exists() {
      return hasWithFallback(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        objectSafeSet(config2, key, value);
      }
      return _saveAll(config2);
    }
    return _saveAll(value);
  }
  function _saveAll(config2) {
    const buf2 = fromString(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf2);
  }
}
function isPlainObject(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function sortKeys(object, options = {}) {
  if (!isPlainObject(object) && !Array.isArray(object)) {
    throw new TypeError("Expected a plain object or array");
  }
  const { deep, compare: compare2 } = options;
  const seenInput = [];
  const seenOutput = [];
  const deepSortArray = (array) => {
    const seenIndex = seenInput.indexOf(array);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = [];
    seenInput.push(array);
    seenOutput.push(result);
    result.push(...array.map((item) => {
      if (Array.isArray(item)) {
        return deepSortArray(item);
      }
      if (isPlainObject(item)) {
        return _sortKeys(item);
      }
      return item;
    }));
    return result;
  };
  const _sortKeys = (object2) => {
    const seenIndex = seenInput.indexOf(object2);
    if (seenIndex !== -1) {
      return seenOutput[seenIndex];
    }
    const result = {};
    const keys = Object.keys(object2).sort(compare2);
    seenInput.push(object2);
    seenOutput.push(result);
    for (const key of keys) {
      const value = object2[key];
      let newValue;
      if (deep && Array.isArray(value)) {
        newValue = deepSortArray(value);
      } else {
        newValue = deep && isPlainObject(value) ? _sortKeys(value) : value;
      }
      Object.defineProperty(result, key, {
        ...Object.getOwnPropertyDescriptor(object2, key),
        value: newValue
      });
    }
    return result;
  };
  if (Array.isArray(object)) {
    return deep ? deepSortArray(object) : object.slice();
  }
  return _sortKeys(object);
}
const specKey = new Key("datastore_spec");
function spec(store) {
  return {
    exists() {
      return store.has(specKey);
    },
    async get() {
      const buf2 = await store.get(specKey);
      return JSON.parse(toString(buf2));
    },
    async set(spec2) {
      return store.put(specKey, fromString(JSON.stringify(sortKeys(spec2, { deep: true }))));
    }
  };
}
const apiFile = new Key("api");
function apiAddr(store) {
  return {
    async get() {
      const value = await store.get(apiFile);
      return value && value.toString();
    },
    set(value) {
      return store.put(apiFile, fromString(value.toString()));
    },
    delete() {
      return store.delete(apiFile);
    }
  };
}
const filter$1 = async function* (source, fn2) {
  for await (const entry of source) {
    if (await fn2(entry)) {
      yield entry;
    }
  }
};
var itFilter = filter$1;
class FixedFIFO$1 {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) {
      throw new Error("Max size for a FixedFIFO should be a power of two");
    }
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0) {
      return false;
    }
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0) {
      return void 0;
    }
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
}
class FIFO$1 {
  constructor(options = {}) {
    var _a2;
    this.hwm = (_a2 = options.splitLimit) != null ? _a2 : 16;
    this.head = new FixedFIFO$1(this.hwm);
    this.tail = this.head;
    this.size = 0;
  }
  calculateSize(obj) {
    if ((obj == null ? void 0 : obj.byteLength) != null) {
      return obj.byteLength;
    }
    return 1;
  }
  push(val) {
    if ((val == null ? void 0 : val.value) != null) {
      this.size += this.calculateSize(val.value);
    }
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO$1(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    let val = this.tail.shift();
    if (val === void 0 && this.tail.next != null) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      val = this.tail.shift();
    }
    if ((val == null ? void 0 : val.value) != null) {
      this.size -= this.calculateSize(val.value);
    }
    return val;
  }
  isEmpty() {
    return this.head.isEmpty();
  }
}
function pushable$1(options = {}) {
  const getNext = (buffer2) => {
    const next = buffer2.shift();
    if (next == null) {
      return { done: true };
    }
    if (next.error != null) {
      throw next.error;
    }
    return {
      done: next.done === true,
      value: next.value
    };
  };
  return _pushable(getNext, options);
}
function _pushable(getNext, options) {
  options = options != null ? options : {};
  let onEnd = options.onEnd;
  let buffer2 = new FIFO$1();
  let pushable2;
  let onNext;
  let ended;
  const waitNext = async () => {
    if (!buffer2.isEmpty()) {
      return getNext(buffer2);
    }
    if (ended) {
      return { done: true };
    }
    return await new Promise((resolve, reject) => {
      onNext = (next) => {
        onNext = null;
        buffer2.push(next);
        try {
          resolve(getNext(buffer2));
        } catch (err) {
          reject(err);
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext != null) {
      return onNext(next);
    }
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer2 = new FIFO$1();
    if (onNext != null) {
      return onNext({ error: err });
    }
    buffer2.push({ error: err });
    return pushable2;
  };
  const push2 = (value) => {
    if (ended) {
      return pushable2;
    }
    if ((options == null ? void 0 : options.objectMode) !== true && (value == null ? void 0 : value.byteLength) == null) {
      throw new Error("objectMode was not true but tried to push non-Uint8Array value");
    }
    return bufferNext({ done: false, value });
  };
  const end2 = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err != null ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO$1();
    end2();
    return { done: true };
  };
  const _throw = (err) => {
    end2(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push: push2,
    end: end2,
    get readableLength() {
      return buffer2.size;
    }
  };
  if (onEnd == null) {
    return pushable2;
  }
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd != null) {
        onEnd();
        onEnd = void 0;
      }
      return { done: true };
    },
    push: push2,
    end(err) {
      _pushable2.end(err);
      if (onEnd != null) {
        onEnd(err);
        onEnd = void 0;
      }
      return pushable2;
    },
    get readableLength() {
      return _pushable2.readableLength;
    }
  };
  return pushable2;
}
const drain = async (source) => {
  for await (const _2 of source) {
  }
};
var itDrain = drain;
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = pushable$1({
        objectMode: true
      });
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await itDrain(store.putMany(async function* () {
            for await (const { key, value } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield { key, value };
              }
              output.push({ key, value });
            }
          }()));
          output.end();
        } catch (err) {
          output.end(err);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(itFilter(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch2 = store.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch2.delete(cid);
        },
        commit: (options) => {
          return batch2.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID$3.asCID(k);
  if (cid == null) {
    throw errCode$1(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity$4.code) {
    return {
      isIdentity: false
    };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}
const log$3 = debug$1("ipfs:repo:lock:memory");
const lockFile = "repo.lock";
const LOCKS = {};
async function lock(dir) {
  const file = dir + "/" + lockFile;
  log$3("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log$3(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
const MemoryLock = {
  lock,
  locked
};
const defaultOptions$3 = {
  autoMigrate: true,
  onMigrationProgress: () => {
  },
  repoOwner: true,
  repoLock: MemoryLock
};
const defaultDatastore = {
  Spec: {
    type: "mount",
    mounts: [
      {
        mountpoint: "/blocks",
        type: "measure",
        prefix: "flatfs.datastore",
        child: {
          type: "flatfs",
          path: "blocks",
          sync: true,
          shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
        }
      },
      {
        mountpoint: "/",
        type: "measure",
        prefix: "leveldb.datastore",
        child: {
          type: "levelds",
          path: "datastore",
          compression: "none"
        }
      }
    ]
  }
};
const first = async (source) => {
  for await (const entry of source) {
    return entry;
  }
  return void 0;
};
var itFirst = first;
const readonly$3 = ({ enumerable = true, configurable = false } = {}) => ({
  enumerable,
  configurable,
  writable: false
});
const links = function* (source, base3) {
  if (source == null)
    return;
  if (source instanceof Uint8Array)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    if (value != null && typeof value === "object") {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid = CID$3.asCID(element);
          if (cid) {
            yield [
              elementPath.join("/"),
              cid
            ];
          } else if (typeof element === "object") {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid = CID$3.asCID(value);
        if (cid) {
          yield [
            path.join("/"),
            cid
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
};
const tree = function* (source, base3) {
  if (source == null)
    return;
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base3,
      key
    ];
    yield path.join("/");
    if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID$3.asCID(value)) {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          yield elementPath.join("/");
          if (typeof element === "object" && !CID$3.asCID(element)) {
            yield* tree(element, elementPath);
          }
        }
      } else {
        yield* tree(value, path);
      }
    }
  }
};
const get = (source, path) => {
  let node = source;
  for (const [index, key] of path.entries()) {
    node = node[key];
    if (node == null) {
      throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
    }
    const cid = CID$3.asCID(node);
    if (cid) {
      return {
        value: cid,
        remaining: path.slice(index + 1).join("/")
      };
    }
  }
  return { value: node };
};
class Block {
  constructor({ cid, bytes: bytes2, value }) {
    if (!cid || !bytes2 || typeof value === "undefined")
      throw new Error("Missing required argument");
    this.cid = cid;
    this.bytes = bytes2;
    this.value = value;
    this.asBlock = this;
    Object.defineProperties(this, {
      cid: readonly$3(),
      bytes: readonly$3(),
      value: readonly$3(),
      asBlock: readonly$3()
    });
  }
  links() {
    return links(this.value, []);
  }
  tree() {
    return tree(this.value, []);
  }
  get(path = "/") {
    return get(this.value, path.split("/").filter(Boolean));
  }
}
const createUnsafe = ({
  bytes: bytes2,
  cid,
  value: maybeValue,
  codec
}) => {
  const value = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes2);
  if (value === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new Block({
    cid,
    bytes: bytes2,
    value
  });
};
function cidToKey$1(c) {
  const cid = CID$3.asCID(c);
  if (cid == null) {
    throw errCode$1(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base32$3.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash(key) {
  return decode$j(base32$3.decode(`b${key.toString().toLowerCase().substring(1)}`));
}
const log$2 = debug$1("ipfs:repo:utils:walk-dag");
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes2 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({ bytes: bytes2, cid, codec });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err) {
    log$2("Could not walk DAG for CID", cid.toString(), err);
    throw err;
  }
}
const PinTypes = {
  direct: "direct",
  recursive: "recursive",
  indirect: "indirect",
  all: "all"
};
class QuickLRU extends Map {
  constructor(options = {}) {
    super();
    if (!(options.maxSize && options.maxSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    if (typeof options.maxAge === "number" && options.maxAge === 0) {
      throw new TypeError("`maxAge` must be a number greater than 0");
    }
    this.maxSize = options.maxSize;
    this.maxAge = options.maxAge || Number.POSITIVE_INFINITY;
    this.onEviction = options.onEviction;
    this.cache = /* @__PURE__ */ new Map();
    this.oldCache = /* @__PURE__ */ new Map();
    this._size = 0;
  }
  _emitEvictions(cache) {
    if (typeof this.onEviction !== "function") {
      return;
    }
    for (const [key, item] of cache) {
      this.onEviction(key, item.value);
    }
  }
  _deleteIfExpired(key, item) {
    if (typeof item.expiry === "number" && item.expiry <= Date.now()) {
      if (typeof this.onEviction === "function") {
        this.onEviction(key, item.value);
      }
      return this.delete(key);
    }
    return false;
  }
  _getOrDeleteIfExpired(key, item) {
    const deleted = this._deleteIfExpired(key, item);
    if (deleted === false) {
      return item.value;
    }
  }
  _getItemValue(key, item) {
    return item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;
  }
  _peek(key, cache) {
    const item = cache.get(key);
    return this._getItemValue(key, item);
  }
  _set(key, value) {
    this.cache.set(key, value);
    this._size++;
    if (this._size >= this.maxSize) {
      this._size = 0;
      this._emitEvictions(this.oldCache);
      this.oldCache = this.cache;
      this.cache = /* @__PURE__ */ new Map();
    }
  }
  _moveToRecent(key, item) {
    this.oldCache.delete(key);
    this._set(key, item);
  }
  *_entriesAscending() {
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield item;
        }
      }
    }
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield item;
      }
    }
  }
  get(key) {
    if (this.cache.has(key)) {
      const item = this.cache.get(key);
      return this._getItemValue(key, item);
    }
    if (this.oldCache.has(key)) {
      const item = this.oldCache.get(key);
      if (this._deleteIfExpired(key, item) === false) {
        this._moveToRecent(key, item);
        return item.value;
      }
    }
  }
  set(key, value, { maxAge = this.maxAge } = {}) {
    const expiry = typeof maxAge === "number" && maxAge !== Number.POSITIVE_INFINITY ? Date.now() + maxAge : void 0;
    if (this.cache.has(key)) {
      this.cache.set(key, {
        value,
        expiry
      });
    } else {
      this._set(key, { value, expiry });
    }
  }
  has(key) {
    if (this.cache.has(key)) {
      return !this._deleteIfExpired(key, this.cache.get(key));
    }
    if (this.oldCache.has(key)) {
      return !this._deleteIfExpired(key, this.oldCache.get(key));
    }
    return false;
  }
  peek(key) {
    if (this.cache.has(key)) {
      return this._peek(key, this.cache);
    }
    if (this.oldCache.has(key)) {
      return this._peek(key, this.oldCache);
    }
  }
  delete(key) {
    const deleted = this.cache.delete(key);
    if (deleted) {
      this._size--;
    }
    return this.oldCache.delete(key) || deleted;
  }
  clear() {
    this.cache.clear();
    this.oldCache.clear();
    this._size = 0;
  }
  resize(newSize) {
    if (!(newSize && newSize > 0)) {
      throw new TypeError("`maxSize` must be a number greater than 0");
    }
    const items = [...this._entriesAscending()];
    const removeCount = items.length - newSize;
    if (removeCount < 0) {
      this.cache = new Map(items);
      this.oldCache = /* @__PURE__ */ new Map();
      this._size = items.length;
    } else {
      if (removeCount > 0) {
        this._emitEvictions(items.slice(0, removeCount));
      }
      this.oldCache = new Map(items.slice(removeCount));
      this.cache = /* @__PURE__ */ new Map();
      this._size = 0;
    }
    this.maxSize = newSize;
  }
  *keys() {
    for (const [key] of this) {
      yield key;
    }
  }
  *values() {
    for (const [, value] of this) {
      yield value;
    }
  }
  *[Symbol.iterator]() {
    for (const item of this.cache) {
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    for (const item of this.oldCache) {
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesDescending() {
    let items = [...this.cache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value] = item;
      const deleted = this._deleteIfExpired(key, value);
      if (deleted === false) {
        yield [key, value.value];
      }
    }
    items = [...this.oldCache];
    for (let i2 = items.length - 1; i2 >= 0; --i2) {
      const item = items[i2];
      const [key, value] = item;
      if (!this.cache.has(key)) {
        const deleted = this._deleteIfExpired(key, value);
        if (deleted === false) {
          yield [key, value.value];
        }
      }
    }
  }
  *entriesAscending() {
    for (const [key, value] of this._entriesAscending()) {
      yield [key, value.value];
    }
  }
  get size() {
    if (!this._size) {
      return this.oldCache.size;
    }
    let oldCacheSize = 0;
    for (const key of this.oldCache.keys()) {
      if (!this.cache.has(key)) {
        oldCacheSize++;
      }
    }
    return Math.min(this._size + oldCacheSize, this.maxSize);
  }
  entries() {
    return this.entriesAscending();
  }
  forEach(callbackFunction, thisArgument = this) {
    for (const [key, value] of this.entriesAscending()) {
      callbackFunction.call(thisArgument, value, key, this);
    }
  }
  get [Symbol.toStringTag]() {
    return JSON.stringify([...this.entriesAscending()]);
  }
}
const CID_CACHE_MAX_SIZE = 2048;
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return errCode$1(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
class PinManager {
  constructor({ pinstore, blockstore, loadCodec }) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = debug$1("ipfs:repo:pin");
    this.directPins = /* @__PURE__ */ new Set();
    this.recursivePins = /* @__PURE__ */ new Set();
  }
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = {
      depth: 0
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code$8) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(cidToKey$1(cid), encode$B(pin));
  }
  unpin(cid, options) {
    return this.pinstore.delete(cidToKey$1(cid), options);
  }
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = {
      depth: Infinity
    };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== code$8) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(cidToKey$1(cid), encode$B(pin));
  }
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode$O(entry2.value);
        return pin.depth === 0;
      }]
    })) {
      const pin = decode$O(entry.value);
      const version2 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code$8;
      const multihash = keyToMultihash(entry.key);
      yield {
        cid: CID$3.create(version2, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
      filters: [(entry2) => {
        const pin = decode$O(entry2.value);
        return pin.depth === Infinity;
      }]
    })) {
      const pin = decode$O(entry.value);
      const version2 = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : code$8;
      const multihash = keyToMultihash(entry.key);
      yield {
        cid: CID$3.create(version2, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *indirectKeys(options) {
    for await (const { cid } of this.recursiveKeys()) {
      for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types = [
          PinTypes.recursive
        ];
        const result = await this.isPinnedWithType(childCid, types);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  async isPinnedWithType(cid, types, options) {
    if (!Array.isArray(types)) {
      types = [types];
    }
    const all2 = types.includes(PinTypes.all);
    const direct = types.includes(PinTypes.direct);
    const recursive = types.includes(PinTypes.recursive);
    const indirect = types.includes(PinTypes.indirect);
    if (recursive || direct || all2) {
      const result = await itFirst(this.pinstore.query({
        prefix: cidToKey$1(cid).toString(),
        filters: [(entry) => {
          if (all2) {
            return true;
          }
          const pin = decode$O(entry.value);
          return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
        }],
        limit: 1
      }));
      if (result) {
        const pin = decode$O(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self2 = this;
    async function* findChild(key, source) {
      for await (const { cid: parentCid } of source) {
        for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all2 || indirect) {
      const parentCid = await itFirst(findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: PinTypes.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  async fetchCompleteDag(cid, options = {}) {
    var _a2;
    const seen = new QuickLRU({ maxSize: (_a2 = options.cidCacheMaxSize) != null ? _a2 : CID_CACHE_MAX_SIZE });
    const walkDag2 = async (cid2, options2) => {
      if (seen.has(cid2.toString())) {
        return;
      }
      seen.set(cid2.toString(), true);
      const bytes2 = await this.blockstore.get(cid2, options2);
      const codec = await this.loadCodec(cid2.code);
      const block = createUnsafe({ bytes: bytes2, cid: cid2, codec });
      await Promise.all(
        [...block.links()].map(([, childCid]) => walkDag2(childCid, options2))
      );
    };
    await walkDag2(cid, options);
  }
  static checkPinType(type) {
    if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
}
const map$1 = async function* (source, func) {
  for await (const val of source) {
    yield func(val);
  }
};
var itMap = map$1;
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(itMap(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes.all);
  if (pinned) {
    throw errCode$1(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}
class TimeoutError extends Error {
  constructor(message) {
    super(message);
    this.name = "TimeoutError";
  }
}
class AbortError extends Error {
  constructor(message) {
    super();
    this.name = "AbortError";
    this.message = message;
  }
}
const getDOMException = (errorMessage) => globalThis.DOMException === void 0 ? new AbortError(errorMessage) : new DOMException(errorMessage);
const getAbortedReason = (signal) => {
  const reason = signal.reason === void 0 ? getDOMException("This operation was aborted.") : signal.reason;
  return reason instanceof Error ? reason : getDOMException(reason);
};
function pTimeout(promise2, options) {
  const {
    milliseconds,
    fallback,
    message,
    customTimers = { setTimeout, clearTimeout }
  } = options;
  let timer;
  const cancelablePromise = new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
      throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
    }
    if (milliseconds === Number.POSITIVE_INFINITY) {
      resolve(promise2);
      return;
    }
    if (options.signal) {
      const { signal } = options;
      if (signal.aborted) {
        reject(getAbortedReason(signal));
      }
      signal.addEventListener("abort", () => {
        reject(getAbortedReason(signal));
      });
    }
    timer = customTimers.setTimeout.call(void 0, () => {
      if (fallback) {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const errorMessage = typeof message === "string" ? message : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError2 = message instanceof Error ? message : new TimeoutError(errorMessage);
      if (typeof promise2.cancel === "function") {
        promise2.cancel();
      }
      reject(timeoutError2);
    }, milliseconds);
    (async () => {
      try {
        resolve(await promise2);
      } catch (error) {
        reject(error);
      } finally {
        customTimers.clearTimeout.call(void 0, timer);
      }
    })();
  });
  cancelablePromise.clear = () => {
    customTimers.clearTimeout.call(void 0, timer);
    timer = void 0;
  };
  return cancelablePromise;
}
let nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
  byte &= 63;
  if (byte < 36) {
    id += byte.toString(36);
  } else if (byte < 62) {
    id += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id += "-";
  } else {
    id += "_";
  }
  return id;
}, "");
const WORKER_REQUEST_READ_LOCK = "lock:worker:request-read";
const WORKER_RELEASE_READ_LOCK = "lock:worker:release-read";
const MASTER_GRANT_READ_LOCK = "lock:master:grant-read";
const WORKER_REQUEST_WRITE_LOCK = "lock:worker:request-write";
const WORKER_RELEASE_WRITE_LOCK = "lock:worker:release-write";
const MASTER_GRANT_WRITE_LOCK = "lock:master:grant-write";
const events = {};
const observable = (worker) => {
  worker.addEventListener("message", (event) => {
    observable.dispatchEvent("message", worker, event);
  });
  if (worker.port != null) {
    worker.port.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
  }
};
observable.addEventListener = (type, fn2) => {
  if (events[type] == null) {
    events[type] = [];
  }
  events[type].push(fn2);
};
observable.removeEventListener = (type, fn2) => {
  if (events[type] == null) {
    return;
  }
  events[type] = events[type].filter((listener) => listener === fn2);
};
observable.dispatchEvent = function(type, worker, event) {
  if (events[type] == null) {
    return;
  }
  events[type].forEach((fn2) => fn2(worker, event));
};
const handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
  return (worker, event) => {
    if (event.data.type !== requestType) {
      return;
    }
    const requestEvent = {
      type: event.data.type,
      name: event.data.name,
      identifier: event.data.identifier
    };
    emitter.dispatchEvent(new MessageEvent(masterEvent, {
      data: {
        name: requestEvent.name,
        handler: async () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return await new Promise((resolve) => {
            const releaseEventListener = (event2) => {
              if (event2 == null || event2.data == null) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        }
      }
    }));
  };
};
const makeWorkerLockRequest = (name2, requestType, grantType, releaseType) => {
  return async () => {
    const id = nanoid();
    globalThis.postMessage({
      type: requestType,
      identifier: id,
      name: name2
    });
    return await new Promise((resolve) => {
      const listener = (event) => {
        if (event == null || event.data == null) {
          return;
        }
        const responseEvent = {
          type: event.data.type,
          identifier: event.data.identifier
        };
        if (responseEvent.type === grantType && responseEvent.identifier === id) {
          globalThis.removeEventListener("message", listener);
          resolve(() => {
            globalThis.postMessage({
              type: releaseType,
              identifier: id,
              name: name2
            });
          });
        }
      };
      globalThis.addEventListener("message", listener);
    });
  };
};
const defaultOptions$2 = {
  singleProcess: false
};
const impl = (options) => {
  options = Object.assign({}, defaultOptions$2, options);
  const isPrimary = Boolean(globalThis.document) || options.singleProcess;
  if (isPrimary) {
    const emitter = new EventTarget();
    observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
    observable.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
    return emitter;
  }
  return {
    isWorker: true,
    readLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
    writeLock: (name2) => makeWorkerLockRequest(name2, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
  };
};
const mutexes = {};
let implementation;
async function createReleaseable(queue, options) {
  let res;
  const p2 = new Promise((resolve) => {
    res = resolve;
  });
  void queue.add(async () => await pTimeout((async () => {
    return await new Promise((resolve) => {
      res(() => {
        resolve();
      });
    });
  })(), {
    milliseconds: options.timeout
  }));
  return await p2;
}
const createMutex = (name2, options) => {
  if (implementation.isWorker === true) {
    return {
      readLock: implementation.readLock(name2, options),
      writeLock: implementation.writeLock(name2, options)
    };
  }
  const masterQueue = new PQueue({ concurrency: 1 });
  let readQueue;
  return {
    async readLock() {
      if (readQueue != null) {
        return await createReleaseable(readQueue, options);
      }
      readQueue = new PQueue({
        concurrency: options.concurrency,
        autoStart: false
      });
      const localReadQueue = readQueue;
      const readPromise = createReleaseable(readQueue, options);
      void masterQueue.add(async () => {
        localReadQueue.start();
        return await localReadQueue.onIdle().then(() => {
          if (readQueue === localReadQueue) {
            readQueue = null;
          }
        });
      });
      return await readPromise;
    },
    async writeLock() {
      readQueue = null;
      return await createReleaseable(masterQueue, options);
    }
  };
};
const defaultOptions$1 = {
  name: "lock",
  concurrency: Infinity,
  timeout: 846e5,
  singleProcess: false
};
function createMortice(options) {
  const opts = Object.assign({}, defaultOptions$1, options);
  if (implementation == null) {
    implementation = impl(opts);
    if (implementation.isWorker !== true) {
      implementation.addEventListener("requestReadLock", (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].readLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
      implementation.addEventListener("requestWriteLock", async (event) => {
        if (mutexes[event.data.name] == null) {
          return;
        }
        void mutexes[event.data.name].writeLock().then(async (release) => await event.data.handler().finally(() => release()));
      });
    }
  }
  if (mutexes[opts.name] == null) {
    mutexes[opts.name] = createMutex(opts.name, opts);
  }
  return mutexes[opts.name];
}
async function* batch$1(source, size = 1) {
  let things = [];
  if (size < 1) {
    size = 1;
  }
  for await (const thing of source) {
    things.push(thing);
    while (things.length >= size) {
      yield things.slice(0, size);
      things = things.slice(size);
    }
  }
  while (things.length) {
    yield things.slice(0, size);
    things = things.slice(size);
  }
}
var itBatch = batch$1;
const batch = itBatch;
async function* parallelBatch(source, size = 1) {
  for await (const tasks of batch(source, size)) {
    const things = tasks.map(
      (p2) => {
        return p2().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
      }
    );
    for (let i2 = 0; i2 < things.length; i2++) {
      const result = await things[i2];
      if (result.ok) {
        yield result.value;
      } else {
        throw result.err;
      }
    }
  }
}
var itParallelBatch = parallelBatch;
var fixedSize = class FixedFIFO2 {
  constructor(hwm) {
    if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
      throw new Error("Max size for a FixedFIFO should be a power of two");
    this.buffer = new Array(hwm);
    this.mask = hwm - 1;
    this.top = 0;
    this.btm = 0;
    this.next = null;
  }
  push(data) {
    if (this.buffer[this.top] !== void 0)
      return false;
    this.buffer[this.top] = data;
    this.top = this.top + 1 & this.mask;
    return true;
  }
  shift() {
    const last = this.buffer[this.btm];
    if (last === void 0)
      return void 0;
    this.buffer[this.btm] = void 0;
    this.btm = this.btm + 1 & this.mask;
    return last;
  }
  peek() {
    return this.buffer[this.btm];
  }
  isEmpty() {
    return this.buffer[this.btm] === void 0;
  }
};
const FixedFIFO = fixedSize;
var fastFifo = class FastFIFO {
  constructor(hwm) {
    this.hwm = hwm || 16;
    this.head = new FixedFIFO(this.hwm);
    this.tail = this.head;
  }
  push(val) {
    if (!this.head.push(val)) {
      const prev = this.head;
      this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
      this.head.push(val);
    }
  }
  shift() {
    const val = this.tail.shift();
    if (val === void 0 && this.tail.next) {
      const next = this.tail.next;
      this.tail.next = null;
      this.tail = next;
      return this.tail.shift();
    }
    return val;
  }
  peek() {
    return this.tail.peek();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
};
const FIFO = fastFifo;
var itPushable = (options) => {
  options = options || {};
  let onEnd;
  if (typeof options === "function") {
    onEnd = options;
    options = {};
  } else {
    onEnd = options.onEnd;
  }
  let buffer2 = new FIFO();
  let pushable2, onNext, ended;
  const waitNext = () => {
    if (!buffer2.isEmpty()) {
      if (options.writev) {
        let next2;
        const values = [];
        while (!buffer2.isEmpty()) {
          next2 = buffer2.shift();
          if (next2.error)
            throw next2.error;
          values.push(next2.value);
        }
        return { done: next2.done, value: values };
      }
      const next = buffer2.shift();
      if (next.error)
        throw next.error;
      return next;
    }
    if (ended)
      return { done: true };
    return new Promise((resolve, reject) => {
      onNext = (next) => {
        onNext = null;
        if (next.error) {
          reject(next.error);
        } else {
          if (options.writev && !next.done) {
            resolve({ done: next.done, value: [next.value] });
          } else {
            resolve(next);
          }
        }
        return pushable2;
      };
    });
  };
  const bufferNext = (next) => {
    if (onNext)
      return onNext(next);
    buffer2.push(next);
    return pushable2;
  };
  const bufferError = (err) => {
    buffer2 = new FIFO();
    if (onNext)
      return onNext({ error: err });
    buffer2.push({ error: err });
    return pushable2;
  };
  const push2 = (value) => {
    if (ended)
      return pushable2;
    return bufferNext({ done: false, value });
  };
  const end2 = (err) => {
    if (ended)
      return pushable2;
    ended = true;
    return err ? bufferError(err) : bufferNext({ done: true });
  };
  const _return = () => {
    buffer2 = new FIFO();
    end2();
    return { done: true };
  };
  const _throw = (err) => {
    end2(err);
    return { done: true };
  };
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next: waitNext,
    return: _return,
    throw: _throw,
    push: push2,
    end: end2
  };
  if (!onEnd)
    return pushable2;
  const _pushable2 = pushable2;
  pushable2 = {
    [Symbol.asyncIterator]() {
      return this;
    },
    next() {
      return _pushable2.next();
    },
    throw(err) {
      _pushable2.throw(err);
      if (onEnd) {
        onEnd(err);
        onEnd = null;
      }
      return { done: true };
    },
    return() {
      _pushable2.return();
      if (onEnd) {
        onEnd();
        onEnd = null;
      }
      return { done: true };
    },
    push: push2,
    end(err) {
      _pushable2.end(err);
      if (onEnd) {
        onEnd(err);
        onEnd = null;
      }
      return pushable2;
    }
  };
  return pushable2;
};
const pushable = itPushable;
const merge = async function* (...sources) {
  const output = pushable();
  setTimeout(async () => {
    try {
      await Promise.all(
        sources.map(async (source) => {
          for await (const item of source) {
            output.push(item);
          }
        })
      );
      output.end();
    } catch (err) {
      output.end(err);
    }
  }, 0);
  yield* output;
};
var itMerge = merge;
const rawPipe = (...fns) => {
  let res;
  while (fns.length > 0) {
    res = fns.shift()(res);
  }
  return res;
};
const isIterable = (obj) => {
  return obj != null && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
};
const isDuplex = (obj) => {
  return obj != null && typeof obj.sink === "function" && isIterable(obj.source);
};
const duplexPipelineFn = (duplex) => {
  return (source) => {
    const p2 = duplex.sink(source);
    if (p2.then != null) {
      const stream = pushable$1({
        objectMode: true
      });
      p2.then(() => {
        stream.end();
      }, (err) => {
        stream.end(err);
      });
      const sourceWrap = async function* () {
        yield* duplex.source;
        stream.end();
      };
      return itMerge(stream, sourceWrap());
    }
    return duplex.source;
  };
};
function pipe(first2, ...rest) {
  if (isDuplex(first2)) {
    const duplex = first2;
    first2 = () => duplex.source;
  } else if (isIterable(first2)) {
    const source = first2;
    first2 = () => source;
  }
  const fns = [first2, ...rest];
  if (fns.length > 1) {
    if (isDuplex(fns[fns.length - 1])) {
      fns[fns.length - 1] = fns[fns.length - 1].sink;
    }
  }
  if (fns.length > 2) {
    for (let i2 = 1; i2 < fns.length - 1; i2++) {
      if (isDuplex(fns[i2])) {
        fns[i2] = duplexPipelineFn(fns[i2]);
      }
    }
  }
  return rawPipe(...fns);
}
const log$1 = debug$1("ipfs:repo:gc");
const ERR_NOT_FOUND = notFoundError$1().code;
const BLOCK_RM_CONCURRENCY = 256;
const MFS_ROOT_KEY = new Key("/local/filesroot");
function gc$1({ gcLock, pins, blockstore, root, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log$1("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({ pins, blockstore, root, loadCodec });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log$1(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root }) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root.get(MFS_ROOT_KEY);
    } catch (err) {
      if (err.code === ERR_NOT_FOUND) {
        log$1("No blocks in MFS");
        return;
      }
      throw err;
    }
    const rootCid = CID$3.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = itMerge(
    itMap(pins.recursiveKeys(), ({ cid }) => cid),
    pins.indirectKeys(),
    itMap(pins.directKeys(), ({ cid }) => cid),
    mfsSource
  );
  const output = /* @__PURE__ */ new Set();
  for await (const cid of itMerge(pinsSource, mfsSource)) {
    output.add(base32$3.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base32$3.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err) {
          return {
            err: new Error(`Could not delete block with CID ${cid}: ${err.message}`)
          };
        }
        return { cid };
      } catch (err) {
        const msg = `Could delete block with CID ${cid}`;
        log$1(msg, err);
        return { err: new Error(msg + `: ${err.message}`) };
      }
    };
  };
  yield* pipe(
    itParallelBatch(itMap(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY),
    (source) => itFilter(source, Boolean)
  );
  log$1(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}
const log = debug$1("ipfs:repo");
const noLimit = Number.MAX_SAFE_INTEGER;
const AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
class Repo {
  constructor(path, loadCodec, backends, options) {
    if (typeof path !== "string") {
      throw new Error("missing repo path");
    }
    if (typeof loadCodec !== "function") {
      throw new Error("missing codec loader");
    }
    this.options = mergeOptions(defaultOptions$3, options);
    this.closed = true;
    this.path = path;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new PinManager({ pinstore, blockstore, loadCodec });
    const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
    this.blocks = createIdStore(pinnedBlockstore);
    this.version = version$3(this.root);
    this.config = config(this.root);
    this.spec = spec(this.root);
    this.apiAddr = apiAddr(this.root);
    this.gcLock = createMortice({
      name: path,
      singleProcess: this.options.repoOwner !== false
    });
    this.gc = gc$1({ gcLock: this.gcLock, pins: this.pins, blockstore: this.blocks, root: this.root, loadCodec });
  }
  async init(config2) {
    log("initializing at: %s", this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config2));
    await this.spec.set(buildDatastoreSpec(config2));
    await this.version.set(repoVersion);
  }
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err) {
      return false;
    }
  }
  async open() {
    if (!this.closed) {
      throw errCode$1(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
    }
    log("opening at: %s", this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log("acquired repo.lock");
      const isCompatible = await this.version.check(repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
        }
      }
      log("creating datastore");
      await this.datastore.open();
      log("creating blocks");
      await this.blocks.open();
      log("creating keystore");
      await this.keys.open();
      log("creating pins");
      await this.pins.pinstore.open();
      this.closed = false;
      log("all opened");
    } catch (err) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err2) {
          log("error removing lock", err2);
        }
      }
      throw err;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err) {
      if (err.message !== "Already open") {
        throw err;
      }
    }
  }
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== "function") {
      throw errCode$1(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
    }
    return lockfile;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    log("init check");
    let config2;
    try {
      [config2] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err) {
      if (err.code === "ERR_NOT_FOUND") {
        throw errCode$1(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
      throw err;
    }
    if (!config2) {
      throw errCode$1(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
        path: this.path
      });
    }
  }
  async close() {
    if (this.closed) {
      throw errCode$1(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
    }
    log("closing at: %s", this.path);
    try {
      await this.apiAddr.delete();
    } catch (err) {
      if (err.code !== ERR_REPO_NOT_INITIALIZED && !err.message.startsWith("ENOENT")) {
        throw err;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map((store) => store && store.close()));
    log("unlocking");
    this.closed = true;
    await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version2, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version2,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw errCode$1(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, {
      path: this.path
    });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== void 0) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log(`reverting to version ${toVersion}`);
      return revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log(`migrating to version ${toVersion}`);
      return migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  async _storageMaxStat() {
    try {
      const max = await this.config.get("Datastore.StorageMax");
      return BigInt(bytes$1.exports(max));
    } catch (err) {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const { key, value } of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return { count, size };
  }
}
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo$1(path, loadCodec, backends, options) {
  return new Repo(path, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, defaultDatastore, objectSafeGet(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...defaultDatastore.Spec,
    ...objectSafeGet(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}
const SHARDING_FN = "SHARDING";
const README_FN = "_README";
const all$1 = async (source) => {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
};
var itAll = all$1;
const sortAll$1 = (iterable, sorter) => {
  return async function* () {
    const values = await itAll(iterable);
    yield* values.sort(sorter);
  }();
};
const take$1 = async function* (source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
};
var itTake = take$1;
class BaseDatastore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await itDrain(this.putMany(puts, options));
        puts = [];
        await itDrain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = itFilter(
        it,
        (e) => e.key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll$1(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = itFilter(
        it,
        (key) => key.toString().startsWith(q.prefix)
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll$1(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
}
class MemoryDatastore extends BaseDatastore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(key, val) {
    this.data[key.toString()] = val;
  }
  async get(key) {
    const exists = await this.has(key);
    if (!exists)
      throw notFoundError$1();
    return this.data[key.toString()];
  }
  async has(key) {
    return this.data[key.toString()] !== void 0;
  }
  async delete(key) {
    delete this.data[key.toString()];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value]) => ({ key: new Key(key), value }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => new Key(key));
  }
}
new Key(SHARDING_FN);
new Key(README_FN);
debug$1.formatters.b = (v) => {
  return v == null ? "undefined" : base58btc$9.baseEncode(v);
};
debug$1.formatters.t = (v) => {
  return v == null ? "undefined" : base32$d.baseEncode(v);
};
debug$1.formatters.m = (v) => {
  return v == null ? "undefined" : base64$9.baseEncode(v);
};
debug$1.formatters.p = (v) => {
  return v == null ? "undefined" : v.toString();
};
debug$1.formatters.c = (v) => {
  return v == null ? "undefined" : v.toString();
};
debug$1.formatters.k = (v) => {
  return v == null ? "undefined" : v.toString();
};
function logger(name2) {
  return Object.assign(debug$1(name2), {
    error: debug$1(`${name2}:error`),
    trace: debug$1(`${name2}:trace`)
  });
}
logger("datastore:core:tiered");
async function* filter(source, fn2) {
  for await (const entry of source) {
    if (await fn2(entry)) {
      yield entry;
    }
  }
}
async function* map(source, func) {
  for await (const val of source) {
    yield func(val);
  }
}
async function* take(source, limit) {
  let items = 0;
  if (limit < 1) {
    return;
  }
  for await (const entry of source) {
    yield entry;
    items++;
    if (items === limit) {
      return;
    }
  }
}
async function all(source) {
  const arr = [];
  for await (const entry of source) {
    arr.push(entry);
  }
  return arr;
}
async function* sort(source, sorter) {
  const arr = await all(source);
  yield* arr.sort(sorter);
}
var browserLevel = {};
var abstractLevel$1 = {};
var abstractLevel = {};
var levelSupports = {};
levelSupports.supports = function supports2(...manifests) {
  const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
  return Object.assign(manifest, {
    snapshots: manifest.snapshots || false,
    permanence: manifest.permanence || false,
    seek: manifest.seek || false,
    clear: manifest.clear || false,
    getMany: manifest.getMany || false,
    keyIterator: manifest.keyIterator || false,
    valueIterator: manifest.valueIterator || false,
    iteratorNextv: manifest.iteratorNextv || false,
    iteratorAll: manifest.iteratorAll || false,
    status: manifest.status || false,
    createIfMissing: manifest.createIfMissing || false,
    errorIfExists: manifest.errorIfExists || false,
    deferredOpen: manifest.deferredOpen || false,
    promises: manifest.promises || false,
    streams: manifest.streams || false,
    encodings: Object.assign({}, manifest.encodings),
    events: Object.assign({}, manifest.events),
    additionalMethods: Object.assign({}, manifest.additionalMethods)
  });
};
var levelTranscoder = {};
var moduleError = class ModuleError2 extends Error {
  constructor(message, options) {
    super(message || "");
    if (typeof options === "object" && options !== null) {
      if (options.code)
        this.code = String(options.code);
      if (options.expected)
        this.expected = true;
      if (options.transient)
        this.transient = true;
      if (options.cause)
        this.cause = options.cause;
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var encodings$1 = {};
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup$1 = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code$5.length; i < len; ++i) {
  lookup$1[i] = code$5[i];
  revLookup[code$5.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len2 = b64.length;
  if (len2 % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len2;
  var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len2; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup$1[num >> 18 & 63] + lookup$1[num >> 12 & 63] + lookup$1[num >> 6 & 63] + lookup$1[num & 63];
}
function encodeChunk(uint8, start, end2) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end2; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len2 = uint8.length;
  var extraBytes = len2 % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len2 - 1];
    parts.push(
      lookup$1[tmp >> 2] + lookup$1[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
    parts.push(
      lookup$1[tmp >> 10] + lookup$1[tmp >> 4 & 63] + lookup$1[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset + i2];
  i2 += d2;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer2[offset + i2], i2 += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m & 255, i2 += d2, m /= 256, mLen -= 8) {
  }
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e & 255, i2 += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d2] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base642 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf2 = new Uint8Array(length2);
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function Buffer2(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe2(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer2.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString2(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length2);
    }
    const b2 = fromObject(value);
    if (b2)
      return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer2.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc3(size, fill, encoding2) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding2 === "string" ? createBuffer(size).fill(fill, encoding2) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding2) {
    return alloc3(size, fill, encoding2);
  };
  function allocUnsafe2(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe2(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe2(size);
  };
  function fromString2(string2, encoding2) {
    if (typeof encoding2 !== "string" || encoding2 === "") {
      encoding2 = "utf8";
    }
    if (!Buffer2.isEncoding(encoding2)) {
      throw new TypeError("Unknown encoding: " + encoding2);
    }
    const length2 = byteLength2(string2, encoding2) | 0;
    let buf2 = createBuffer(length2);
    const actual = buf2.write(string2, encoding2);
    if (actual !== length2) {
      buf2 = buf2.slice(0, actual);
    }
    return buf2;
  }
  function fromArrayLike(array) {
    const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf2 = createBuffer(length2);
    for (let i2 = 0; i2 < length2; i2 += 1) {
      buf2[i2] = array[i2] & 255;
    }
    return buf2;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf2;
    if (byteOffset === void 0 && length2 === void 0) {
      buf2 = new Uint8Array(array);
    } else if (length2 === void 0) {
      buf2 = new Uint8Array(array, byteOffset);
    } else {
      buf2 = new Uint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf2, Buffer2.prototype);
    return buf2;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      const len2 = checked(obj.length) | 0;
      const buf2 = createBuffer(len2);
      if (buf2.length === 0) {
        return buf2;
      }
      obj.copy(buf2, 0, 0, len2);
      return buf2;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer2.alloc(+length2);
  }
  Buffer2.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer2.prototype;
  };
  Buffer2.compare = function compare2(a2, b2) {
    if (isInstance(a2, Uint8Array))
      a2 = Buffer2.from(a2, a2.offset, a2.byteLength);
    if (isInstance(b2, Uint8Array))
      b2 = Buffer2.from(b2, b2.offset, b2.byteLength);
    if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a2 === b2)
      return 0;
    let x2 = a2.length;
    let y = b2.length;
    for (let i2 = 0, len2 = Math.min(x2, y); i2 < len2; ++i2) {
      if (a2[i2] !== b2[i2]) {
        x2 = a2[i2];
        y = b2[i2];
        break;
      }
    }
    if (x2 < y)
      return -1;
    if (y < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding2) {
    switch (String(encoding2).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    let i2;
    if (length2 === void 0) {
      length2 = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length2 += list[i2].length;
      }
    }
    const buffer2 = Buffer2.allocUnsafe(length2);
    let pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      let buf2 = list[i2];
      if (isInstance(buf2, Uint8Array)) {
        if (pos + buf2.length > buffer2.length) {
          if (!Buffer2.isBuffer(buf2))
            buf2 = Buffer2.from(buf2);
          buf2.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(
            buffer2,
            buf2,
            pos
          );
        }
      } else if (!Buffer2.isBuffer(buf2)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf2.copy(buffer2, pos);
      }
      pos += buf2.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding2) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
      );
    }
    const len2 = string2.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len2 === 0)
      return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "ascii":
        case "latin1":
        case "binary":
          return len2;
        case "utf8":
        case "utf-8":
          return utf8ToBytes2(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len2 * 2;
        case "hex":
          return len2 >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes2(string2).length;
          }
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding2, start, end2) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start >>>= 0;
    if (end2 <= start) {
      return "";
    }
    if (!encoding2)
      encoding2 = "utf8";
    while (true) {
      switch (encoding2) {
        case "hex":
          return hexSlice(this, start, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice2(this, start, end2);
        case "ascii":
          return asciiSlice(this, start, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end2);
        case "base64":
          return base64Slice(this, start, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = (encoding2 + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b2, n, m) {
    const i2 = b2[n];
    b2[n] = b2[m];
    b2[m] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    const len2 = this.length;
    if (len2 % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    const len2 = this.length;
    if (len2 % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    const len2 = this.length;
    if (len2 % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i2 = 0; i2 < len2; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice2(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b2) {
    if (!Buffer2.isBuffer(b2))
      throw new TypeError("Argument must be a Buffer");
    if (this === b2)
      return true;
    return Buffer2.compare(this, b2) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare2(target, start, end2, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end2) {
      return 1;
    }
    start >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    let x2 = thisEnd - thisStart;
    let y = end2 - start;
    const len2 = Math.min(x2, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end2);
    for (let i2 = 0; i2 < len2; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y = targetCopy[i2];
        break;
      }
    }
    if (x2 < y)
      return -1;
    if (y < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding2, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding2 = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding2);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding2, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding2, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding2, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding2 !== void 0) {
      encoding2 = String(encoding2).toLowerCase();
      if (encoding2 === "ucs2" || encoding2 === "ucs-2" || encoding2 === "utf16le" || encoding2 === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf2, i3) {
      if (indexSize === 1) {
        return buf2[i3];
      } else {
        return buf2.readUInt16BE(i3 * indexSize);
      }
    }
    let i2;
    if (dir) {
      let foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        let found = true;
        for (let j = 0; j < valLength; j++) {
          if (read2(arr, i2 + j) !== read2(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding2) {
    return this.indexOf(val, byteOffset, encoding2) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding2) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding2, false);
  };
  function hexWrite(buf2, string2, offset, length2) {
    offset = Number(offset) || 0;
    const remaining = buf2.length - offset;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string2.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      const parsed = parseInt(string2.substr(i2 * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i2;
      buf2[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf2, string2, offset, length2) {
    return blitBuffer(utf8ToBytes2(string2, buf2.length - offset), buf2, offset, length2);
  }
  function asciiWrite(buf2, string2, offset, length2) {
    return blitBuffer(asciiToBytes(string2), buf2, offset, length2);
  }
  function base64Write(buf2, string2, offset, length2) {
    return blitBuffer(base64ToBytes(string2), buf2, offset, length2);
  }
  function ucs2Write(buf2, string2, offset, length2) {
    return blitBuffer(utf16leToBytes(string2, buf2.length - offset), buf2, offset, length2);
  }
  Buffer2.prototype.write = function write(string2, offset, length2, encoding2) {
    if (offset === void 0) {
      encoding2 = "utf8";
      length2 = this.length;
      offset = 0;
    } else if (length2 === void 0 && typeof offset === "string") {
      encoding2 = offset;
      length2 = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding2 === void 0)
          encoding2 = "utf8";
      } else {
        encoding2 = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length2 === void 0 || length2 > remaining)
      length2 = remaining;
    if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding2)
      encoding2 = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding2) {
        case "hex":
          return hexWrite(this, string2, offset, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length2);
        case "base64":
          return base64Write(this, string2, offset, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding2);
          encoding2 = ("" + encoding2).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf2, start, end2) {
    if (start === 0 && end2 === buf2.length) {
      return base642.fromByteArray(buf2);
    } else {
      return base642.fromByteArray(buf2.slice(start, end2));
    }
  }
  function utf8Slice2(buf2, start, end2) {
    end2 = Math.min(buf2.length, end2);
    const res = [];
    let i2 = start;
    while (i2 < end2) {
      const firstByte = buf2[i2];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf2[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf2[i2 + 1];
            thirdByte = buf2[i2 + 2];
            fourthByte = buf2[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray2(res);
  }
  const MAX_ARGUMENTS_LENGTH2 = 4096;
  function decodeCodePointsArray2(codePoints) {
    const len2 = codePoints.length;
    if (len2 <= MAX_ARGUMENTS_LENGTH2) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i2 = 0;
    while (i2 < len2) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH2)
      );
    }
    return res;
  }
  function asciiSlice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf2, start, end2) {
    let ret = "";
    end2 = Math.min(buf2.length, end2);
    for (let i2 = start; i2 < end2; ++i2) {
      ret += String.fromCharCode(buf2[i2]);
    }
    return ret;
  }
  function hexSlice(buf2, start, end2) {
    const len2 = buf2.length;
    if (!start || start < 0)
      start = 0;
    if (!end2 || end2 < 0 || end2 > len2)
      end2 = len2;
    let out = "";
    for (let i2 = start; i2 < end2; ++i2) {
      out += hexSliceLookupTable[buf2[i2]];
    }
    return out;
  }
  function utf16leSlice(buf2, start, end2) {
    const bytes2 = buf2.slice(start, end2);
    let res = "";
    for (let i2 = 0; i2 < bytes2.length - 1; i2 += 2) {
      res += String.fromCharCode(bytes2[i2] + bytes2[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice2(start, end2) {
    const len2 = this.length;
    start = ~~start;
    end2 = end2 === void 0 ? len2 : ~~end2;
    if (start < 0) {
      start += len2;
      if (start < 0)
        start = 0;
    } else if (start > len2) {
      start = len2;
    }
    if (end2 < 0) {
      end2 += len2;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len2) {
      end2 = len2;
    }
    if (end2 < start)
      end2 = start;
    const newBuf = this.subarray(start, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length2) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo2 = first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi2 = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo2) + (BigInt(hi2) << BigInt(32));
  });
  Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi2 = first2 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo2 = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi2) << BigInt(32)) + BigInt(lo2);
  });
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    let i2 = byteLength3;
    let mul = 1;
    let val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first2 = this[offset];
    const last = this[offset + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first2 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf2, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf2, value, offset, min, max) {
    checkIntBI(value, min, max, buf2, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf2[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf2[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf2[offset++] = lo2;
    lo2 = lo2 >> 8;
    buf2[offset++] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset++] = hi2;
    return offset;
  }
  function wrtBigUInt64BE(buf2, value, offset, min, max) {
    checkIntBI(value, min, max, buf2, offset, 7);
    let lo2 = Number(value & BigInt(4294967295));
    buf2[offset + 7] = lo2;
    lo2 = lo2 >> 8;
    buf2[offset + 6] = lo2;
    lo2 = lo2 >> 8;
    buf2[offset + 5] = lo2;
    lo2 = lo2 >> 8;
    buf2[offset + 4] = lo2;
    let hi2 = Number(value >> BigInt(32) & BigInt(4294967295));
    buf2[offset + 3] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 2] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset + 1] = hi2;
    hi2 = hi2 >> 8;
    buf2[offset] = hi2;
    return offset + 8;
  }
  Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i2 = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf2, value, offset, ext, max, min) {
    if (offset + ext > buf2.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 4);
    }
    ieee754$1.write(buf2, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf2, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf2, value, offset, 8);
    }
    ieee754$1.write(buf2, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end2) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start)
      end2 = start;
    if (end2 === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target.length - targetStart < end2 - start) {
      end2 = target.length - targetStart + start;
    }
    const len2 = end2 - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end2);
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, end2),
        targetStart
      );
    }
    return len2;
  };
  Buffer2.prototype.fill = function fill(val, start, end2, encoding2) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding2 = start;
        start = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding2 = end2;
        end2 = this.length;
      }
      if (encoding2 !== void 0 && typeof encoding2 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding2 === "string" && !Buffer2.isEncoding(encoding2)) {
        throw new TypeError("Unknown encoding: " + encoding2);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding2 === "utf8" && code2 < 128 || encoding2 === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start) {
      return this;
    }
    start = start >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    let i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end2; ++i2) {
        this[i2] = val;
      }
    } else {
      const bytes2 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding2);
      const len2 = bytes2.length;
      if (len2 === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i2 = 0; i2 < end2 - start; ++i2) {
        this[i2 + start] = bytes2[i2 % len2];
      }
    }
    return this;
  };
  const errors2 = {};
  function E(sym, getMessage, Base) {
    errors2[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name2) {
      if (name2) {
        return `${name2} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E(
    "ERR_INVALID_ARG_TYPE",
    function(name2, actual) {
      return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E(
    "ERR_OUT_OF_RANGE",
    function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i2 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i2 >= start + 4; i2 -= 3) {
      res = `_${val.slice(i2 - 3, i2)}${res}`;
    }
    return `${val.slice(0, i2)}${res}`;
  }
  function checkBounds(buf2, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf2[offset] === void 0 || buf2[offset + byteLength3] === void 0) {
      boundsError(offset, buf2.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min, max, buf2, offset, byteLength3) {
    if (value > max || value < min) {
      const n = typeof min === "bigint" ? "n" : "";
      let range;
      if (byteLength3 > 3) {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      } else {
        range = `>= ${min}${n} and <= ${max}${n}`;
      }
      throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf2, offset, byteLength3);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors2.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length2, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors2.ERR_OUT_OF_RANGE(
      type || "offset",
      `>= ${type ? 1 : 0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes2(string2, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string2.length;
    let leadSurrogate = null;
    const bytes2 = [];
    for (let i2 = 0; i2 < length2; ++i2) {
      codePoint = string2.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length2) {
            if ((units -= 3) > -1)
              bytes2.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes2.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes2.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes2.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes2.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes2.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes2.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes2;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi2, lo2;
    const byteArray = [];
    for (let i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i2);
      hi2 = c >> 8;
      lo2 = c % 256;
      byteArray.push(lo2);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base642.toByteArray(base64clean(str));
  }
  function blitBuffer(src2, dst, offset, length2) {
    let i2;
    for (i2 = 0; i2 < length2; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src2.length)
        break;
      dst[i2 + offset] = src2[i2];
    }
    return i2;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet2 = "0123456789abcdef";
    const table2 = new Array(256);
    for (let i2 = 0; i2 < 16; ++i2) {
      const i16 = i2 * 16;
      for (let j = 0; j < 16; ++j) {
        table2[i16 + j] = alphabet2[i2] + alphabet2[j];
      }
    }
    return table2;
  }();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
let lazy = null;
var textEndec$1 = function() {
  if (lazy === null) {
    lazy = {
      textEncoder: new TextEncoder(),
      textDecoder: new TextDecoder()
    };
  }
  return lazy;
};
var formats$2 = {};
var encoding = {};
const ModuleError$8 = moduleError;
const formats$1 = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Encoding$2 {
  constructor(options) {
    this.encode = options.encode || this.encode;
    this.decode = options.decode || this.decode;
    this.name = options.name || this.name;
    this.format = options.format || this.format;
    if (typeof this.encode !== "function") {
      throw new TypeError("The 'encode' property must be a function");
    }
    if (typeof this.decode !== "function") {
      throw new TypeError("The 'decode' property must be a function");
    }
    this.encode = this.encode.bind(this);
    this.decode = this.decode.bind(this);
    if (typeof this.name !== "string" || this.name === "") {
      throw new TypeError("The 'name' property must be a string");
    }
    if (typeof this.format !== "string" || !formats$1.has(this.format)) {
      throw new TypeError("The 'format' property must be one of 'buffer', 'view', 'utf8'");
    }
    if (options.createViewTranscoder) {
      this.createViewTranscoder = options.createViewTranscoder;
    }
    if (options.createBufferTranscoder) {
      this.createBufferTranscoder = options.createBufferTranscoder;
    }
    if (options.createUTF8Transcoder) {
      this.createUTF8Transcoder = options.createUTF8Transcoder;
    }
  }
  get commonName() {
    return this.name.split("+")[0];
  }
  createBufferTranscoder() {
    throw new ModuleError$8(`Encoding '${this.name}' cannot be transcoded to 'buffer'`, {
      code: "LEVEL_ENCODING_NOT_SUPPORTED"
    });
  }
  createViewTranscoder() {
    throw new ModuleError$8(`Encoding '${this.name}' cannot be transcoded to 'view'`, {
      code: "LEVEL_ENCODING_NOT_SUPPORTED"
    });
  }
  createUTF8Transcoder() {
    throw new ModuleError$8(`Encoding '${this.name}' cannot be transcoded to 'utf8'`, {
      code: "LEVEL_ENCODING_NOT_SUPPORTED"
    });
  }
}
encoding.Encoding = Encoding$2;
const { Buffer: Buffer$1 } = buffer || {};
const { Encoding: Encoding$1 } = encoding;
const textEndec = textEndec$1;
class BufferFormat$2 extends Encoding$1 {
  constructor(options) {
    super({ ...options, format: "buffer" });
  }
  createViewTranscoder() {
    return new ViewFormat$2({
      encode: this.encode,
      decode: (data) => this.decode(
        Buffer$1.from(data.buffer, data.byteOffset, data.byteLength)
      ),
      name: `${this.name}+view`
    });
  }
  createBufferTranscoder() {
    return this;
  }
}
class ViewFormat$2 extends Encoding$1 {
  constructor(options) {
    super({ ...options, format: "view" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({
      encode: (data) => {
        const view = this.encode(data);
        return Buffer$1.from(view.buffer, view.byteOffset, view.byteLength);
      },
      decode: this.decode,
      name: `${this.name}+buffer`
    });
  }
  createViewTranscoder() {
    return this;
  }
}
class UTF8Format$2 extends Encoding$1 {
  constructor(options) {
    super({ ...options, format: "utf8" });
  }
  createBufferTranscoder() {
    return new BufferFormat$2({
      encode: (data) => Buffer$1.from(this.encode(data), "utf8"),
      decode: (data) => this.decode(data.toString("utf8")),
      name: `${this.name}+buffer`
    });
  }
  createViewTranscoder() {
    const { textEncoder: textEncoder2, textDecoder: textDecoder2 } = textEndec();
    return new ViewFormat$2({
      encode: (data) => textEncoder2.encode(this.encode(data)),
      decode: (data) => this.decode(textDecoder2.decode(data)),
      name: `${this.name}+view`
    });
  }
  createUTF8Transcoder() {
    return this;
  }
}
formats$2.BufferFormat = BufferFormat$2;
formats$2.ViewFormat = ViewFormat$2;
formats$2.UTF8Format = UTF8Format$2;
const { Buffer } = buffer || { Buffer: { isBuffer: () => false } };
const { textEncoder: textEncoder$2, textDecoder: textDecoder$1 } = textEndec$1();
const { BufferFormat: BufferFormat$1, ViewFormat: ViewFormat$1, UTF8Format: UTF8Format$1 } = formats$2;
const identity$3 = (v) => v;
encodings$1.utf8 = new UTF8Format$1({
  encode: function(data) {
    return Buffer.isBuffer(data) ? data.toString("utf8") : ArrayBuffer.isView(data) ? textDecoder$1.decode(data) : String(data);
  },
  decode: identity$3,
  name: "utf8",
  createViewTranscoder() {
    return new ViewFormat$1({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : textEncoder$2.encode(data);
      },
      decode: function(data) {
        return textDecoder$1.decode(data);
      },
      name: `${this.name}+view`
    });
  },
  createBufferTranscoder() {
    return new BufferFormat$1({
      encode: function(data) {
        return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), "utf8");
      },
      decode: function(data) {
        return data.toString("utf8");
      },
      name: `${this.name}+buffer`
    });
  }
});
encodings$1.json = new UTF8Format$1({
  encode: JSON.stringify,
  decode: JSON.parse,
  name: "json"
});
encodings$1.buffer = new BufferFormat$1({
  encode: function(data) {
    return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), "utf8");
  },
  decode: identity$3,
  name: "buffer",
  createViewTranscoder() {
    return new ViewFormat$1({
      encode: function(data) {
        return ArrayBuffer.isView(data) ? data : Buffer.from(String(data), "utf8");
      },
      decode: function(data) {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      },
      name: `${this.name}+view`
    });
  }
});
encodings$1.view = new ViewFormat$1({
  encode: function(data) {
    return ArrayBuffer.isView(data) ? data : textEncoder$2.encode(data);
  },
  decode: identity$3,
  name: "view",
  createBufferTranscoder() {
    return new BufferFormat$1({
      encode: function(data) {
        return Buffer.isBuffer(data) ? data : ArrayBuffer.isView(data) ? Buffer.from(data.buffer, data.byteOffset, data.byteLength) : Buffer.from(String(data), "utf8");
      },
      decode: identity$3,
      name: `${this.name}+buffer`
    });
  }
});
encodings$1.hex = new BufferFormat$1({
  encode: function(data) {
    return Buffer.isBuffer(data) ? data : Buffer.from(String(data), "hex");
  },
  decode: function(buffer2) {
    return buffer2.toString("hex");
  },
  name: "hex"
});
encodings$1.base64 = new BufferFormat$1({
  encode: function(data) {
    return Buffer.isBuffer(data) ? data : Buffer.from(String(data), "base64");
  },
  decode: function(buffer2) {
    return buffer2.toString("base64");
  },
  name: "base64"
});
const ModuleError$7 = moduleError;
const encodings = encodings$1;
const { Encoding } = encoding;
const { BufferFormat, ViewFormat, UTF8Format } = formats$2;
const kFormats = Symbol("formats");
const kEncodings = Symbol("encodings");
const validFormats = /* @__PURE__ */ new Set(["buffer", "view", "utf8"]);
class Transcoder$1 {
  constructor(formats2) {
    if (!Array.isArray(formats2)) {
      throw new TypeError("The first argument 'formats' must be an array");
    } else if (!formats2.every((f) => validFormats.has(f))) {
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    }
    this[kEncodings] = /* @__PURE__ */ new Map();
    this[kFormats] = new Set(formats2);
    for (const k in encodings) {
      try {
        this.encoding(k);
      } catch (err) {
        if (err.code !== "LEVEL_ENCODING_NOT_SUPPORTED")
          throw err;
      }
    }
  }
  encodings() {
    return Array.from(new Set(this[kEncodings].values()));
  }
  encoding(encoding2) {
    let resolved = this[kEncodings].get(encoding2);
    if (resolved === void 0) {
      if (typeof encoding2 === "string" && encoding2 !== "") {
        resolved = lookup[encoding2];
        if (!resolved) {
          throw new ModuleError$7(`Encoding '${encoding2}' is not found`, {
            code: "LEVEL_ENCODING_NOT_FOUND"
          });
        }
      } else if (typeof encoding2 !== "object" || encoding2 === null) {
        throw new TypeError("First argument 'encoding' must be a string or object");
      } else {
        resolved = from$3(encoding2);
      }
      const { name: name2, format: format2 } = resolved;
      if (!this[kFormats].has(format2)) {
        if (this[kFormats].has("view")) {
          resolved = resolved.createViewTranscoder();
        } else if (this[kFormats].has("buffer")) {
          resolved = resolved.createBufferTranscoder();
        } else if (this[kFormats].has("utf8")) {
          resolved = resolved.createUTF8Transcoder();
        } else {
          throw new ModuleError$7(`Encoding '${name2}' cannot be transcoded`, {
            code: "LEVEL_ENCODING_NOT_SUPPORTED"
          });
        }
      }
      for (const k of [encoding2, name2, resolved.name, resolved.commonName]) {
        this[kEncodings].set(k, resolved);
      }
    }
    return resolved;
  }
}
levelTranscoder.Transcoder = Transcoder$1;
function from$3(options) {
  if (options instanceof Encoding) {
    return options;
  }
  const maybeType = "type" in options && typeof options.type === "string" ? options.type : void 0;
  const name2 = options.name || maybeType || `anonymous-${anonymousCount++}`;
  switch (detectFormat(options)) {
    case "view":
      return new ViewFormat({ ...options, name: name2 });
    case "utf8":
      return new UTF8Format({ ...options, name: name2 });
    case "buffer":
      return new BufferFormat({ ...options, name: name2 });
    default: {
      throw new TypeError("Format must be one of 'buffer', 'view', 'utf8'");
    }
  }
}
function detectFormat(options) {
  if ("format" in options && options.format !== void 0) {
    return options.format;
  } else if ("buffer" in options && typeof options.buffer === "boolean") {
    return options.buffer ? "buffer" : "utf8";
  } else if ("code" in options && Number.isInteger(options.code)) {
    return "view";
  } else {
    return "buffer";
  }
}
const aliases = {
  binary: encodings.buffer,
  "utf-8": encodings.utf8
};
const lookup = {
  ...encodings,
  ...aliases
};
let anonymousCount = 0;
var catering = {};
var nextTickBrowser$1 = typeof queueMicrotask === "function" ? queueMicrotask : (fn2) => Promise.resolve().then(fn2);
var nextTick = nextTickBrowser$1;
catering.fromCallback = function(callback, symbol2) {
  if (callback === void 0) {
    var promise2 = new Promise(function(resolve, reject) {
      callback = function(err, res) {
        if (err)
          reject(err);
        else
          resolve(res);
      };
    });
    callback[symbol2 !== void 0 ? symbol2 : "promise"] = promise2;
  } else if (typeof callback !== "function") {
    throw new TypeError("Callback must be a function");
  }
  return callback;
};
catering.fromPromise = function(promise2, callback) {
  if (callback === void 0)
    return promise2;
  promise2.then(function(res) {
    nextTick(() => callback(null, res));
  }).catch(function(err) {
    nextTick(() => callback(err));
  });
};
var abstractIterator = {};
var common = {};
common.getCallback = function(options, callback) {
  return typeof options === "function" ? options : callback;
};
common.getOptions = function(options, def) {
  if (typeof options === "object" && options !== null) {
    return options;
  }
  if (def !== void 0) {
    return def;
  }
  return {};
};
const { fromCallback: fromCallback$3 } = catering;
const ModuleError$6 = moduleError;
const { getOptions: getOptions$2, getCallback: getCallback$2 } = common;
const kPromise$3 = Symbol("promise");
const kCallback$1 = Symbol("callback");
const kWorking = Symbol("working");
const kHandleOne$1 = Symbol("handleOne");
const kHandleMany$1 = Symbol("handleMany");
const kAutoClose = Symbol("autoClose");
const kFinishWork = Symbol("finishWork");
const kReturnMany = Symbol("returnMany");
const kClosing = Symbol("closing");
const kHandleClose = Symbol("handleClose");
const kClosed = Symbol("closed");
const kCloseCallbacks$1 = Symbol("closeCallbacks");
const kKeyEncoding$1 = Symbol("keyEncoding");
const kValueEncoding$1 = Symbol("valueEncoding");
const kAbortOnClose = Symbol("abortOnClose");
const kLegacy = Symbol("legacy");
const kKeys = Symbol("keys");
const kValues = Symbol("values");
const kLimit = Symbol("limit");
const kCount = Symbol("count");
const emptyOptions$1 = Object.freeze({});
const noop$1 = () => {
};
let warnedEnd = false;
class CommonIterator {
  constructor(db, options, legacy) {
    if (typeof db !== "object" || db === null) {
      const hint = db === null ? "null" : typeof db;
      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
    }
    if (typeof options !== "object" || options === null) {
      throw new TypeError("The second argument must be an options object");
    }
    this[kClosed] = false;
    this[kCloseCallbacks$1] = [];
    this[kWorking] = false;
    this[kClosing] = false;
    this[kAutoClose] = false;
    this[kCallback$1] = null;
    this[kHandleOne$1] = this[kHandleOne$1].bind(this);
    this[kHandleMany$1] = this[kHandleMany$1].bind(this);
    this[kHandleClose] = this[kHandleClose].bind(this);
    this[kKeyEncoding$1] = options[kKeyEncoding$1];
    this[kValueEncoding$1] = options[kValueEncoding$1];
    this[kLegacy] = legacy;
    this[kLimit] = Number.isInteger(options.limit) && options.limit >= 0 ? options.limit : Infinity;
    this[kCount] = 0;
    this[kAbortOnClose] = !!options.abortOnClose;
    this.db = db;
    this.db.attachResource(this);
    this.nextTick = db.nextTick;
  }
  get count() {
    return this[kCount];
  }
  get limit() {
    return this[kLimit];
  }
  next(callback) {
    let promise2;
    if (callback === void 0) {
      promise2 = new Promise((resolve, reject) => {
        callback = (err, key, value) => {
          if (err)
            reject(err);
          else if (!this[kLegacy])
            resolve(key);
          else if (key === void 0 && value === void 0)
            resolve();
          else
            resolve([key, value]);
        };
      });
    } else if (typeof callback !== "function") {
      throw new TypeError("Callback must be a function");
    }
    if (this[kClosing]) {
      this.nextTick(callback, new ModuleError$6("Iterator is not open: cannot call next() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    } else if (this[kWorking]) {
      this.nextTick(callback, new ModuleError$6("Iterator is busy: cannot call next() until previous call has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      }));
    } else {
      this[kWorking] = true;
      this[kCallback$1] = callback;
      if (this[kCount] >= this[kLimit])
        this.nextTick(this[kHandleOne$1], null);
      else
        this._next(this[kHandleOne$1]);
    }
    return promise2;
  }
  _next(callback) {
    this.nextTick(callback);
  }
  nextv(size, options, callback) {
    callback = getCallback$2(options, callback);
    callback = fromCallback$3(callback, kPromise$3);
    options = getOptions$2(options, emptyOptions$1);
    if (!Number.isInteger(size)) {
      this.nextTick(callback, new TypeError("The first argument 'size' must be an integer"));
      return callback[kPromise$3];
    }
    if (this[kClosing]) {
      this.nextTick(callback, new ModuleError$6("Iterator is not open: cannot call nextv() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    } else if (this[kWorking]) {
      this.nextTick(callback, new ModuleError$6("Iterator is busy: cannot call nextv() until previous call has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      }));
    } else {
      if (size < 1)
        size = 1;
      if (this[kLimit] < Infinity)
        size = Math.min(size, this[kLimit] - this[kCount]);
      this[kWorking] = true;
      this[kCallback$1] = callback;
      if (size <= 0)
        this.nextTick(this[kHandleMany$1], null, []);
      else
        this._nextv(size, options, this[kHandleMany$1]);
    }
    return callback[kPromise$3];
  }
  _nextv(size, options, callback) {
    const acc = [];
    const onnext = (err, key, value) => {
      if (err) {
        return callback(err);
      } else if (this[kLegacy] ? key === void 0 && value === void 0 : key === void 0) {
        return callback(null, acc);
      }
      acc.push(this[kLegacy] ? [key, value] : key);
      if (acc.length === size) {
        callback(null, acc);
      } else {
        this._next(onnext);
      }
    };
    this._next(onnext);
  }
  all(options, callback) {
    callback = getCallback$2(options, callback);
    callback = fromCallback$3(callback, kPromise$3);
    options = getOptions$2(options, emptyOptions$1);
    if (this[kClosing]) {
      this.nextTick(callback, new ModuleError$6("Iterator is not open: cannot call all() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    } else if (this[kWorking]) {
      this.nextTick(callback, new ModuleError$6("Iterator is busy: cannot call all() until previous call has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      }));
    } else {
      this[kWorking] = true;
      this[kCallback$1] = callback;
      this[kAutoClose] = true;
      if (this[kCount] >= this[kLimit])
        this.nextTick(this[kHandleMany$1], null, []);
      else
        this._all(options, this[kHandleMany$1]);
    }
    return callback[kPromise$3];
  }
  _all(options, callback) {
    let count = this[kCount];
    const acc = [];
    const nextv = () => {
      const size = this[kLimit] < Infinity ? Math.min(1e3, this[kLimit] - count) : 1e3;
      if (size <= 0) {
        this.nextTick(callback, null, acc);
      } else {
        this._nextv(size, emptyOptions$1, onnextv);
      }
    };
    const onnextv = (err, items) => {
      if (err) {
        callback(err);
      } else if (items.length === 0) {
        callback(null, acc);
      } else {
        acc.push.apply(acc, items);
        count += items.length;
        nextv();
      }
    };
    nextv();
  }
  [kFinishWork]() {
    const cb = this[kCallback$1];
    if (this[kAbortOnClose] && cb === null)
      return noop$1;
    this[kWorking] = false;
    this[kCallback$1] = null;
    if (this[kClosing])
      this._close(this[kHandleClose]);
    return cb;
  }
  [kReturnMany](cb, err, items) {
    if (this[kAutoClose]) {
      this.close(cb.bind(null, err, items));
    } else {
      cb(err, items);
    }
  }
  seek(target, options) {
    options = getOptions$2(options, emptyOptions$1);
    if (this[kClosing])
      ;
    else if (this[kWorking]) {
      throw new ModuleError$6("Iterator is busy: cannot call seek() until next() has completed", {
        code: "LEVEL_ITERATOR_BUSY"
      });
    } else {
      const keyEncoding = this.db.keyEncoding(options.keyEncoding || this[kKeyEncoding$1]);
      const keyFormat = keyEncoding.format;
      if (options.keyEncoding !== keyFormat) {
        options = { ...options, keyEncoding: keyFormat };
      }
      const mapped = this.db.prefixKey(keyEncoding.encode(target), keyFormat);
      this._seek(mapped, options);
    }
  }
  _seek(target, options) {
    throw new ModuleError$6("Iterator does not support seek()", {
      code: "LEVEL_NOT_SUPPORTED"
    });
  }
  close(callback) {
    callback = fromCallback$3(callback, kPromise$3);
    if (this[kClosed]) {
      this.nextTick(callback);
    } else if (this[kClosing]) {
      this[kCloseCallbacks$1].push(callback);
    } else {
      this[kClosing] = true;
      this[kCloseCallbacks$1].push(callback);
      if (!this[kWorking]) {
        this._close(this[kHandleClose]);
      } else if (this[kAbortOnClose]) {
        const cb = this[kFinishWork]();
        cb(new ModuleError$6("Aborted on iterator close()", {
          code: "LEVEL_ITERATOR_NOT_OPEN"
        }));
      }
    }
    return callback[kPromise$3];
  }
  _close(callback) {
    this.nextTick(callback);
  }
  [kHandleClose]() {
    this[kClosed] = true;
    this.db.detachResource(this);
    const callbacks = this[kCloseCallbacks$1];
    this[kCloseCallbacks$1] = [];
    for (const cb of callbacks) {
      cb();
    }
  }
  async *[Symbol.asyncIterator]() {
    try {
      let item;
      while ((item = await this.next()) !== void 0) {
        yield item;
      }
    } finally {
      if (!this[kClosed])
        await this.close();
    }
  }
}
class AbstractIterator$3 extends CommonIterator {
  constructor(db, options) {
    super(db, options, true);
    this[kKeys] = options.keys !== false;
    this[kValues] = options.values !== false;
  }
  [kHandleOne$1](err, key, value) {
    const cb = this[kFinishWork]();
    if (err)
      return cb(err);
    try {
      key = this[kKeys] && key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
      value = this[kValues] && value !== void 0 ? this[kValueEncoding$1].decode(value) : void 0;
    } catch (err2) {
      return cb(new IteratorDecodeError("entry", err2));
    }
    if (!(key === void 0 && value === void 0)) {
      this[kCount]++;
    }
    cb(null, key, value);
  }
  [kHandleMany$1](err, entries) {
    const cb = this[kFinishWork]();
    if (err)
      return this[kReturnMany](cb, err);
    try {
      for (const entry of entries) {
        const key = entry[0];
        const value = entry[1];
        entry[0] = this[kKeys] && key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
        entry[1] = this[kValues] && value !== void 0 ? this[kValueEncoding$1].decode(value) : void 0;
      }
    } catch (err2) {
      return this[kReturnMany](cb, new IteratorDecodeError("entries", err2));
    }
    this[kCount] += entries.length;
    this[kReturnMany](cb, null, entries);
  }
  end(callback) {
    if (!warnedEnd && typeof console !== "undefined") {
      warnedEnd = true;
      console.warn(new ModuleError$6(
        "The iterator.end() method was renamed to close() and end() is an alias that will be removed in a future version",
        { code: "LEVEL_LEGACY" }
      ));
    }
    return this.close(callback);
  }
}
class AbstractKeyIterator$2 extends CommonIterator {
  constructor(db, options) {
    super(db, options, false);
  }
  [kHandleOne$1](err, key) {
    const cb = this[kFinishWork]();
    if (err)
      return cb(err);
    try {
      key = key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
    } catch (err2) {
      return cb(new IteratorDecodeError("key", err2));
    }
    if (key !== void 0)
      this[kCount]++;
    cb(null, key);
  }
  [kHandleMany$1](err, keys) {
    const cb = this[kFinishWork]();
    if (err)
      return this[kReturnMany](cb, err);
    try {
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        keys[i2] = key !== void 0 ? this[kKeyEncoding$1].decode(key) : void 0;
      }
    } catch (err2) {
      return this[kReturnMany](cb, new IteratorDecodeError("keys", err2));
    }
    this[kCount] += keys.length;
    this[kReturnMany](cb, null, keys);
  }
}
class AbstractValueIterator$2 extends CommonIterator {
  constructor(db, options) {
    super(db, options, false);
  }
  [kHandleOne$1](err, value) {
    const cb = this[kFinishWork]();
    if (err)
      return cb(err);
    try {
      value = value !== void 0 ? this[kValueEncoding$1].decode(value) : void 0;
    } catch (err2) {
      return cb(new IteratorDecodeError("value", err2));
    }
    if (value !== void 0)
      this[kCount]++;
    cb(null, value);
  }
  [kHandleMany$1](err, values) {
    const cb = this[kFinishWork]();
    if (err)
      return this[kReturnMany](cb, err);
    try {
      for (let i2 = 0; i2 < values.length; i2++) {
        const value = values[i2];
        values[i2] = value !== void 0 ? this[kValueEncoding$1].decode(value) : void 0;
      }
    } catch (err2) {
      return this[kReturnMany](cb, new IteratorDecodeError("values", err2));
    }
    this[kCount] += values.length;
    this[kReturnMany](cb, null, values);
  }
}
class IteratorDecodeError extends ModuleError$6 {
  constructor(subject, cause) {
    super(`Iterator could not decode ${subject}`, {
      code: "LEVEL_DECODE_ERROR",
      cause
    });
  }
}
for (const k of ["_ended property", "_nexting property", "_end method"]) {
  Object.defineProperty(AbstractIterator$3.prototype, k.split(" ")[0], {
    get() {
      throw new ModuleError$6(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
    },
    set() {
      throw new ModuleError$6(`The ${k} has been removed`, { code: "LEVEL_LEGACY" });
    }
  });
}
AbstractIterator$3.keyEncoding = kKeyEncoding$1;
AbstractIterator$3.valueEncoding = kValueEncoding$1;
abstractIterator.AbstractIterator = AbstractIterator$3;
abstractIterator.AbstractKeyIterator = AbstractKeyIterator$2;
abstractIterator.AbstractValueIterator = AbstractValueIterator$2;
var defaultKvIterator = {};
const { AbstractKeyIterator: AbstractKeyIterator$1, AbstractValueIterator: AbstractValueIterator$1 } = abstractIterator;
const kIterator = Symbol("iterator");
const kCallback = Symbol("callback");
const kHandleOne = Symbol("handleOne");
const kHandleMany = Symbol("handleMany");
class DefaultKeyIterator$1 extends AbstractKeyIterator$1 {
  constructor(db, options) {
    super(db, options);
    this[kIterator] = db.iterator({ ...options, keys: true, values: false });
    this[kHandleOne] = this[kHandleOne].bind(this);
    this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
class DefaultValueIterator$1 extends AbstractValueIterator$1 {
  constructor(db, options) {
    super(db, options);
    this[kIterator] = db.iterator({ ...options, keys: false, values: true });
    this[kHandleOne] = this[kHandleOne].bind(this);
    this[kHandleMany] = this[kHandleMany].bind(this);
  }
}
for (const Iterator2 of [DefaultKeyIterator$1, DefaultValueIterator$1]) {
  const keys = Iterator2 === DefaultKeyIterator$1;
  const mapEntry = keys ? (entry) => entry[0] : (entry) => entry[1];
  Iterator2.prototype._next = function(callback) {
    this[kCallback] = callback;
    this[kIterator].next(this[kHandleOne]);
  };
  Iterator2.prototype[kHandleOne] = function(err, key, value) {
    const callback = this[kCallback];
    if (err)
      callback(err);
    else
      callback(null, keys ? key : value);
  };
  Iterator2.prototype._nextv = function(size, options, callback) {
    this[kCallback] = callback;
    this[kIterator].nextv(size, options, this[kHandleMany]);
  };
  Iterator2.prototype._all = function(options, callback) {
    this[kCallback] = callback;
    this[kIterator].all(options, this[kHandleMany]);
  };
  Iterator2.prototype[kHandleMany] = function(err, entries) {
    const callback = this[kCallback];
    if (err)
      callback(err);
    else
      callback(null, entries.map(mapEntry));
  };
  Iterator2.prototype._seek = function(target, options) {
    this[kIterator].seek(target, options);
  };
  Iterator2.prototype._close = function(callback) {
    this[kIterator].close(callback);
  };
}
defaultKvIterator.DefaultKeyIterator = DefaultKeyIterator$1;
defaultKvIterator.DefaultValueIterator = DefaultValueIterator$1;
var deferredIterator = {};
const { AbstractIterator: AbstractIterator$2, AbstractKeyIterator, AbstractValueIterator } = abstractIterator;
const ModuleError$5 = moduleError;
const kNut = Symbol("nut");
const kUndefer$1 = Symbol("undefer");
const kFactory = Symbol("factory");
class DeferredIterator$1 extends AbstractIterator$2 {
  constructor(db, options) {
    super(db, options);
    this[kNut] = null;
    this[kFactory] = () => db.iterator(options);
    this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredKeyIterator$1 extends AbstractKeyIterator {
  constructor(db, options) {
    super(db, options);
    this[kNut] = null;
    this[kFactory] = () => db.keys(options);
    this.db.defer(() => this[kUndefer$1]());
  }
}
class DeferredValueIterator$1 extends AbstractValueIterator {
  constructor(db, options) {
    super(db, options);
    this[kNut] = null;
    this[kFactory] = () => db.values(options);
    this.db.defer(() => this[kUndefer$1]());
  }
}
for (const Iterator2 of [DeferredIterator$1, DeferredKeyIterator$1, DeferredValueIterator$1]) {
  Iterator2.prototype[kUndefer$1] = function() {
    if (this.db.status === "open") {
      this[kNut] = this[kFactory]();
    }
  };
  Iterator2.prototype._next = function(callback) {
    if (this[kNut] !== null) {
      this[kNut].next(callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._next(callback));
    } else {
      this.nextTick(callback, new ModuleError$5("Iterator is not open: cannot call next() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    }
  };
  Iterator2.prototype._nextv = function(size, options, callback) {
    if (this[kNut] !== null) {
      this[kNut].nextv(size, options, callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._nextv(size, options, callback));
    } else {
      this.nextTick(callback, new ModuleError$5("Iterator is not open: cannot call nextv() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    }
  };
  Iterator2.prototype._all = function(options, callback) {
    if (this[kNut] !== null) {
      this[kNut].all(callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._all(options, callback));
    } else {
      this.nextTick(callback, new ModuleError$5("Iterator is not open: cannot call all() after close()", {
        code: "LEVEL_ITERATOR_NOT_OPEN"
      }));
    }
  };
  Iterator2.prototype._seek = function(target, options) {
    if (this[kNut] !== null) {
      this[kNut]._seek(target, options);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._seek(target, options));
    }
  };
  Iterator2.prototype._close = function(callback) {
    if (this[kNut] !== null) {
      this[kNut].close(callback);
    } else if (this.db.status === "opening") {
      this.db.defer(() => this._close(callback));
    } else {
      this.nextTick(callback);
    }
  };
}
deferredIterator.DeferredIterator = DeferredIterator$1;
deferredIterator.DeferredKeyIterator = DeferredKeyIterator$1;
deferredIterator.DeferredValueIterator = DeferredValueIterator$1;
var defaultChainedBatch = {};
var abstractChainedBatch = {};
const { fromCallback: fromCallback$2 } = catering;
const ModuleError$4 = moduleError;
const { getCallback: getCallback$1, getOptions: getOptions$1 } = common;
const kPromise$2 = Symbol("promise");
const kStatus$1 = Symbol("status");
const kOperations$1 = Symbol("operations");
const kFinishClose = Symbol("finishClose");
const kCloseCallbacks = Symbol("closeCallbacks");
class AbstractChainedBatch$1 {
  constructor(db) {
    if (typeof db !== "object" || db === null) {
      const hint = db === null ? "null" : typeof db;
      throw new TypeError(`The first argument must be an abstract-level database, received ${hint}`);
    }
    this[kOperations$1] = [];
    this[kCloseCallbacks] = [];
    this[kStatus$1] = "open";
    this[kFinishClose] = this[kFinishClose].bind(this);
    this.db = db;
    this.db.attachResource(this);
    this.nextTick = db.nextTick;
  }
  get length() {
    return this[kOperations$1].length;
  }
  put(key, value, options) {
    if (this[kStatus$1] !== "open") {
      throw new ModuleError$4("Batch is not open: cannot call put() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      });
    }
    const err = this.db._checkKey(key) || this.db._checkValue(value);
    if (err)
      throw err;
    const db = options && options.sublevel != null ? options.sublevel : this.db;
    const original = options;
    const keyEncoding = db.keyEncoding(options && options.keyEncoding);
    const valueEncoding = db.valueEncoding(options && options.valueEncoding);
    const keyFormat = keyEncoding.format;
    options = { ...options, keyEncoding: keyFormat, valueEncoding: valueEncoding.format };
    if (db !== this.db) {
      options.sublevel = null;
    }
    const mappedKey = db.prefixKey(keyEncoding.encode(key), keyFormat);
    const mappedValue = valueEncoding.encode(value);
    this._put(mappedKey, mappedValue, options);
    this[kOperations$1].push({ ...original, type: "put", key, value });
    return this;
  }
  _put(key, value, options) {
  }
  del(key, options) {
    if (this[kStatus$1] !== "open") {
      throw new ModuleError$4("Batch is not open: cannot call del() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      });
    }
    const err = this.db._checkKey(key);
    if (err)
      throw err;
    const db = options && options.sublevel != null ? options.sublevel : this.db;
    const original = options;
    const keyEncoding = db.keyEncoding(options && options.keyEncoding);
    const keyFormat = keyEncoding.format;
    options = { ...options, keyEncoding: keyFormat };
    if (db !== this.db) {
      options.sublevel = null;
    }
    this._del(db.prefixKey(keyEncoding.encode(key), keyFormat), options);
    this[kOperations$1].push({ ...original, type: "del", key });
    return this;
  }
  _del(key, options) {
  }
  clear() {
    if (this[kStatus$1] !== "open") {
      throw new ModuleError$4("Batch is not open: cannot call clear() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      });
    }
    this._clear();
    this[kOperations$1] = [];
    return this;
  }
  _clear() {
  }
  write(options, callback) {
    callback = getCallback$1(options, callback);
    callback = fromCallback$2(callback, kPromise$2);
    options = getOptions$1(options);
    if (this[kStatus$1] !== "open") {
      this.nextTick(callback, new ModuleError$4("Batch is not open: cannot call write() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      }));
    } else if (this.length === 0) {
      this.close(callback);
    } else {
      this[kStatus$1] = "writing";
      this._write(options, (err) => {
        this[kStatus$1] = "closing";
        this[kCloseCallbacks].push(() => callback(err));
        if (!err)
          this.db.emit("batch", this[kOperations$1]);
        this._close(this[kFinishClose]);
      });
    }
    return callback[kPromise$2];
  }
  _write(options, callback) {
  }
  close(callback) {
    callback = fromCallback$2(callback, kPromise$2);
    if (this[kStatus$1] === "closing") {
      this[kCloseCallbacks].push(callback);
    } else if (this[kStatus$1] === "closed") {
      this.nextTick(callback);
    } else {
      this[kCloseCallbacks].push(callback);
      if (this[kStatus$1] !== "writing") {
        this[kStatus$1] = "closing";
        this._close(this[kFinishClose]);
      }
    }
    return callback[kPromise$2];
  }
  _close(callback) {
    this.nextTick(callback);
  }
  [kFinishClose]() {
    this[kStatus$1] = "closed";
    this.db.detachResource(this);
    const callbacks = this[kCloseCallbacks];
    this[kCloseCallbacks] = [];
    for (const cb of callbacks) {
      cb();
    }
  }
}
abstractChainedBatch.AbstractChainedBatch = AbstractChainedBatch$1;
const { AbstractChainedBatch } = abstractChainedBatch;
const ModuleError$3 = moduleError;
const kEncoded = Symbol("encoded");
class DefaultChainedBatch$1 extends AbstractChainedBatch {
  constructor(db) {
    super(db);
    this[kEncoded] = [];
  }
  _put(key, value, options) {
    this[kEncoded].push({ ...options, type: "put", key, value });
  }
  _del(key, options) {
    this[kEncoded].push({ ...options, type: "del", key });
  }
  _clear() {
    this[kEncoded] = [];
  }
  _write(options, callback) {
    if (this.db.status === "opening") {
      this.db.defer(() => this._write(options, callback));
    } else if (this.db.status === "open") {
      if (this[kEncoded].length === 0)
        this.nextTick(callback);
      else
        this.db._batch(this[kEncoded], options, callback);
    } else {
      this.nextTick(callback, new ModuleError$3("Batch is not open: cannot call write() after write() or close()", {
        code: "LEVEL_BATCH_NOT_OPEN"
      }));
    }
  }
}
defaultChainedBatch.DefaultChainedBatch = DefaultChainedBatch$1;
const ModuleError$2 = moduleError;
const hasOwnProperty = Object.prototype.hasOwnProperty;
const rangeOptions$1 = /* @__PURE__ */ new Set(["lt", "lte", "gt", "gte"]);
var rangeOptions_1 = function(options, keyEncoding) {
  const result = {};
  for (const k in options) {
    if (!hasOwnProperty.call(options, k))
      continue;
    if (k === "keyEncoding" || k === "valueEncoding")
      continue;
    if (k === "start" || k === "end") {
      throw new ModuleError$2(`The legacy range option '${k}' has been removed`, {
        code: "LEVEL_LEGACY"
      });
    } else if (k === "encoding") {
      throw new ModuleError$2("The levelup-style 'encoding' alias has been removed, use 'valueEncoding' instead", {
        code: "LEVEL_LEGACY"
      });
    }
    if (rangeOptions$1.has(k)) {
      result[k] = keyEncoding.encode(options[k]);
    } else {
      result[k] = options[k];
    }
  }
  result.reverse = !!result.reverse;
  result.limit = Number.isInteger(result.limit) && result.limit >= 0 ? result.limit : -1;
  return result;
};
var nextTickBrowser;
var hasRequiredNextTickBrowser;
function requireNextTickBrowser() {
  if (hasRequiredNextTickBrowser)
    return nextTickBrowser;
  hasRequiredNextTickBrowser = 1;
  const queueMicrotask2 = queueMicrotask_1;
  nextTickBrowser = function(fn2, ...args) {
    if (args.length === 0) {
      queueMicrotask2(fn2);
    } else {
      queueMicrotask2(() => fn2(...args));
    }
  };
  return nextTickBrowser;
}
var abstractSublevelIterator = {};
var hasRequiredAbstractSublevelIterator;
function requireAbstractSublevelIterator() {
  if (hasRequiredAbstractSublevelIterator)
    return abstractSublevelIterator;
  hasRequiredAbstractSublevelIterator = 1;
  const { AbstractIterator: AbstractIterator2, AbstractKeyIterator: AbstractKeyIterator2, AbstractValueIterator: AbstractValueIterator2 } = abstractIterator;
  const kUnfix = Symbol("unfix");
  const kIterator2 = Symbol("iterator");
  const kHandleOne2 = Symbol("handleOne");
  const kHandleMany2 = Symbol("handleMany");
  const kCallback2 = Symbol("callback");
  class AbstractSublevelIterator extends AbstractIterator2 {
    constructor(db, options, iterator2, unfix) {
      super(db, options);
      this[kIterator2] = iterator2;
      this[kUnfix] = unfix;
      this[kHandleOne2] = this[kHandleOne2].bind(this);
      this[kHandleMany2] = this[kHandleMany2].bind(this);
      this[kCallback2] = null;
    }
    [kHandleOne2](err, key, value) {
      const callback = this[kCallback2];
      if (err)
        return callback(err);
      if (key !== void 0)
        key = this[kUnfix](key);
      callback(err, key, value);
    }
    [kHandleMany2](err, entries) {
      const callback = this[kCallback2];
      if (err)
        return callback(err);
      for (const entry of entries) {
        const key = entry[0];
        if (key !== void 0)
          entry[0] = this[kUnfix](key);
      }
      callback(err, entries);
    }
  }
  class AbstractSublevelKeyIterator extends AbstractKeyIterator2 {
    constructor(db, options, iterator2, unfix) {
      super(db, options);
      this[kIterator2] = iterator2;
      this[kUnfix] = unfix;
      this[kHandleOne2] = this[kHandleOne2].bind(this);
      this[kHandleMany2] = this[kHandleMany2].bind(this);
      this[kCallback2] = null;
    }
    [kHandleOne2](err, key) {
      const callback = this[kCallback2];
      if (err)
        return callback(err);
      if (key !== void 0)
        key = this[kUnfix](key);
      callback(err, key);
    }
    [kHandleMany2](err, keys) {
      const callback = this[kCallback2];
      if (err)
        return callback(err);
      for (let i2 = 0; i2 < keys.length; i2++) {
        const key = keys[i2];
        if (key !== void 0)
          keys[i2] = this[kUnfix](key);
      }
      callback(err, keys);
    }
  }
  class AbstractSublevelValueIterator extends AbstractValueIterator2 {
    constructor(db, options, iterator2) {
      super(db, options);
      this[kIterator2] = iterator2;
    }
  }
  for (const Iterator2 of [AbstractSublevelIterator, AbstractSublevelKeyIterator]) {
    Iterator2.prototype._next = function(callback) {
      this[kCallback2] = callback;
      this[kIterator2].next(this[kHandleOne2]);
    };
    Iterator2.prototype._nextv = function(size, options, callback) {
      this[kCallback2] = callback;
      this[kIterator2].nextv(size, options, this[kHandleMany2]);
    };
    Iterator2.prototype._all = function(options, callback) {
      this[kCallback2] = callback;
      this[kIterator2].all(options, this[kHandleMany2]);
    };
  }
  for (const Iterator2 of [AbstractSublevelValueIterator]) {
    Iterator2.prototype._next = function(callback) {
      this[kIterator2].next(callback);
    };
    Iterator2.prototype._nextv = function(size, options, callback) {
      this[kIterator2].nextv(size, options, callback);
    };
    Iterator2.prototype._all = function(options, callback) {
      this[kIterator2].all(options, callback);
    };
  }
  for (const Iterator2 of [AbstractSublevelIterator, AbstractSublevelKeyIterator, AbstractSublevelValueIterator]) {
    Iterator2.prototype._seek = function(target, options) {
      this[kIterator2].seek(target, options);
    };
    Iterator2.prototype._close = function(callback) {
      this[kIterator2].close(callback);
    };
  }
  abstractSublevelIterator.AbstractSublevelIterator = AbstractSublevelIterator;
  abstractSublevelIterator.AbstractSublevelKeyIterator = AbstractSublevelKeyIterator;
  abstractSublevelIterator.AbstractSublevelValueIterator = AbstractSublevelValueIterator;
  return abstractSublevelIterator;
}
var abstractSublevel;
var hasRequiredAbstractSublevel;
function requireAbstractSublevel() {
  if (hasRequiredAbstractSublevel)
    return abstractSublevel;
  hasRequiredAbstractSublevel = 1;
  const ModuleError3 = moduleError;
  const { Buffer: Buffer2 } = buffer || {};
  const {
    AbstractSublevelIterator,
    AbstractSublevelKeyIterator,
    AbstractSublevelValueIterator
  } = requireAbstractSublevelIterator();
  const kPrefix = Symbol("prefix");
  const kUpperBound = Symbol("upperBound");
  const kPrefixRange = Symbol("prefixRange");
  const kParent = Symbol("parent");
  const kUnfix = Symbol("unfix");
  const textEncoder2 = new TextEncoder();
  const defaults = { separator: "!" };
  abstractSublevel = function({ AbstractLevel: AbstractLevel2 }) {
    class AbstractSublevel2 extends AbstractLevel2 {
      static defaults(options) {
        if (typeof options === "string") {
          throw new ModuleError3("The subleveldown string shorthand for { separator } has been removed", {
            code: "LEVEL_LEGACY"
          });
        } else if (options && options.open) {
          throw new ModuleError3("The subleveldown open option has been removed", {
            code: "LEVEL_LEGACY"
          });
        }
        if (options == null) {
          return defaults;
        } else if (!options.separator) {
          return { ...options, separator: "!" };
        } else {
          return options;
        }
      }
      constructor(db, name2, options) {
        const { separator, manifest, ...forward } = AbstractSublevel2.defaults(options);
        name2 = trim(name2, separator);
        const reserved = separator.charCodeAt(0) + 1;
        const parent = db[kParent] || db;
        if (!textEncoder2.encode(name2).every((x2) => x2 > reserved && x2 < 127)) {
          throw new ModuleError3(`Prefix must use bytes > ${reserved} < ${127}`, {
            code: "LEVEL_INVALID_PREFIX"
          });
        }
        super(mergeManifests(parent, manifest), forward);
        const prefix = (db.prefix || "") + separator + name2 + separator;
        const upperBound = prefix.slice(0, -1) + String.fromCharCode(reserved);
        this[kParent] = parent;
        this[kPrefix] = new MultiFormat(prefix);
        this[kUpperBound] = new MultiFormat(upperBound);
        this[kUnfix] = new Unfixer();
        this.nextTick = parent.nextTick;
      }
      prefixKey(key, keyFormat) {
        if (keyFormat === "utf8") {
          return this[kPrefix].utf8 + key;
        } else if (key.byteLength === 0) {
          return this[kPrefix][keyFormat];
        } else if (keyFormat === "view") {
          const view = this[kPrefix].view;
          const result = new Uint8Array(view.byteLength + key.byteLength);
          result.set(view, 0);
          result.set(key, view.byteLength);
          return result;
        } else {
          const buffer2 = this[kPrefix].buffer;
          return Buffer2.concat([buffer2, key], buffer2.byteLength + key.byteLength);
        }
      }
      [kPrefixRange](range, keyFormat) {
        if (range.gte !== void 0) {
          range.gte = this.prefixKey(range.gte, keyFormat);
        } else if (range.gt !== void 0) {
          range.gt = this.prefixKey(range.gt, keyFormat);
        } else {
          range.gte = this[kPrefix][keyFormat];
        }
        if (range.lte !== void 0) {
          range.lte = this.prefixKey(range.lte, keyFormat);
        } else if (range.lt !== void 0) {
          range.lt = this.prefixKey(range.lt, keyFormat);
        } else {
          range.lte = this[kUpperBound][keyFormat];
        }
      }
      get prefix() {
        return this[kPrefix].utf8;
      }
      get db() {
        return this[kParent];
      }
      _open(options, callback) {
        this[kParent].open({ passive: true }, callback);
      }
      _put(key, value, options, callback) {
        this[kParent].put(key, value, options, callback);
      }
      _get(key, options, callback) {
        this[kParent].get(key, options, callback);
      }
      _getMany(keys, options, callback) {
        this[kParent].getMany(keys, options, callback);
      }
      _del(key, options, callback) {
        this[kParent].del(key, options, callback);
      }
      _batch(operations, options, callback) {
        this[kParent].batch(operations, options, callback);
      }
      _clear(options, callback) {
        this[kPrefixRange](options, options.keyEncoding);
        this[kParent].clear(options, callback);
      }
      _iterator(options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator2 = this[kParent].iterator(options);
        const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
        return new AbstractSublevelIterator(this, options, iterator2, unfix);
      }
      _keys(options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator2 = this[kParent].keys(options);
        const unfix = this[kUnfix].get(this[kPrefix].utf8.length, options.keyEncoding);
        return new AbstractSublevelKeyIterator(this, options, iterator2, unfix);
      }
      _values(options) {
        this[kPrefixRange](options, options.keyEncoding);
        const iterator2 = this[kParent].values(options);
        return new AbstractSublevelValueIterator(this, options, iterator2);
      }
    }
    return { AbstractSublevel: AbstractSublevel2 };
  };
  const mergeManifests = function(parent, manifest) {
    return {
      ...parent.supports,
      createIfMissing: false,
      errorIfExists: false,
      events: {},
      additionalMethods: {},
      ...manifest,
      encodings: {
        utf8: supportsEncoding(parent, "utf8"),
        buffer: supportsEncoding(parent, "buffer"),
        view: supportsEncoding(parent, "view")
      }
    };
  };
  const supportsEncoding = function(parent, encoding2) {
    return parent.supports.encodings[encoding2] ? parent.keyEncoding(encoding2).name === encoding2 : false;
  };
  class MultiFormat {
    constructor(key) {
      this.utf8 = key;
      this.view = textEncoder2.encode(key);
      this.buffer = Buffer2 ? Buffer2.from(this.view.buffer, 0, this.view.byteLength) : {};
    }
  }
  class Unfixer {
    constructor() {
      this.cache = /* @__PURE__ */ new Map();
    }
    get(prefixLength, keyFormat) {
      let unfix = this.cache.get(keyFormat);
      if (unfix === void 0) {
        if (keyFormat === "view") {
          unfix = function(prefixLength2, key) {
            return key.subarray(prefixLength2);
          }.bind(null, prefixLength);
        } else {
          unfix = function(prefixLength2, key) {
            return key.slice(prefixLength2);
          }.bind(null, prefixLength);
        }
        this.cache.set(keyFormat, unfix);
      }
      return unfix;
    }
  }
  const trim = function(str, char) {
    let start = 0;
    let end2 = str.length;
    while (start < end2 && str[start] === char)
      start++;
    while (end2 > start && str[end2 - 1] === char)
      end2--;
    return str.slice(start, end2);
  };
  return abstractSublevel;
}
const { supports } = levelSupports;
const { Transcoder } = levelTranscoder;
const { EventEmitter } = events$1.exports;
const { fromCallback: fromCallback$1 } = catering;
const ModuleError$1 = moduleError;
const { AbstractIterator: AbstractIterator$1 } = abstractIterator;
const { DefaultKeyIterator, DefaultValueIterator } = defaultKvIterator;
const { DeferredIterator, DeferredKeyIterator, DeferredValueIterator } = deferredIterator;
const { DefaultChainedBatch } = defaultChainedBatch;
const { getCallback, getOptions } = common;
const rangeOptions = rangeOptions_1;
const kPromise$1 = Symbol("promise");
const kLanded = Symbol("landed");
const kResources = Symbol("resources");
const kCloseResources = Symbol("closeResources");
const kOperations = Symbol("operations");
const kUndefer = Symbol("undefer");
const kDeferOpen = Symbol("deferOpen");
const kOptions$1 = Symbol("options");
const kStatus = Symbol("status");
const kDefaultOptions = Symbol("defaultOptions");
const kTranscoder = Symbol("transcoder");
const kKeyEncoding = Symbol("keyEncoding");
const kValueEncoding = Symbol("valueEncoding");
const noop = () => {
};
class AbstractLevel$1 extends EventEmitter {
  constructor(manifest, options) {
    super();
    if (typeof manifest !== "object" || manifest === null) {
      throw new TypeError("The first argument 'manifest' must be an object");
    }
    options = getOptions(options);
    const { keyEncoding, valueEncoding, passive, ...forward } = options;
    this[kResources] = /* @__PURE__ */ new Set();
    this[kOperations] = [];
    this[kDeferOpen] = true;
    this[kOptions$1] = forward;
    this[kStatus] = "opening";
    this.supports = supports(manifest, {
      status: true,
      promises: true,
      clear: true,
      getMany: true,
      deferredOpen: true,
      snapshots: manifest.snapshots !== false,
      permanence: manifest.permanence !== false,
      keyIterator: true,
      valueIterator: true,
      iteratorNextv: true,
      iteratorAll: true,
      encodings: manifest.encodings || {},
      events: Object.assign({}, manifest.events, {
        opening: true,
        open: true,
        closing: true,
        closed: true,
        put: true,
        del: true,
        batch: true,
        clear: true
      })
    });
    this[kTranscoder] = new Transcoder(formats(this));
    this[kKeyEncoding] = this[kTranscoder].encoding(keyEncoding || "utf8");
    this[kValueEncoding] = this[kTranscoder].encoding(valueEncoding || "utf8");
    for (const encoding2 of this[kTranscoder].encodings()) {
      if (!this.supports.encodings[encoding2.commonName]) {
        this.supports.encodings[encoding2.commonName] = true;
      }
    }
    this[kDefaultOptions] = {
      empty: Object.freeze({}),
      entry: Object.freeze({
        keyEncoding: this[kKeyEncoding].commonName,
        valueEncoding: this[kValueEncoding].commonName
      }),
      key: Object.freeze({
        keyEncoding: this[kKeyEncoding].commonName
      })
    };
    this.nextTick(() => {
      if (this[kDeferOpen]) {
        this.open({ passive: false }, noop);
      }
    });
  }
  get status() {
    return this[kStatus];
  }
  keyEncoding(encoding2) {
    return this[kTranscoder].encoding(encoding2 != null ? encoding2 : this[kKeyEncoding]);
  }
  valueEncoding(encoding2) {
    return this[kTranscoder].encoding(encoding2 != null ? encoding2 : this[kValueEncoding]);
  }
  open(options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = { ...this[kOptions$1], ...getOptions(options) };
    options.createIfMissing = options.createIfMissing !== false;
    options.errorIfExists = !!options.errorIfExists;
    const maybeOpened = (err) => {
      if (this[kStatus] === "closing" || this[kStatus] === "opening") {
        this.once(kLanded, err ? () => maybeOpened(err) : maybeOpened);
      } else if (this[kStatus] !== "open") {
        callback(new ModuleError$1("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN",
          cause: err
        }));
      } else {
        callback();
      }
    };
    if (options.passive) {
      if (this[kStatus] === "opening") {
        this.once(kLanded, maybeOpened);
      } else {
        this.nextTick(maybeOpened);
      }
    } else if (this[kStatus] === "closed" || this[kDeferOpen]) {
      this[kDeferOpen] = false;
      this[kStatus] = "opening";
      this.emit("opening");
      this._open(options, (err) => {
        if (err) {
          this[kStatus] = "closed";
          this[kCloseResources](() => {
            this.emit(kLanded);
            maybeOpened(err);
          });
          this[kUndefer]();
          return;
        }
        this[kStatus] = "open";
        this[kUndefer]();
        this.emit(kLanded);
        if (this[kStatus] === "open")
          this.emit("open");
        if (this[kStatus] === "open")
          this.emit("ready");
        maybeOpened();
      });
    } else if (this[kStatus] === "open") {
      this.nextTick(maybeOpened);
    } else {
      this.once(kLanded, () => this.open(options, callback));
    }
    return callback[kPromise$1];
  }
  _open(options, callback) {
    this.nextTick(callback);
  }
  close(callback) {
    callback = fromCallback$1(callback, kPromise$1);
    const maybeClosed = (err) => {
      if (this[kStatus] === "opening" || this[kStatus] === "closing") {
        this.once(kLanded, err ? maybeClosed(err) : maybeClosed);
      } else if (this[kStatus] !== "closed") {
        callback(new ModuleError$1("Database is not closed", {
          code: "LEVEL_DATABASE_NOT_CLOSED",
          cause: err
        }));
      } else {
        callback();
      }
    };
    if (this[kStatus] === "open") {
      this[kStatus] = "closing";
      this.emit("closing");
      const cancel = (err) => {
        this[kStatus] = "open";
        this[kUndefer]();
        this.emit(kLanded);
        maybeClosed(err);
      };
      this[kCloseResources](() => {
        this._close((err) => {
          if (err)
            return cancel(err);
          this[kStatus] = "closed";
          this[kUndefer]();
          this.emit(kLanded);
          if (this[kStatus] === "closed")
            this.emit("closed");
          maybeClosed();
        });
      });
    } else if (this[kStatus] === "closed") {
      this.nextTick(maybeClosed);
    } else {
      this.once(kLanded, () => this.close(callback));
    }
    return callback[kPromise$1];
  }
  [kCloseResources](callback) {
    if (this[kResources].size === 0) {
      return this.nextTick(callback);
    }
    let pending = this[kResources].size;
    let sync = true;
    const next = () => {
      if (--pending === 0) {
        if (sync)
          this.nextTick(callback);
        else
          callback();
      }
    };
    for (const resource of this[kResources]) {
      resource.close(next);
    }
    sync = false;
    this[kResources].clear();
  }
  _close(callback) {
    this.nextTick(callback);
  }
  get(key, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].entry);
    if (this[kStatus] === "opening") {
      this.defer(() => this.get(key, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const err = this._checkKey(key);
    if (err) {
      this.nextTick(callback, err);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const valueEncoding = this.valueEncoding(options.valueEncoding);
    const keyFormat = keyEncoding.format;
    const valueFormat = valueEncoding.format;
    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
    }
    this._get(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err2, value) => {
      if (err2) {
        if (err2.code === "LEVEL_NOT_FOUND" || err2.notFound || /NotFound/i.test(err2)) {
          if (!err2.code)
            err2.code = "LEVEL_NOT_FOUND";
          if (!err2.notFound)
            err2.notFound = true;
          if (!err2.status)
            err2.status = 404;
        }
        return callback(err2);
      }
      try {
        value = valueEncoding.decode(value);
      } catch (err3) {
        return callback(new ModuleError$1("Could not decode value", {
          code: "LEVEL_DECODE_ERROR",
          cause: err3
        }));
      }
      callback(null, value);
    });
    return callback[kPromise$1];
  }
  _get(key, options, callback) {
    this.nextTick(callback, new Error("NotFound"));
  }
  getMany(keys, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].entry);
    if (this[kStatus] === "opening") {
      this.defer(() => this.getMany(keys, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    if (!Array.isArray(keys)) {
      this.nextTick(callback, new TypeError("The first argument 'keys' must be an array"));
      return callback[kPromise$1];
    }
    if (keys.length === 0) {
      this.nextTick(callback, null, []);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const valueEncoding = this.valueEncoding(options.valueEncoding);
    const keyFormat = keyEncoding.format;
    const valueFormat = valueEncoding.format;
    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
    }
    const mappedKeys = new Array(keys.length);
    for (let i2 = 0; i2 < keys.length; i2++) {
      const key = keys[i2];
      const err = this._checkKey(key);
      if (err) {
        this.nextTick(callback, err);
        return callback[kPromise$1];
      }
      mappedKeys[i2] = this.prefixKey(keyEncoding.encode(key), keyFormat);
    }
    this._getMany(mappedKeys, options, (err, values) => {
      if (err)
        return callback(err);
      try {
        for (let i2 = 0; i2 < values.length; i2++) {
          if (values[i2] !== void 0) {
            values[i2] = valueEncoding.decode(values[i2]);
          }
        }
      } catch (err2) {
        return callback(new ModuleError$1(`Could not decode one or more of ${values.length} value(s)`, {
          code: "LEVEL_DECODE_ERROR",
          cause: err2
        }));
      }
      callback(null, values);
    });
    return callback[kPromise$1];
  }
  _getMany(keys, options, callback) {
    this.nextTick(callback, null, new Array(keys.length).fill(void 0));
  }
  put(key, value, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].entry);
    if (this[kStatus] === "opening") {
      this.defer(() => this.put(key, value, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const err = this._checkKey(key) || this._checkValue(value);
    if (err) {
      this.nextTick(callback, err);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const valueEncoding = this.valueEncoding(options.valueEncoding);
    const keyFormat = keyEncoding.format;
    const valueFormat = valueEncoding.format;
    if (options.keyEncoding !== keyFormat || options.valueEncoding !== valueFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat, valueEncoding: valueFormat });
    }
    const mappedKey = this.prefixKey(keyEncoding.encode(key), keyFormat);
    const mappedValue = valueEncoding.encode(value);
    this._put(mappedKey, mappedValue, options, (err2) => {
      if (err2)
        return callback(err2);
      this.emit("put", key, value);
      callback();
    });
    return callback[kPromise$1];
  }
  _put(key, value, options, callback) {
    this.nextTick(callback);
  }
  del(key, options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].key);
    if (this[kStatus] === "opening") {
      this.defer(() => this.del(key, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const err = this._checkKey(key);
    if (err) {
      this.nextTick(callback, err);
      return callback[kPromise$1];
    }
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    const keyFormat = keyEncoding.format;
    if (options.keyEncoding !== keyFormat) {
      options = Object.assign({}, options, { keyEncoding: keyFormat });
    }
    this._del(this.prefixKey(keyEncoding.encode(key), keyFormat), options, (err2) => {
      if (err2)
        return callback(err2);
      this.emit("del", key);
      callback();
    });
    return callback[kPromise$1];
  }
  _del(key, options, callback) {
    this.nextTick(callback);
  }
  batch(operations, options, callback) {
    if (!arguments.length) {
      if (this[kStatus] === "opening")
        return new DefaultChainedBatch(this);
      if (this[kStatus] !== "open") {
        throw new ModuleError$1("Database is not open", {
          code: "LEVEL_DATABASE_NOT_OPEN"
        });
      }
      return this._chainedBatch();
    }
    if (typeof operations === "function")
      callback = operations;
    else
      callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].empty);
    if (this[kStatus] === "opening") {
      this.defer(() => this.batch(operations, options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    if (!Array.isArray(operations)) {
      this.nextTick(callback, new TypeError("The first argument 'operations' must be an array"));
      return callback[kPromise$1];
    }
    if (operations.length === 0) {
      this.nextTick(callback);
      return callback[kPromise$1];
    }
    const mapped = new Array(operations.length);
    const { keyEncoding: ke2, valueEncoding: ve2, ...forward } = options;
    for (let i2 = 0; i2 < operations.length; i2++) {
      if (typeof operations[i2] !== "object" || operations[i2] === null) {
        this.nextTick(callback, new TypeError("A batch operation must be an object"));
        return callback[kPromise$1];
      }
      const op = Object.assign({}, operations[i2]);
      if (op.type !== "put" && op.type !== "del") {
        this.nextTick(callback, new TypeError("A batch operation must have a type property that is 'put' or 'del'"));
        return callback[kPromise$1];
      }
      const err = this._checkKey(op.key);
      if (err) {
        this.nextTick(callback, err);
        return callback[kPromise$1];
      }
      const db = op.sublevel != null ? op.sublevel : this;
      const keyEncoding = db.keyEncoding(op.keyEncoding || ke2);
      const keyFormat = keyEncoding.format;
      op.key = db.prefixKey(keyEncoding.encode(op.key), keyFormat);
      op.keyEncoding = keyFormat;
      if (op.type === "put") {
        const valueErr = this._checkValue(op.value);
        if (valueErr) {
          this.nextTick(callback, valueErr);
          return callback[kPromise$1];
        }
        const valueEncoding = db.valueEncoding(op.valueEncoding || ve2);
        op.value = valueEncoding.encode(op.value);
        op.valueEncoding = valueEncoding.format;
      }
      if (db !== this) {
        op.sublevel = null;
      }
      mapped[i2] = op;
    }
    this._batch(mapped, forward, (err) => {
      if (err)
        return callback(err);
      this.emit("batch", operations);
      callback();
    });
    return callback[kPromise$1];
  }
  _batch(operations, options, callback) {
    this.nextTick(callback);
  }
  sublevel(name2, options) {
    return this._sublevel(name2, AbstractSublevel.defaults(options));
  }
  _sublevel(name2, options) {
    return new AbstractSublevel(this, name2, options);
  }
  prefixKey(key, keyFormat) {
    return key;
  }
  clear(options, callback) {
    callback = getCallback(options, callback);
    callback = fromCallback$1(callback, kPromise$1);
    options = getOptions(options, this[kDefaultOptions].empty);
    if (this[kStatus] === "opening") {
      this.defer(() => this.clear(options, callback));
      return callback[kPromise$1];
    }
    if (maybeError(this, callback)) {
      return callback[kPromise$1];
    }
    const original = options;
    const keyEncoding = this.keyEncoding(options.keyEncoding);
    options = rangeOptions(options, keyEncoding);
    options.keyEncoding = keyEncoding.format;
    if (options.limit === 0) {
      this.nextTick(callback);
    } else {
      this._clear(options, (err) => {
        if (err)
          return callback(err);
        this.emit("clear", original);
        callback();
      });
    }
    return callback[kPromise$1];
  }
  _clear(options, callback) {
    this.nextTick(callback);
  }
  iterator(options) {
    const keyEncoding = this.keyEncoding(options && options.keyEncoding);
    const valueEncoding = this.valueEncoding(options && options.valueEncoding);
    options = rangeOptions(options, keyEncoding);
    options.keys = options.keys !== false;
    options.values = options.values !== false;
    options[AbstractIterator$1.keyEncoding] = keyEncoding;
    options[AbstractIterator$1.valueEncoding] = valueEncoding;
    options.keyEncoding = keyEncoding.format;
    options.valueEncoding = valueEncoding.format;
    if (this[kStatus] === "opening") {
      return new DeferredIterator(this, options);
    } else if (this[kStatus] !== "open") {
      throw new ModuleError$1("Database is not open", {
        code: "LEVEL_DATABASE_NOT_OPEN"
      });
    }
    return this._iterator(options);
  }
  _iterator(options) {
    return new AbstractIterator$1(this, options);
  }
  keys(options) {
    const keyEncoding = this.keyEncoding(options && options.keyEncoding);
    const valueEncoding = this.valueEncoding(options && options.valueEncoding);
    options = rangeOptions(options, keyEncoding);
    options[AbstractIterator$1.keyEncoding] = keyEncoding;
    options[AbstractIterator$1.valueEncoding] = valueEncoding;
    options.keyEncoding = keyEncoding.format;
    options.valueEncoding = valueEncoding.format;
    if (this[kStatus] === "opening") {
      return new DeferredKeyIterator(this, options);
    } else if (this[kStatus] !== "open") {
      throw new ModuleError$1("Database is not open", {
        code: "LEVEL_DATABASE_NOT_OPEN"
      });
    }
    return this._keys(options);
  }
  _keys(options) {
    return new DefaultKeyIterator(this, options);
  }
  values(options) {
    const keyEncoding = this.keyEncoding(options && options.keyEncoding);
    const valueEncoding = this.valueEncoding(options && options.valueEncoding);
    options = rangeOptions(options, keyEncoding);
    options[AbstractIterator$1.keyEncoding] = keyEncoding;
    options[AbstractIterator$1.valueEncoding] = valueEncoding;
    options.keyEncoding = keyEncoding.format;
    options.valueEncoding = valueEncoding.format;
    if (this[kStatus] === "opening") {
      return new DeferredValueIterator(this, options);
    } else if (this[kStatus] !== "open") {
      throw new ModuleError$1("Database is not open", {
        code: "LEVEL_DATABASE_NOT_OPEN"
      });
    }
    return this._values(options);
  }
  _values(options) {
    return new DefaultValueIterator(this, options);
  }
  defer(fn2) {
    if (typeof fn2 !== "function") {
      throw new TypeError("The first argument must be a function");
    }
    this[kOperations].push(fn2);
  }
  [kUndefer]() {
    if (this[kOperations].length === 0) {
      return;
    }
    const operations = this[kOperations];
    this[kOperations] = [];
    for (const op of operations) {
      op();
    }
  }
  attachResource(resource) {
    if (typeof resource !== "object" || resource === null || typeof resource.close !== "function") {
      throw new TypeError("The first argument must be a resource object");
    }
    this[kResources].add(resource);
  }
  detachResource(resource) {
    this[kResources].delete(resource);
  }
  _chainedBatch() {
    return new DefaultChainedBatch(this);
  }
  _checkKey(key) {
    if (key === null || key === void 0) {
      return new ModuleError$1("Key cannot be null or undefined", {
        code: "LEVEL_INVALID_KEY"
      });
    }
  }
  _checkValue(value) {
    if (value === null || value === void 0) {
      return new ModuleError$1("Value cannot be null or undefined", {
        code: "LEVEL_INVALID_VALUE"
      });
    }
  }
}
AbstractLevel$1.prototype.nextTick = requireNextTickBrowser();
const { AbstractSublevel } = requireAbstractSublevel()({ AbstractLevel: AbstractLevel$1 });
abstractLevel.AbstractLevel = AbstractLevel$1;
abstractLevel.AbstractSublevel = AbstractSublevel;
const maybeError = function(db, callback) {
  if (db[kStatus] !== "open") {
    db.nextTick(callback, new ModuleError$1("Database is not open", {
      code: "LEVEL_DATABASE_NOT_OPEN"
    }));
    return true;
  }
  return false;
};
const formats = function(db) {
  return Object.keys(db.supports.encodings).filter((k) => !!db.supports.encodings[k]);
};
abstractLevel$1.AbstractLevel = abstractLevel.AbstractLevel;
abstractLevel$1.AbstractSublevel = abstractLevel.AbstractSublevel;
abstractLevel$1.AbstractIterator = abstractIterator.AbstractIterator;
abstractLevel$1.AbstractKeyIterator = abstractIterator.AbstractKeyIterator;
abstractLevel$1.AbstractValueIterator = abstractIterator.AbstractValueIterator;
abstractLevel$1.AbstractChainedBatch = abstractChainedBatch.AbstractChainedBatch;
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var runParallelLimit_1 = runParallelLimit;
const queueMicrotask$1 = queueMicrotask_1;
function runParallelLimit(tasks, limit, cb) {
  if (typeof limit !== "number")
    throw new Error("second argument must be a Number");
  let results, len2, pending, keys, isErrored;
  let isSync = true;
  let next;
  if (Array.isArray(tasks)) {
    results = [];
    pending = len2 = tasks.length;
  } else {
    keys = Object.keys(tasks);
    results = {};
    pending = len2 = keys.length;
  }
  function done(err) {
    function end2() {
      if (cb)
        cb(err, results);
      cb = null;
    }
    if (isSync)
      queueMicrotask$1(end2);
    else
      end2();
  }
  function each(i2, err, result) {
    results[i2] = result;
    if (err)
      isErrored = true;
    if (--pending === 0 || err) {
      done(err);
    } else if (!isErrored && next < len2) {
      let key;
      if (keys) {
        key = keys[next];
        next += 1;
        tasks[key](function(err2, result2) {
          each(key, err2, result2);
        });
      } else {
        key = next;
        next += 1;
        tasks[key](function(err2, result2) {
          each(key, err2, result2);
        });
      }
    }
  }
  next = limit;
  if (!pending) {
    done(null);
  } else if (keys) {
    keys.some(function(key, i2) {
      tasks[key](function(err, result) {
        each(key, err, result);
      });
      if (i2 === limit - 1)
        return true;
      return false;
    });
  } else {
    tasks.some(function(task, i2) {
      task(function(err, result) {
        each(i2, err, result);
      });
      if (i2 === limit - 1)
        return true;
      return false;
    });
  }
  isSync = false;
}
var iterator = {};
var keyRange = function createKeyRange2(options) {
  const lower = options.gte !== void 0 ? options.gte : options.gt !== void 0 ? options.gt : void 0;
  const upper = options.lte !== void 0 ? options.lte : options.lt !== void 0 ? options.lt : void 0;
  const lowerExclusive = options.gte === void 0;
  const upperExclusive = options.lte === void 0;
  if (lower !== void 0 && upper !== void 0) {
    return IDBKeyRange.bound(lower, upper, lowerExclusive, upperExclusive);
  } else if (lower !== void 0) {
    return IDBKeyRange.lowerBound(lower, lowerExclusive);
  } else if (upper !== void 0) {
    return IDBKeyRange.upperBound(upper, upperExclusive);
  } else {
    return null;
  }
};
const textEncoder$1 = new TextEncoder();
var deserialize$2 = function(data) {
  if (data instanceof Uint8Array) {
    return data;
  } else if (data instanceof ArrayBuffer) {
    return new Uint8Array(data);
  } else {
    return textEncoder$1.encode(data);
  }
};
const { AbstractIterator } = abstractLevel$1;
const createKeyRange$1 = keyRange;
const deserialize$1 = deserialize$2;
const kCache = Symbol("cache");
const kFinished = Symbol("finished");
const kOptions = Symbol("options");
const kCurrentOptions = Symbol("currentOptions");
const kPosition = Symbol("position");
const kLocation$1 = Symbol("location");
const kFirst = Symbol("first");
const emptyOptions = {};
class Iterator$1 extends AbstractIterator {
  constructor(db, location, options) {
    super(db, options);
    this[kCache] = [];
    this[kFinished] = this.limit === 0;
    this[kOptions] = options;
    this[kCurrentOptions] = { ...options };
    this[kPosition] = void 0;
    this[kLocation$1] = location;
    this[kFirst] = true;
  }
  _nextv(size, options, callback) {
    this[kFirst] = false;
    if (this[kFinished]) {
      return this.nextTick(callback, null, []);
    } else if (this[kCache].length > 0) {
      size = Math.min(size, this[kCache].length);
      return this.nextTick(callback, null, this[kCache].splice(0, size));
    }
    if (this[kPosition] !== void 0) {
      if (this[kOptions].reverse) {
        this[kCurrentOptions].lt = this[kPosition];
        this[kCurrentOptions].lte = void 0;
      } else {
        this[kCurrentOptions].gt = this[kPosition];
        this[kCurrentOptions].gte = void 0;
      }
    }
    let keyRange2;
    try {
      keyRange2 = createKeyRange$1(this[kCurrentOptions]);
    } catch (_2) {
      this[kFinished] = true;
      return this.nextTick(callback, null, []);
    }
    const transaction = this.db.db.transaction([this[kLocation$1]], "readonly");
    const store = transaction.objectStore(this[kLocation$1]);
    const entries = [];
    if (!this[kOptions].reverse) {
      let keys;
      let values;
      const complete = () => {
        if (keys === void 0 || values === void 0)
          return;
        const length2 = Math.max(keys.length, values.length);
        if (length2 === 0 || size === Infinity) {
          this[kFinished] = true;
        } else {
          this[kPosition] = keys[length2 - 1];
        }
        entries.length = length2;
        for (let i2 = 0; i2 < length2; i2++) {
          const key = keys[i2];
          const value = values[i2];
          entries[i2] = [
            this[kOptions].keys && key !== void 0 ? deserialize$1(key) : void 0,
            this[kOptions].values && value !== void 0 ? deserialize$1(value) : void 0
          ];
        }
        maybeCommit(transaction);
      };
      if (this[kOptions].keys || size < Infinity) {
        store.getAllKeys(keyRange2, size < Infinity ? size : void 0).onsuccess = (ev) => {
          keys = ev.target.result;
          complete();
        };
      } else {
        keys = [];
        this.nextTick(complete);
      }
      if (this[kOptions].values) {
        store.getAll(keyRange2, size < Infinity ? size : void 0).onsuccess = (ev) => {
          values = ev.target.result;
          complete();
        };
      } else {
        values = [];
        this.nextTick(complete);
      }
    } else {
      const method = !this[kOptions].values && store.openKeyCursor ? "openKeyCursor" : "openCursor";
      store[method](keyRange2, "prev").onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor) {
          const { key, value } = cursor;
          this[kPosition] = key;
          entries.push([
            this[kOptions].keys && key !== void 0 ? deserialize$1(key) : void 0,
            this[kOptions].values && value !== void 0 ? deserialize$1(value) : void 0
          ]);
          if (entries.length < size) {
            cursor.continue();
          } else {
            maybeCommit(transaction);
          }
        } else {
          this[kFinished] = true;
        }
      };
    }
    transaction.onabort = () => {
      callback(transaction.error || new Error("aborted by user"));
      callback = null;
    };
    transaction.oncomplete = () => {
      callback(null, entries);
      callback = null;
    };
  }
  _next(callback) {
    if (this[kCache].length > 0) {
      const [key, value] = this[kCache].shift();
      this.nextTick(callback, null, key, value);
    } else if (this[kFinished]) {
      this.nextTick(callback);
    } else {
      let size = Math.min(100, this.limit - this.count);
      if (this[kFirst]) {
        this[kFirst] = false;
        size = 1;
      }
      this._nextv(size, emptyOptions, (err, entries) => {
        if (err)
          return callback(err);
        this[kCache] = entries;
        this._next(callback);
      });
    }
  }
  _all(options, callback) {
    this[kFirst] = false;
    const cache = this[kCache].splice(0, this[kCache].length);
    const size = this.limit - this.count - cache.length;
    if (size <= 0) {
      return this.nextTick(callback, null, cache);
    }
    this._nextv(size, emptyOptions, (err, entries) => {
      if (err)
        return callback(err);
      if (cache.length > 0)
        entries = cache.concat(entries);
      callback(null, entries);
    });
  }
  _seek(target, options) {
    this[kFirst] = true;
    this[kCache] = [];
    this[kFinished] = false;
    this[kPosition] = void 0;
    this[kCurrentOptions] = { ...this[kOptions] };
    let keyRange2;
    try {
      keyRange2 = createKeyRange$1(this[kOptions]);
    } catch (_2) {
      this[kFinished] = true;
      return;
    }
    if (keyRange2 !== null && !keyRange2.includes(target)) {
      this[kFinished] = true;
    } else if (this[kOptions].reverse) {
      this[kCurrentOptions].lte = target;
    } else {
      this[kCurrentOptions].gte = target;
    }
  }
}
iterator.Iterator = Iterator$1;
function maybeCommit(transaction) {
  if (typeof transaction.commit === "function") {
    transaction.commit();
  }
}
var clear$1 = function clear2(db, location, keyRange2, options, callback) {
  if (options.limit === 0)
    return db.nextTick(callback);
  const transaction = db.db.transaction([location], "readwrite");
  const store = transaction.objectStore(location);
  let count = 0;
  transaction.oncomplete = function() {
    callback();
  };
  transaction.onabort = function() {
    callback(transaction.error || new Error("aborted by user"));
  };
  const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
  const direction = options.reverse ? "prev" : "next";
  store[method](keyRange2, direction).onsuccess = function(ev) {
    const cursor = ev.target.result;
    if (cursor) {
      store.delete(cursor.key).onsuccess = function() {
        if (options.limit <= 0 || ++count < options.limit) {
          cursor.continue();
        }
      };
    }
  };
};
const { AbstractLevel } = abstractLevel$1;
const ModuleError = moduleError;
const parallel = runParallelLimit_1;
const { fromCallback } = catering;
const { Iterator } = iterator;
const deserialize = deserialize$2;
const clear = clear$1;
const createKeyRange = keyRange;
const DEFAULT_PREFIX = "level-js-";
const kIDB = Symbol("idb");
const kNamePrefix = Symbol("namePrefix");
const kLocation = Symbol("location");
const kVersion = Symbol("version");
const kStore = Symbol("store");
const kOnComplete = Symbol("onComplete");
const kPromise = Symbol("promise");
class BrowserLevel extends AbstractLevel {
  constructor(location, options, _2) {
    if (typeof options === "function" || typeof _2 === "function") {
      throw new ModuleError("The levelup-style callback argument has been removed", {
        code: "LEVEL_LEGACY"
      });
    }
    const { prefix, version: version2, ...forward } = options || {};
    super({
      encodings: { view: true },
      snapshots: false,
      createIfMissing: false,
      errorIfExists: false,
      seek: true
    }, forward);
    if (typeof location !== "string") {
      throw new Error("constructor requires a location string argument");
    }
    this[kLocation] = location;
    this[kNamePrefix] = prefix == null ? DEFAULT_PREFIX : prefix;
    this[kVersion] = parseInt(version2 || 1, 10);
    this[kIDB] = null;
  }
  get location() {
    return this[kLocation];
  }
  get namePrefix() {
    return this[kNamePrefix];
  }
  get version() {
    return this[kVersion];
  }
  get db() {
    return this[kIDB];
  }
  get type() {
    return "browser-level";
  }
  _open(options, callback) {
    const req = indexedDB.open(this[kNamePrefix] + this[kLocation], this[kVersion]);
    req.onerror = function() {
      callback(req.error || new Error("unknown error"));
    };
    req.onsuccess = () => {
      this[kIDB] = req.result;
      callback();
    };
    req.onupgradeneeded = (ev) => {
      const db = ev.target.result;
      if (!db.objectStoreNames.contains(this[kLocation])) {
        db.createObjectStore(this[kLocation]);
      }
    };
  }
  [kStore](mode) {
    const transaction = this[kIDB].transaction([this[kLocation]], mode);
    return transaction.objectStore(this[kLocation]);
  }
  [kOnComplete](request, callback) {
    const transaction = request.transaction;
    transaction.onabort = function() {
      callback(transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      callback(null, request.result);
    };
  }
  _get(key, options, callback) {
    const store = this[kStore]("readonly");
    let req;
    try {
      req = store.get(key);
    } catch (err) {
      return this.nextTick(callback, err);
    }
    this[kOnComplete](req, function(err, value) {
      if (err)
        return callback(err);
      if (value === void 0) {
        return callback(new ModuleError("Entry not found", {
          code: "LEVEL_NOT_FOUND"
        }));
      }
      callback(null, deserialize(value));
    });
  }
  _getMany(keys, options, callback) {
    const store = this[kStore]("readonly");
    const tasks = keys.map((key) => (next) => {
      let request;
      try {
        request = store.get(key);
      } catch (err) {
        return next(err);
      }
      request.onsuccess = () => {
        const value = request.result;
        next(null, value === void 0 ? value : deserialize(value));
      };
      request.onerror = (ev) => {
        ev.stopPropagation();
        next(request.error);
      };
    });
    parallel(tasks, 16, callback);
  }
  _del(key, options, callback) {
    const store = this[kStore]("readwrite");
    let req;
    try {
      req = store.delete(key);
    } catch (err) {
      return this.nextTick(callback, err);
    }
    this[kOnComplete](req, callback);
  }
  _put(key, value, options, callback) {
    const store = this[kStore]("readwrite");
    let req;
    try {
      req = store.put(value, key);
    } catch (err) {
      return this.nextTick(callback, err);
    }
    this[kOnComplete](req, callback);
  }
  _iterator(options) {
    return new Iterator(this, this[kLocation], options);
  }
  _batch(operations, options, callback) {
    const store = this[kStore]("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error;
    transaction.onabort = function() {
      callback(error || transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      callback();
    };
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err) {
        error = err;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      } else if (typeof transaction.commit === "function") {
        transaction.commit();
      }
    }
    loop();
  }
  _clear(options, callback) {
    let keyRange2;
    let req;
    try {
      keyRange2 = createKeyRange(options);
    } catch (e) {
      return this.nextTick(callback);
    }
    if (options.limit >= 0) {
      return clear(this, this[kLocation], keyRange2, options, callback);
    }
    try {
      const store = this[kStore]("readwrite");
      req = keyRange2 ? store.delete(keyRange2) : store.clear();
    } catch (err) {
      return this.nextTick(callback, err);
    }
    this[kOnComplete](req, callback);
  }
  _close(callback) {
    this[kIDB].close();
    this.nextTick(callback);
  }
}
BrowserLevel.destroy = function(location, prefix, callback) {
  if (typeof prefix === "function") {
    callback = prefix;
    prefix = DEFAULT_PREFIX;
  }
  callback = fromCallback(callback, kPromise);
  const request = indexedDB.deleteDatabase(prefix + location);
  request.onsuccess = function() {
    callback();
  };
  request.onerror = function(err) {
    callback(err);
  };
  return callback[kPromise];
};
browserLevel.BrowserLevel = BrowserLevel;
var Level = browserLevel.BrowserLevel;
class LevelDatastore extends BaseDatastore {
  constructor(path, opts = {}) {
    super();
    this.db = typeof path === "string" ? new Level(path, {
      ...opts,
      keyEncoding: "utf8",
      valueEncoding: "view"
    }) : path;
    this.opts = {
      createIfMissing: true,
      compression: false,
      ...opts
    };
  }
  async open() {
    try {
      await this.db.open(this.opts);
    } catch (err) {
      throw dbOpenFailedError(err);
    }
  }
  async put(key, value) {
    try {
      await this.db.put(key.toString(), value);
    } catch (err) {
      throw dbWriteFailedError(err);
    }
  }
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        throw notFoundError$1(err);
      throw dbWriteFailedError(err);
    }
    return data;
  }
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        return false;
      throw err;
    }
    return true;
  }
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err) {
      throw dbDeleteFailedError(err);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const ops = [];
    return {
      put: (key, value) => {
        ops.push({
          type: "put",
          key: key.toString(),
          value
        });
      },
      delete: (key) => {
        ops.push({
          type: "del",
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  queryKeys(q) {
    let it = map(this._query({
      values: false,
      prefix: q.prefix
    }), ({ key }) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => filter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sort(it2, f), it);
    }
    const { offset, limit } = q;
    if (offset) {
      let i2 = 0;
      it = filter(it, () => i2++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyEncoding: "buffer",
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + "\xFF";
    }
    const iterator2 = this.db.iterator(iteratorOpts);
    if (iterator2[Symbol.asyncIterator]) {
      return levelIteratorToIterator(iterator2);
    }
    if (iterator2.next != null && iterator2.end != null) {
      return oldLevelIteratorToIterator(iterator2);
    }
    throw new Error("Level returned incompatible iterator");
  }
}
async function* levelIteratorToIterator(li2) {
  for await (const [key, value] of li2) {
    yield { key: new Key(key, false), value };
  }
  await li2.close();
}
function oldLevelIteratorToIterator(li2) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve, reject) => {
          li2.next((err, key, value) => {
            if (err)
              return reject(err);
            if (key == null) {
              return li2.end((err2) => {
                if (err2)
                  return reject(err2);
                resolve({ done: true, value: void 0 });
              });
            }
            resolve({ done: false, value: { key: new Key(key, false), value } });
          });
        }),
        return: () => new Promise((resolve, reject) => {
          li2.end((err) => {
            if (err)
              return reject(err);
            resolve({ done: true, value: void 0 });
          });
        })
      };
    }
  };
}
var encode_1$2 = encode$d;
var MSB$3 = 128, REST$3 = 127, MSBALL$2 = ~REST$3, INT$2 = Math.pow(2, 31);
function encode$d(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$2) {
    out[offset++] = num & 255 | MSB$3;
    num /= 128;
  }
  while (num & MSBALL$2) {
    out[offset++] = num & 255 | MSB$3;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$d.bytes = offset - oldOffset + 1;
  return out;
}
var decode$i = read$2;
var MSB$1$2 = 128, REST$1$2 = 127;
function read$2(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$2.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$2) << shift : (b2 & REST$1$2) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$2);
  read$2.bytes = counter - offset;
  return res;
}
var N1$2 = Math.pow(2, 7);
var N2$2 = Math.pow(2, 14);
var N3$2 = Math.pow(2, 21);
var N4$2 = Math.pow(2, 28);
var N5$2 = Math.pow(2, 35);
var N6$2 = Math.pow(2, 42);
var N7$2 = Math.pow(2, 49);
var N8$2 = Math.pow(2, 56);
var N9$2 = Math.pow(2, 63);
var length$2 = function(value) {
  return value < N1$2 ? 1 : value < N2$2 ? 2 : value < N3$2 ? 3 : value < N4$2 ? 4 : value < N5$2 ? 5 : value < N6$2 ? 6 : value < N7$2 ? 7 : value < N8$2 ? 8 : value < N9$2 ? 9 : 10;
};
var varint$2 = {
  encode: encode_1$2,
  decode: decode$i,
  encodingLength: length$2
};
var _brrp_varint$2 = varint$2;
const decode$h = (data, offset = 0) => {
  const code2 = _brrp_varint$2.decode(data, offset);
  return [
    code2,
    _brrp_varint$2.decode.bytes
  ];
};
const encodeTo$2 = (int, target, offset = 0) => {
  _brrp_varint$2.encode(int, target, offset);
  return target;
};
const encodingLength$2 = (int) => {
  return _brrp_varint$2.encodingLength(int);
};
const equals$5 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$2 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const create$2 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$2(code2);
  const digestOffset = sizeOffset + encodingLength$2(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$2(code2, bytes2, 0);
  encodeTo$2(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$2(code2, size, digest2, bytes2);
};
const decode$g = (multihash) => {
  const bytes2 = coerce$2(multihash);
  const [code2, sizeOffset] = decode$h(bytes2);
  const [size, digestOffset] = decode$h(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$2(code2, size, digest2, bytes2);
};
const equals$4 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$5(a2.bytes, b2.bytes);
  }
};
class Digest$2 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$2(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$2 = base$2;
var _brrp__multiformats_scope_baseX$2 = src$2;
class Encoder$2 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$2 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$2(this, decoder);
  }
}
class ComposedDecoder$2 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$2(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$2 = (left, right) => new ComposedDecoder$2({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$2 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$2(name2, prefix, baseEncode);
    this.decoder = new Decoder$2(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$2 = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$2(name2, prefix, encode2, decode2);
const baseX$2 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$2(alphabet2, name2);
  return from$2({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$2(decode2(text))
  });
};
const decode$f = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$c = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$2 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$2({
    prefix,
    name: name2,
    encode(input) {
      return encode$c(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$f(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$2 = baseX$2({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX$2({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base32$2 = rfc4648$2({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648$2({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648$2({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class CID$2 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$2,
      byteLength: hidden$2,
      code: readonly$2,
      version: readonly$2,
      multihash: readonly$2,
      bytes: readonly$2,
      _baseCache: hidden$2,
      asCID: hidden$2
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$2) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$2) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$2.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$2(code2, digest2);
        return CID$2.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$4(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$2(bytes2, _baseCache, base3 || base58btc$2.encoder);
      default:
        return toStringV1$2(bytes2, _baseCache, base3 || base32$2.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$2(/^0\.0/, IS_CID_DEPRECATION$2);
    return !!(value && (value[cidSymbol$2] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$2) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$2(version2, code2, multihash, bytes2 || encodeCID$2(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$2] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$g(multihash);
      return CID$2.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$2) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$2}) block encoding`);
        } else {
          return new CID$2(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$2(version2, code2, digest2.bytes);
        return new CID$2(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$2.create(0, DAG_PB_CODE$2, digest2);
  }
  static createV1(code2, digest2) {
    return CID$2.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$2.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$2.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$2(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$2(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$2.createV0(digest2) : CID$2.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$h(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$2;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$2(source, base3);
    const cid = CID$2.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$2 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$2;
      return [
        base58btc$2.prefix,
        decoder.decode(`${base58btc$2.prefix}${source}`)
      ];
    }
    case base58btc$2.prefix: {
      const decoder = base3 || base58btc$2;
      return [
        base58btc$2.prefix,
        decoder.decode(source)
      ];
    }
    case base32$2.prefix: {
      const decoder = base3 || base32$2;
      return [
        base32$2.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$2 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$2.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$2 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$2 = 112;
const SHA_256_CODE$2 = 18;
const encodeCID$2 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$2(version2);
  const hashOffset = codeOffset + encodingLength$2(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$2(version2, bytes2, 0);
  encodeTo$2(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$2 = Symbol.for("@ipld/js-cid/CID");
const readonly$2 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$2 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$2 = "0.0.0-dev";
const deprecate$2 = (range, message) => {
  if (range.test(version$2)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$2 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const code$4 = 85;
const sortAll = (iterable, sorter) => {
  return async function* () {
    const values = await itAll(iterable);
    yield* values.sort(sorter);
  }();
};
class BaseBlockstore {
  open() {
    return Promise.reject(new Error(".open is not implemented"));
  }
  close() {
    return Promise.reject(new Error(".close is not implemented"));
  }
  put(key, val, options) {
    return Promise.reject(new Error(".put is not implemented"));
  }
  get(key, options) {
    return Promise.reject(new Error(".get is not implemented"));
  }
  has(key, options) {
    return Promise.reject(new Error(".has is not implemented"));
  }
  delete(key, options) {
    return Promise.reject(new Error(".delete is not implemented"));
  }
  async *putMany(source, options = {}) {
    for await (const { key, value } of source) {
      await this.put(key, value, options);
      yield { key, value };
    }
  }
  async *getMany(source, options = {}) {
    for await (const key of source) {
      yield this.get(key, options);
    }
  }
  async *deleteMany(source, options = {}) {
    for await (const key of source) {
      await this.delete(key, options);
      yield key;
    }
  }
  batch() {
    let puts = [];
    let dels = [];
    return {
      put(key, value) {
        puts.push({ key, value });
      },
      delete(key) {
        dels.push(key);
      },
      commit: async (options) => {
        await itDrain(this.putMany(puts, options));
        puts = [];
        await itDrain(this.deleteMany(dels, options));
        dels = [];
      }
    };
  }
  async *_all(q, options) {
    throw new Error("._all is not implemented");
  }
  async *_allKeys(q, options) {
    throw new Error("._allKeys is not implemented");
  }
  query(q, options) {
    let it = this._all(q, options);
    if (q.prefix != null) {
      it = itFilter(
        it,
        (e) => e.key.toString().startsWith(q.prefix || "")
      );
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= (q.offset || 0));
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
  queryKeys(q, options) {
    let it = this._allKeys(q, options);
    if (q.prefix != null) {
      it = itFilter(it, (cid) => cid.toString().startsWith(q.prefix || ""));
    }
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it2, f) => itFilter(it2, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
    }
    if (q.offset != null) {
      let i2 = 0;
      it = itFilter(it, () => i2++ >= q.offset);
    }
    if (q.limit != null) {
      it = itTake(it, q.limit);
    }
    return it;
  }
}
function cidToKey(cid) {
  const c = CID$2.asCID(cid);
  if (!c) {
    throw errCode$1(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base32$2.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid(key) {
  return CID$2.createV1(code$4, decode$g(base32$2.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base32$2.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc$2.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc$2.decode("z" + input);
  } else {
    decoder = (input) => base32$2.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes2;
  for (let i2 = 1; i2 < prefix.length; i2++) {
    try {
      bytes2 = decoder(prefix.substring(0, i2));
    } catch (err) {
      if (err.message !== "Unexpected end of data") {
        throw err;
      }
    }
  }
  let str = "/C";
  if (bytes2) {
    str = `/${base32$2.encode(bytes2).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter2) => (pair) => {
        return filter2({ key: keyToCid(pair.key), value: pair.value });
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a2, b2) => {
        return order({ key: keyToCid(a2.key), value: a2.value }, { key: keyToCid(b2.key), value: b2.value });
      }
    ) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map(
      (filter2) => (key) => {
        return filter2(keyToCid(key));
      }
    ) : void 0,
    orders: query.orders ? query.orders.map(
      (order) => (a2, b2) => {
        return order(keyToCid(a2), keyToCid(b2));
      }
    ) : void 0
  };
}
class BlockstoreDatastoreAdapter extends BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const { key, value } of this.child.query(convertQuery(query), options)) {
      yield { key: keyToCid(key), value };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value, options) {
    await this.child.put(cidToKey(cid), value, options);
  }
  async *putMany(blocks, options) {
    const output = pushable$1({
      objectMode: true
    });
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await itDrain(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey(block.key);
            const exists = await store.has(key, options);
            if (!exists) {
              yield { key, value: block.value };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err) {
        output.end(err);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey(cid), options);
  }
  deleteMany(cids, options) {
    const out = pushable$1({
      objectMode: true
    });
    itDrain(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch((err) => {
      out.end(err);
    });
    return out;
  }
}
function createRepo(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo$1(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(
      new LevelDatastore(`${repoPath}/blocks`, {
        prefix: "",
        version: 2
      })
    ),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}
var Tc = Object.create;
var nr = Object.defineProperty;
var Ic = Object.getOwnPropertyDescriptor;
var Sc = Object.getOwnPropertyNames;
var Uc = Object.getPrototypeOf, Fc = Object.prototype.hasOwnProperty;
var F = (t, e) => () => (t && (e = t(t = 0)), e);
var S = (t, e) => () => (e || t((e = { exports: {} }).exports, e), e.exports), M = (t, e) => {
  for (var r in e)
    nr(t, r, { get: e[r], enumerable: true });
}, No = (t, e, r, n) => {
  if (e && typeof e == "object" || typeof e == "function")
    for (let o of Sc(e))
      !Fc.call(t, o) && o !== r && nr(t, o, { get: () => e[o], enumerable: !(n = Ic(e, o)) || n.enumerable });
  return t;
};
var J = (t, e, r) => (r = t != null ? Tc(Uc(t)) : {}, No(e || !t || !t.__esModule ? nr(r, "default", { value: t, enumerable: true }) : r, t)), R = (t) => No(nr({}, "__esModule", { value: true }), t);
var Po = S((or2) => {
  a();
  or2.byteLength = kc;
  or2.toByteArray = Nc;
  or2.fromByteArray = Pc;
  var De = [], ue = [], vc = typeof Uint8Array < "u" ? Uint8Array : Array, Xr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Ge = 0, $o = Xr.length; Ge < $o; ++Ge)
    De[Ge] = Xr[Ge], ue[Xr.charCodeAt(Ge)] = Ge;
  var Ge, $o;
  ue["-".charCodeAt(0)] = 62;
  ue["_".charCodeAt(0)] = 63;
  function Lo(t) {
    var e = t.length;
    if (e % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var r = t.indexOf("=");
    r === -1 && (r = e);
    var n = r === e ? 0 : 4 - r % 4;
    return [r, n];
  }
  function kc(t) {
    var e = Lo(t), r = e[0], n = e[1];
    return (r + n) * 3 / 4 - n;
  }
  function _c(t, e, r) {
    return (e + r) * 3 / 4 - r;
  }
  function Nc(t) {
    var e, r = Lo(t), n = r[0], o = r[1], i2 = new vc(_c(t, n, o)), s = 0, u = o > 0 ? n - 4 : n, h;
    for (h = 0; h < u; h += 4)
      e = ue[t.charCodeAt(h)] << 18 | ue[t.charCodeAt(h + 1)] << 12 | ue[t.charCodeAt(h + 2)] << 6 | ue[t.charCodeAt(h + 3)], i2[s++] = e >> 16 & 255, i2[s++] = e >> 8 & 255, i2[s++] = e & 255;
    return o === 2 && (e = ue[t.charCodeAt(h)] << 2 | ue[t.charCodeAt(h + 1)] >> 4, i2[s++] = e & 255), o === 1 && (e = ue[t.charCodeAt(h)] << 10 | ue[t.charCodeAt(h + 1)] << 4 | ue[t.charCodeAt(h + 2)] >> 2, i2[s++] = e >> 8 & 255, i2[s++] = e & 255), i2;
  }
  function $c(t) {
    return De[t >> 18 & 63] + De[t >> 12 & 63] + De[t >> 6 & 63] + De[t & 63];
  }
  function Lc(t, e, r) {
    for (var n, o = [], i2 = e; i2 < r; i2 += 3)
      n = (t[i2] << 16 & 16711680) + (t[i2 + 1] << 8 & 65280) + (t[i2 + 2] & 255), o.push($c(n));
    return o.join("");
  }
  function Pc(t) {
    for (var e, r = t.length, n = r % 3, o = [], i2 = 16383, s = 0, u = r - n; s < u; s += i2)
      o.push(Lc(t, s, s + i2 > u ? u : s + i2));
    return n === 1 ? (e = t[r - 1], o.push(De[e >> 2] + De[e << 4 & 63] + "==")) : n === 2 && (e = (t[r - 2] << 8) + t[r - 1], o.push(De[e >> 10] + De[e >> 4 & 63] + De[e << 2 & 63] + "=")), o.join("");
  }
});
var Ro = S((Yr) => {
  a();
  Yr.read = function(t, e, r, n, o) {
    var i2, s, u = o * 8 - n - 1, h = (1 << u) - 1, w = h >> 1, c = -7, g = r ? o - 1 : 0, B = r ? -1 : 1, k = t[e + g];
    for (g += B, i2 = k & (1 << -c) - 1, k >>= -c, c += u; c > 0; i2 = i2 * 256 + t[e + g], g += B, c -= 8)
      ;
    for (s = i2 & (1 << -c) - 1, i2 >>= -c, c += n; c > 0; s = s * 256 + t[e + g], g += B, c -= 8)
      ;
    if (i2 === 0)
      i2 = 1 - w;
    else {
      if (i2 === h)
        return s ? NaN : (k ? -1 : 1) * (1 / 0);
      s = s + Math.pow(2, n), i2 = i2 - w;
    }
    return (k ? -1 : 1) * s * Math.pow(2, i2 - n);
  };
  Yr.write = function(t, e, r, n, o, i2) {
    var s, u, h, w = i2 * 8 - o - 1, c = (1 << w) - 1, g = c >> 1, B = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k = n ? 0 : i2 - 1, I = n ? 1 : -1, v = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, s = c) : (s = Math.floor(Math.log(e) / Math.LN2), e * (h = Math.pow(2, -s)) < 1 && (s--, h *= 2), s + g >= 1 ? e += B / h : e += B * Math.pow(2, 1 - g), e * h >= 2 && (s++, h /= 2), s + g >= c ? (u = 0, s = c) : s + g >= 1 ? (u = (e * h - 1) * Math.pow(2, o), s = s + g) : (u = e * Math.pow(2, g - 1) * Math.pow(2, o), s = 0)); o >= 8; t[r + k] = u & 255, k += I, u /= 256, o -= 8)
      ;
    for (s = s << o | u, w += o; w > 0; t[r + k] = s & 255, k += I, s /= 256, w -= 8)
      ;
    t[r + k - I] |= v * 128;
  };
});
var ti = S((st) => {
  a();
  var Qr = Po(), ot = Ro(), Mo = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  st.Buffer = f;
  st.SlowBuffer = Hc;
  st.INSPECT_MAX_BYTES = 50;
  var ir = 2147483647;
  st.kMaxLength = ir;
  f.TYPED_ARRAY_SUPPORT = Rc();
  !f.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Rc() {
    try {
      let t = new Uint8Array(1), e = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), t.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(f.prototype, "parent", { enumerable: true, get: function() {
    if (!!f.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(f.prototype, "offset", { enumerable: true, get: function() {
    if (!!f.isBuffer(this))
      return this.byteOffset;
  } });
  function Ae(t) {
    if (t > ir)
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
    let e = new Uint8Array(t);
    return Object.setPrototypeOf(e, f.prototype), e;
  }
  function f(t, e, r) {
    if (typeof t == "number") {
      if (typeof e == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return tn(t);
    }
    return Ho(t, e, r);
  }
  f.poolSize = 8192;
  function Ho(t, e, r) {
    if (typeof t == "string")
      return Oc(t, e);
    if (ArrayBuffer.isView(t))
      return zc(t);
    if (t == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
    if (be(t, ArrayBuffer) || t && be(t.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (be(t, SharedArrayBuffer) || t && be(t.buffer, SharedArrayBuffer)))
      return Kr(t, e, r);
    if (typeof t == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n = t.valueOf && t.valueOf();
    if (n != null && n !== t)
      return f.from(n, e, r);
    let o = qc(t);
    if (o)
      return o;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof t[Symbol.toPrimitive] == "function")
      return f.from(t[Symbol.toPrimitive]("string"), e, r);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
  }
  f.from = function(t, e, r) {
    return Ho(t, e, r);
  };
  Object.setPrototypeOf(f.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(f, Uint8Array);
  function jo(t) {
    if (typeof t != "number")
      throw new TypeError('"size" argument must be of type number');
    if (t < 0)
      throw new RangeError('The value "' + t + '" is invalid for option "size"');
  }
  function Mc(t, e, r) {
    return jo(t), t <= 0 ? Ae(t) : e !== void 0 ? typeof r == "string" ? Ae(t).fill(e, r) : Ae(t).fill(e) : Ae(t);
  }
  f.alloc = function(t, e, r) {
    return Mc(t, e, r);
  };
  function tn(t) {
    return jo(t), Ae(t < 0 ? 0 : rn(t) | 0);
  }
  f.allocUnsafe = function(t) {
    return tn(t);
  };
  f.allocUnsafeSlow = function(t) {
    return tn(t);
  };
  function Oc(t, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !f.isEncoding(e))
      throw new TypeError("Unknown encoding: " + e);
    let r = Vo(t, e) | 0, n = Ae(r), o = n.write(t, e);
    return o !== r && (n = n.slice(0, o)), n;
  }
  function Zr(t) {
    let e = t.length < 0 ? 0 : rn(t.length) | 0, r = Ae(e);
    for (let n = 0; n < e; n += 1)
      r[n] = t[n] & 255;
    return r;
  }
  function zc(t) {
    if (be(t, Uint8Array)) {
      let e = new Uint8Array(t);
      return Kr(e.buffer, e.byteOffset, e.byteLength);
    }
    return Zr(t);
  }
  function Kr(t, e, r) {
    if (e < 0 || t.byteLength < e)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (t.byteLength < e + (r || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return e === void 0 && r === void 0 ? n = new Uint8Array(t) : r === void 0 ? n = new Uint8Array(t, e) : n = new Uint8Array(t, e, r), Object.setPrototypeOf(n, f.prototype), n;
  }
  function qc(t) {
    if (f.isBuffer(t)) {
      let e = rn(t.length) | 0, r = Ae(e);
      return r.length === 0 || t.copy(r, 0, 0, e), r;
    }
    if (t.length !== void 0)
      return typeof t.length != "number" || on2(t.length) ? Ae(0) : Zr(t);
    if (t.type === "Buffer" && Array.isArray(t.data))
      return Zr(t.data);
  }
  function rn(t) {
    if (t >= ir)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + ir.toString(16) + " bytes");
    return t | 0;
  }
  function Hc(t) {
    return +t != t && (t = 0), f.alloc(+t);
  }
  f.isBuffer = function(e) {
    return e != null && e._isBuffer === true && e !== f.prototype;
  };
  f.compare = function(e, r) {
    if (be(e, Uint8Array) && (e = f.from(e, e.offset, e.byteLength)), be(r, Uint8Array) && (r = f.from(r, r.offset, r.byteLength)), !f.isBuffer(e) || !f.isBuffer(r))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (e === r)
      return 0;
    let n = e.length, o = r.length;
    for (let i2 = 0, s = Math.min(n, o); i2 < s; ++i2)
      if (e[i2] !== r[i2]) {
        n = e[i2], o = r[i2];
        break;
      }
    return n < o ? -1 : o < n ? 1 : 0;
  };
  f.isEncoding = function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  f.concat = function(e, r) {
    if (!Array.isArray(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (e.length === 0)
      return f.alloc(0);
    let n;
    if (r === void 0)
      for (r = 0, n = 0; n < e.length; ++n)
        r += e[n].length;
    let o = f.allocUnsafe(r), i2 = 0;
    for (n = 0; n < e.length; ++n) {
      let s = e[n];
      if (be(s, Uint8Array))
        i2 + s.length > o.length ? (f.isBuffer(s) || (s = f.from(s)), s.copy(o, i2)) : Uint8Array.prototype.set.call(o, s, i2);
      else if (f.isBuffer(s))
        s.copy(o, i2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      i2 += s.length;
    }
    return o;
  };
  function Vo(t, e) {
    if (f.isBuffer(t))
      return t.length;
    if (ArrayBuffer.isView(t) || be(t, ArrayBuffer))
      return t.byteLength;
    if (typeof t != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
    let r = t.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && r === 0)
      return 0;
    let o = false;
    for (; ; )
      switch (e) {
        case "ascii":
        case "latin1":
        case "binary":
          return r;
        case "utf8":
        case "utf-8":
          return en(t).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return r * 2;
        case "hex":
          return r >>> 1;
        case "base64":
          return ei(t).length;
        default:
          if (o)
            return n ? -1 : en(t).length;
          e = ("" + e).toLowerCase(), o = true;
      }
  }
  f.byteLength = Vo;
  function jc(t, e, r) {
    let n = false;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((r === void 0 || r > this.length) && (r = this.length), r <= 0) || (r >>>= 0, e >>>= 0, r <= e))
      return "";
    for (t || (t = "utf8"); ; )
      switch (t) {
        case "hex":
          return ef(this, e, r);
        case "utf8":
        case "utf-8":
          return Wo(this, e, r);
        case "ascii":
          return Zc(this, e, r);
        case "latin1":
        case "binary":
          return Kc(this, e, r);
        case "base64":
          return Yc(this, e, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return tf(this, e, r);
        default:
          if (n)
            throw new TypeError("Unknown encoding: " + t);
          t = (t + "").toLowerCase(), n = true;
      }
  }
  f.prototype._isBuffer = true;
  function We(t, e, r) {
    let n = t[e];
    t[e] = t[r], t[r] = n;
  }
  f.prototype.swap16 = function() {
    let e = this.length;
    if (e % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let r = 0; r < e; r += 2)
      We(this, r, r + 1);
    return this;
  };
  f.prototype.swap32 = function() {
    let e = this.length;
    if (e % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let r = 0; r < e; r += 4)
      We(this, r, r + 3), We(this, r + 1, r + 2);
    return this;
  };
  f.prototype.swap64 = function() {
    let e = this.length;
    if (e % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let r = 0; r < e; r += 8)
      We(this, r, r + 7), We(this, r + 1, r + 6), We(this, r + 2, r + 5), We(this, r + 3, r + 4);
    return this;
  };
  f.prototype.toString = function() {
    let e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? Wo(this, 0, e) : jc.apply(this, arguments);
  };
  f.prototype.toLocaleString = f.prototype.toString;
  f.prototype.equals = function(e) {
    if (!f.isBuffer(e))
      throw new TypeError("Argument must be a Buffer");
    return this === e ? true : f.compare(this, e) === 0;
  };
  f.prototype.inspect = function() {
    let e = "", r = st.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (e += " ... "), "<Buffer " + e + ">";
  };
  Mo && (f.prototype[Mo] = f.prototype.inspect);
  f.prototype.compare = function(e, r, n, o, i2) {
    if (be(e, Uint8Array) && (e = f.from(e, e.offset, e.byteLength)), !f.isBuffer(e))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
    if (r === void 0 && (r = 0), n === void 0 && (n = e ? e.length : 0), o === void 0 && (o = 0), i2 === void 0 && (i2 = this.length), r < 0 || n > e.length || o < 0 || i2 > this.length)
      throw new RangeError("out of range index");
    if (o >= i2 && r >= n)
      return 0;
    if (o >= i2)
      return -1;
    if (r >= n)
      return 1;
    if (r >>>= 0, n >>>= 0, o >>>= 0, i2 >>>= 0, this === e)
      return 0;
    let s = i2 - o, u = n - r, h = Math.min(s, u), w = this.slice(o, i2), c = e.slice(r, n);
    for (let g = 0; g < h; ++g)
      if (w[g] !== c[g]) {
        s = w[g], u = c[g];
        break;
      }
    return s < u ? -1 : u < s ? 1 : 0;
  };
  function Go(t, e, r, n, o) {
    if (t.length === 0)
      return -1;
    if (typeof r == "string" ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, on2(r) && (r = o ? 0 : t.length - 1), r < 0 && (r = t.length + r), r >= t.length) {
      if (o)
        return -1;
      r = t.length - 1;
    } else if (r < 0)
      if (o)
        r = 0;
      else
        return -1;
    if (typeof e == "string" && (e = f.from(e, n)), f.isBuffer(e))
      return e.length === 0 ? -1 : Oo(t, e, r, n, o);
    if (typeof e == "number")
      return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? o ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : Oo(t, [e], r, n, o);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Oo(t, e, r, n, o) {
    let i2 = 1, s = t.length, u = e.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (t.length < 2 || e.length < 2)
        return -1;
      i2 = 2, s /= 2, u /= 2, r /= 2;
    }
    function h(c, g) {
      return i2 === 1 ? c[g] : c.readUInt16BE(g * i2);
    }
    let w;
    if (o) {
      let c = -1;
      for (w = r; w < s; w++)
        if (h(t, w) === h(e, c === -1 ? 0 : w - c)) {
          if (c === -1 && (c = w), w - c + 1 === u)
            return c * i2;
        } else
          c !== -1 && (w -= w - c), c = -1;
    } else
      for (r + u > s && (r = s - u), w = r; w >= 0; w--) {
        let c = true;
        for (let g = 0; g < u; g++)
          if (h(t, w + g) !== h(e, g)) {
            c = false;
            break;
          }
        if (c)
          return w;
      }
    return -1;
  }
  f.prototype.includes = function(e, r, n) {
    return this.indexOf(e, r, n) !== -1;
  };
  f.prototype.indexOf = function(e, r, n) {
    return Go(this, e, r, n, true);
  };
  f.prototype.lastIndexOf = function(e, r, n) {
    return Go(this, e, r, n, false);
  };
  function Vc(t, e, r, n) {
    r = Number(r) || 0;
    let o = t.length - r;
    n ? (n = Number(n), n > o && (n = o)) : n = o;
    let i2 = e.length;
    n > i2 / 2 && (n = i2 / 2);
    let s;
    for (s = 0; s < n; ++s) {
      let u = parseInt(e.substr(s * 2, 2), 16);
      if (on2(u))
        return s;
      t[r + s] = u;
    }
    return s;
  }
  function Gc(t, e, r, n) {
    return sr(en(e, t.length - r), t, r, n);
  }
  function Wc(t, e, r, n) {
    return sr(sf(e), t, r, n);
  }
  function Jc(t, e, r, n) {
    return sr(ei(e), t, r, n);
  }
  function Xc(t, e, r, n) {
    return sr(af(e, t.length - r), t, r, n);
  }
  f.prototype.write = function(e, r, n, o) {
    if (r === void 0)
      o = "utf8", n = this.length, r = 0;
    else if (n === void 0 && typeof r == "string")
      o = r, n = this.length, r = 0;
    else if (isFinite(r))
      r = r >>> 0, isFinite(n) ? (n = n >>> 0, o === void 0 && (o = "utf8")) : (o = n, n = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let i2 = this.length - r;
    if ((n === void 0 || n > i2) && (n = i2), e.length > 0 && (n < 0 || r < 0) || r > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    o || (o = "utf8");
    let s = false;
    for (; ; )
      switch (o) {
        case "hex":
          return Vc(this, e, r, n);
        case "utf8":
        case "utf-8":
          return Gc(this, e, r, n);
        case "ascii":
        case "latin1":
        case "binary":
          return Wc(this, e, r, n);
        case "base64":
          return Jc(this, e, r, n);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Xc(this, e, r, n);
        default:
          if (s)
            throw new TypeError("Unknown encoding: " + o);
          o = ("" + o).toLowerCase(), s = true;
      }
  };
  f.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Yc(t, e, r) {
    return e === 0 && r === t.length ? Qr.fromByteArray(t) : Qr.fromByteArray(t.slice(e, r));
  }
  function Wo(t, e, r) {
    r = Math.min(t.length, r);
    let n = [], o = e;
    for (; o < r; ) {
      let i2 = t[o], s = null, u = i2 > 239 ? 4 : i2 > 223 ? 3 : i2 > 191 ? 2 : 1;
      if (o + u <= r) {
        let h, w, c, g;
        switch (u) {
          case 1:
            i2 < 128 && (s = i2);
            break;
          case 2:
            h = t[o + 1], (h & 192) === 128 && (g = (i2 & 31) << 6 | h & 63, g > 127 && (s = g));
            break;
          case 3:
            h = t[o + 1], w = t[o + 2], (h & 192) === 128 && (w & 192) === 128 && (g = (i2 & 15) << 12 | (h & 63) << 6 | w & 63, g > 2047 && (g < 55296 || g > 57343) && (s = g));
            break;
          case 4:
            h = t[o + 1], w = t[o + 2], c = t[o + 3], (h & 192) === 128 && (w & 192) === 128 && (c & 192) === 128 && (g = (i2 & 15) << 18 | (h & 63) << 12 | (w & 63) << 6 | c & 63, g > 65535 && g < 1114112 && (s = g));
        }
      }
      s === null ? (s = 65533, u = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), o += u;
    }
    return Qc(n);
  }
  var zo = 4096;
  function Qc(t) {
    let e = t.length;
    if (e <= zo)
      return String.fromCharCode.apply(String, t);
    let r = "", n = 0;
    for (; n < e; )
      r += String.fromCharCode.apply(String, t.slice(n, n += zo));
    return r;
  }
  function Zc(t, e, r) {
    let n = "";
    r = Math.min(t.length, r);
    for (let o = e; o < r; ++o)
      n += String.fromCharCode(t[o] & 127);
    return n;
  }
  function Kc(t, e, r) {
    let n = "";
    r = Math.min(t.length, r);
    for (let o = e; o < r; ++o)
      n += String.fromCharCode(t[o]);
    return n;
  }
  function ef(t, e, r) {
    let n = t.length;
    (!e || e < 0) && (e = 0), (!r || r < 0 || r > n) && (r = n);
    let o = "";
    for (let i2 = e; i2 < r; ++i2)
      o += uf[t[i2]];
    return o;
  }
  function tf(t, e, r) {
    let n = t.slice(e, r), o = "";
    for (let i2 = 0; i2 < n.length - 1; i2 += 2)
      o += String.fromCharCode(n[i2] + n[i2 + 1] * 256);
    return o;
  }
  f.prototype.slice = function(e, r) {
    let n = this.length;
    e = ~~e, r = r === void 0 ? n : ~~r, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), r < 0 ? (r += n, r < 0 && (r = 0)) : r > n && (r = n), r < e && (r = e);
    let o = this.subarray(e, r);
    return Object.setPrototypeOf(o, f.prototype), o;
  };
  function O(t, e, r) {
    if (t % 1 !== 0 || t < 0)
      throw new RangeError("offset is not uint");
    if (t + e > r)
      throw new RangeError("Trying to access beyond buffer length");
  }
  f.prototype.readUintLE = f.prototype.readUIntLE = function(e, r, n) {
    e = e >>> 0, r = r >>> 0, n || O(e, r, this.length);
    let o = this[e], i2 = 1, s = 0;
    for (; ++s < r && (i2 *= 256); )
      o += this[e + s] * i2;
    return o;
  };
  f.prototype.readUintBE = f.prototype.readUIntBE = function(e, r, n) {
    e = e >>> 0, r = r >>> 0, n || O(e, r, this.length);
    let o = this[e + --r], i2 = 1;
    for (; r > 0 && (i2 *= 256); )
      o += this[e + --r] * i2;
    return o;
  };
  f.prototype.readUint8 = f.prototype.readUInt8 = function(e, r) {
    return e = e >>> 0, r || O(e, 1, this.length), this[e];
  };
  f.prototype.readUint16LE = f.prototype.readUInt16LE = function(e, r) {
    return e = e >>> 0, r || O(e, 2, this.length), this[e] | this[e + 1] << 8;
  };
  f.prototype.readUint16BE = f.prototype.readUInt16BE = function(e, r) {
    return e = e >>> 0, r || O(e, 2, this.length), this[e] << 8 | this[e + 1];
  };
  f.prototype.readUint32LE = f.prototype.readUInt32LE = function(e, r) {
    return e = e >>> 0, r || O(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  };
  f.prototype.readUint32BE = f.prototype.readUInt32BE = function(e, r) {
    return e = e >>> 0, r || O(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  };
  f.prototype.readBigUInt64LE = _e(function(e) {
    e = e >>> 0, it(e, "offset");
    let r = this[e], n = this[e + 7];
    (r === void 0 || n === void 0) && $t(e, this.length - 8);
    let o = r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, i2 = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
    return BigInt(o) + (BigInt(i2) << BigInt(32));
  });
  f.prototype.readBigUInt64BE = _e(function(e) {
    e = e >>> 0, it(e, "offset");
    let r = this[e], n = this[e + 7];
    (r === void 0 || n === void 0) && $t(e, this.length - 8);
    let o = r * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], i2 = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
    return (BigInt(o) << BigInt(32)) + BigInt(i2);
  });
  f.prototype.readIntLE = function(e, r, n) {
    e = e >>> 0, r = r >>> 0, n || O(e, r, this.length);
    let o = this[e], i2 = 1, s = 0;
    for (; ++s < r && (i2 *= 256); )
      o += this[e + s] * i2;
    return i2 *= 128, o >= i2 && (o -= Math.pow(2, 8 * r)), o;
  };
  f.prototype.readIntBE = function(e, r, n) {
    e = e >>> 0, r = r >>> 0, n || O(e, r, this.length);
    let o = r, i2 = 1, s = this[e + --o];
    for (; o > 0 && (i2 *= 256); )
      s += this[e + --o] * i2;
    return i2 *= 128, s >= i2 && (s -= Math.pow(2, 8 * r)), s;
  };
  f.prototype.readInt8 = function(e, r) {
    return e = e >>> 0, r || O(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  };
  f.prototype.readInt16LE = function(e, r) {
    e = e >>> 0, r || O(e, 2, this.length);
    let n = this[e] | this[e + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  f.prototype.readInt16BE = function(e, r) {
    e = e >>> 0, r || O(e, 2, this.length);
    let n = this[e + 1] | this[e] << 8;
    return n & 32768 ? n | 4294901760 : n;
  };
  f.prototype.readInt32LE = function(e, r) {
    return e = e >>> 0, r || O(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  };
  f.prototype.readInt32BE = function(e, r) {
    return e = e >>> 0, r || O(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  };
  f.prototype.readBigInt64LE = _e(function(e) {
    e = e >>> 0, it(e, "offset");
    let r = this[e], n = this[e + 7];
    (r === void 0 || n === void 0) && $t(e, this.length - 8);
    let o = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
    return (BigInt(o) << BigInt(32)) + BigInt(r + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  });
  f.prototype.readBigInt64BE = _e(function(e) {
    e = e >>> 0, it(e, "offset");
    let r = this[e], n = this[e + 7];
    (r === void 0 || n === void 0) && $t(e, this.length - 8);
    let o = (r << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(o) << BigInt(32)) + BigInt(this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n);
  });
  f.prototype.readFloatLE = function(e, r) {
    return e = e >>> 0, r || O(e, 4, this.length), ot.read(this, e, true, 23, 4);
  };
  f.prototype.readFloatBE = function(e, r) {
    return e = e >>> 0, r || O(e, 4, this.length), ot.read(this, e, false, 23, 4);
  };
  f.prototype.readDoubleLE = function(e, r) {
    return e = e >>> 0, r || O(e, 8, this.length), ot.read(this, e, true, 52, 8);
  };
  f.prototype.readDoubleBE = function(e, r) {
    return e = e >>> 0, r || O(e, 8, this.length), ot.read(this, e, false, 52, 8);
  };
  function X(t, e, r, n, o, i2) {
    if (!f.isBuffer(t))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > o || e < i2)
      throw new RangeError('"value" argument is out of bounds');
    if (r + n > t.length)
      throw new RangeError("Index out of range");
  }
  f.prototype.writeUintLE = f.prototype.writeUIntLE = function(e, r, n, o) {
    if (e = +e, r = r >>> 0, n = n >>> 0, !o) {
      let u = Math.pow(2, 8 * n) - 1;
      X(this, e, r, n, u, 0);
    }
    let i2 = 1, s = 0;
    for (this[r] = e & 255; ++s < n && (i2 *= 256); )
      this[r + s] = e / i2 & 255;
    return r + n;
  };
  f.prototype.writeUintBE = f.prototype.writeUIntBE = function(e, r, n, o) {
    if (e = +e, r = r >>> 0, n = n >>> 0, !o) {
      let u = Math.pow(2, 8 * n) - 1;
      X(this, e, r, n, u, 0);
    }
    let i2 = n - 1, s = 1;
    for (this[r + i2] = e & 255; --i2 >= 0 && (s *= 256); )
      this[r + i2] = e / s & 255;
    return r + n;
  };
  f.prototype.writeUint8 = f.prototype.writeUInt8 = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 1, 255, 0), this[r] = e & 255, r + 1;
  };
  f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 2, 65535, 0), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
  };
  f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 2, 65535, 0), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
  };
  f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 4, 4294967295, 0), this[r + 3] = e >>> 24, this[r + 2] = e >>> 16, this[r + 1] = e >>> 8, this[r] = e & 255, r + 4;
  };
  f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 4, 4294967295, 0), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
  };
  function Jo(t, e, r, n, o) {
    Ko(e, n, o, t, r, 7);
    let i2 = Number(e & BigInt(4294967295));
    t[r++] = i2, i2 = i2 >> 8, t[r++] = i2, i2 = i2 >> 8, t[r++] = i2, i2 = i2 >> 8, t[r++] = i2;
    let s = Number(e >> BigInt(32) & BigInt(4294967295));
    return t[r++] = s, s = s >> 8, t[r++] = s, s = s >> 8, t[r++] = s, s = s >> 8, t[r++] = s, r;
  }
  function Xo(t, e, r, n, o) {
    Ko(e, n, o, t, r, 7);
    let i2 = Number(e & BigInt(4294967295));
    t[r + 7] = i2, i2 = i2 >> 8, t[r + 6] = i2, i2 = i2 >> 8, t[r + 5] = i2, i2 = i2 >> 8, t[r + 4] = i2;
    let s = Number(e >> BigInt(32) & BigInt(4294967295));
    return t[r + 3] = s, s = s >> 8, t[r + 2] = s, s = s >> 8, t[r + 1] = s, s = s >> 8, t[r] = s, r + 8;
  }
  f.prototype.writeBigUInt64LE = _e(function(e, r = 0) {
    return Jo(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  f.prototype.writeBigUInt64BE = _e(function(e, r = 0) {
    return Xo(this, e, r, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  f.prototype.writeIntLE = function(e, r, n, o) {
    if (e = +e, r = r >>> 0, !o) {
      let h = Math.pow(2, 8 * n - 1);
      X(this, e, r, n, h - 1, -h);
    }
    let i2 = 0, s = 1, u = 0;
    for (this[r] = e & 255; ++i2 < n && (s *= 256); )
      e < 0 && u === 0 && this[r + i2 - 1] !== 0 && (u = 1), this[r + i2] = (e / s >> 0) - u & 255;
    return r + n;
  };
  f.prototype.writeIntBE = function(e, r, n, o) {
    if (e = +e, r = r >>> 0, !o) {
      let h = Math.pow(2, 8 * n - 1);
      X(this, e, r, n, h - 1, -h);
    }
    let i2 = n - 1, s = 1, u = 0;
    for (this[r + i2] = e & 255; --i2 >= 0 && (s *= 256); )
      e < 0 && u === 0 && this[r + i2 + 1] !== 0 && (u = 1), this[r + i2] = (e / s >> 0) - u & 255;
    return r + n;
  };
  f.prototype.writeInt8 = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[r] = e & 255, r + 1;
  };
  f.prototype.writeInt16LE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 2, 32767, -32768), this[r] = e & 255, this[r + 1] = e >>> 8, r + 2;
  };
  f.prototype.writeInt16BE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 2, 32767, -32768), this[r] = e >>> 8, this[r + 1] = e & 255, r + 2;
  };
  f.prototype.writeInt32LE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 4, 2147483647, -2147483648), this[r] = e & 255, this[r + 1] = e >>> 8, this[r + 2] = e >>> 16, this[r + 3] = e >>> 24, r + 4;
  };
  f.prototype.writeInt32BE = function(e, r, n) {
    return e = +e, r = r >>> 0, n || X(this, e, r, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), this[r] = e >>> 24, this[r + 1] = e >>> 16, this[r + 2] = e >>> 8, this[r + 3] = e & 255, r + 4;
  };
  f.prototype.writeBigInt64LE = _e(function(e, r = 0) {
    return Jo(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  f.prototype.writeBigInt64BE = _e(function(e, r = 0) {
    return Xo(this, e, r, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function Yo(t, e, r, n, o, i2) {
    if (r + n > t.length)
      throw new RangeError("Index out of range");
    if (r < 0)
      throw new RangeError("Index out of range");
  }
  function Qo(t, e, r, n, o) {
    return e = +e, r = r >>> 0, o || Yo(t, e, r, 4), ot.write(t, e, r, n, 23, 4), r + 4;
  }
  f.prototype.writeFloatLE = function(e, r, n) {
    return Qo(this, e, r, true, n);
  };
  f.prototype.writeFloatBE = function(e, r, n) {
    return Qo(this, e, r, false, n);
  };
  function Zo(t, e, r, n, o) {
    return e = +e, r = r >>> 0, o || Yo(t, e, r, 8), ot.write(t, e, r, n, 52, 8), r + 8;
  }
  f.prototype.writeDoubleLE = function(e, r, n) {
    return Zo(this, e, r, true, n);
  };
  f.prototype.writeDoubleBE = function(e, r, n) {
    return Zo(this, e, r, false, n);
  };
  f.prototype.copy = function(e, r, n, o) {
    if (!f.isBuffer(e))
      throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !o && o !== 0 && (o = this.length), r >= e.length && (r = e.length), r || (r = 0), o > 0 && o < n && (o = n), o === n || e.length === 0 || this.length === 0)
      return 0;
    if (r < 0)
      throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length)
      throw new RangeError("Index out of range");
    if (o < 0)
      throw new RangeError("sourceEnd out of bounds");
    o > this.length && (o = this.length), e.length - r < o - n && (o = e.length - r + n);
    let i2 = o - n;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(r, n, o) : Uint8Array.prototype.set.call(e, this.subarray(n, o), r), i2;
  };
  f.prototype.fill = function(e, r, n, o) {
    if (typeof e == "string") {
      if (typeof r == "string" ? (o = r, r = 0, n = this.length) : typeof n == "string" && (o = n, n = this.length), o !== void 0 && typeof o != "string")
        throw new TypeError("encoding must be a string");
      if (typeof o == "string" && !f.isEncoding(o))
        throw new TypeError("Unknown encoding: " + o);
      if (e.length === 1) {
        let s = e.charCodeAt(0);
        (o === "utf8" && s < 128 || o === "latin1") && (e = s);
      }
    } else
      typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (r < 0 || this.length < r || this.length < n)
      throw new RangeError("Out of range index");
    if (n <= r)
      return this;
    r = r >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
    let i2;
    if (typeof e == "number")
      for (i2 = r; i2 < n; ++i2)
        this[i2] = e;
    else {
      let s = f.isBuffer(e) ? e : f.from(e, o), u = s.length;
      if (u === 0)
        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (i2 = 0; i2 < n - r; ++i2)
        this[i2 + r] = s[i2 % u];
    }
    return this;
  };
  var nt = {};
  function nn(t, e, r) {
    nt[t] = class extends r {
      constructor() {
        super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t}]`, this.stack, delete this.name;
      }
      get code() {
        return t;
      }
      set code(o) {
        Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: o, writable: true });
      }
      toString() {
        return `${this.name} [${t}]: ${this.message}`;
      }
    };
  }
  nn("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
    return t ? `${t} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  nn("ERR_INVALID_ARG_TYPE", function(t, e) {
    return `The "${t}" argument must be of type number. Received type ${typeof e}`;
  }, TypeError);
  nn("ERR_OUT_OF_RANGE", function(t, e, r) {
    let n = `The value of "${t}" is out of range.`, o = r;
    return Number.isInteger(r) && Math.abs(r) > 2 ** 32 ? o = qo(String(r)) : typeof r == "bigint" && (o = String(r), (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (o = qo(o)), o += "n"), n += ` It must be ${e}. Received ${o}`, n;
  }, RangeError);
  function qo(t) {
    let e = "", r = t.length, n = t[0] === "-" ? 1 : 0;
    for (; r >= n + 4; r -= 3)
      e = `_${t.slice(r - 3, r)}${e}`;
    return `${t.slice(0, r)}${e}`;
  }
  function rf(t, e, r) {
    it(e, "offset"), (t[e] === void 0 || t[e + r] === void 0) && $t(e, t.length - (r + 1));
  }
  function Ko(t, e, r, n, o, i2) {
    if (t > r || t < e) {
      let s = typeof e == "bigint" ? "n" : "", u;
      throw i2 > 3 ? e === 0 || e === BigInt(0) ? u = `>= 0${s} and < 2${s} ** ${(i2 + 1) * 8}${s}` : u = `>= -(2${s} ** ${(i2 + 1) * 8 - 1}${s}) and < 2 ** ${(i2 + 1) * 8 - 1}${s}` : u = `>= ${e}${s} and <= ${r}${s}`, new nt.ERR_OUT_OF_RANGE("value", u, t);
    }
    rf(n, o, i2);
  }
  function it(t, e) {
    if (typeof t != "number")
      throw new nt.ERR_INVALID_ARG_TYPE(e, "number", t);
  }
  function $t(t, e, r) {
    throw Math.floor(t) !== t ? (it(t, r), new nt.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : e < 0 ? new nt.ERR_BUFFER_OUT_OF_BOUNDS() : new nt.ERR_OUT_OF_RANGE(r || "offset", `>= ${r ? 1 : 0} and <= ${e}`, t);
  }
  var nf = /[^+/0-9A-Za-z-_]/g;
  function of(t) {
    if (t = t.split("=")[0], t = t.trim().replace(nf, ""), t.length < 2)
      return "";
    for (; t.length % 4 !== 0; )
      t = t + "=";
    return t;
  }
  function en(t, e) {
    e = e || 1 / 0;
    let r, n = t.length, o = null, i2 = [];
    for (let s = 0; s < n; ++s) {
      if (r = t.charCodeAt(s), r > 55295 && r < 57344) {
        if (!o) {
          if (r > 56319) {
            (e -= 3) > -1 && i2.push(239, 191, 189);
            continue;
          } else if (s + 1 === n) {
            (e -= 3) > -1 && i2.push(239, 191, 189);
            continue;
          }
          o = r;
          continue;
        }
        if (r < 56320) {
          (e -= 3) > -1 && i2.push(239, 191, 189), o = r;
          continue;
        }
        r = (o - 55296 << 10 | r - 56320) + 65536;
      } else
        o && (e -= 3) > -1 && i2.push(239, 191, 189);
      if (o = null, r < 128) {
        if ((e -= 1) < 0)
          break;
        i2.push(r);
      } else if (r < 2048) {
        if ((e -= 2) < 0)
          break;
        i2.push(r >> 6 | 192, r & 63 | 128);
      } else if (r < 65536) {
        if ((e -= 3) < 0)
          break;
        i2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
      } else if (r < 1114112) {
        if ((e -= 4) < 0)
          break;
        i2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return i2;
  }
  function sf(t) {
    let e = [];
    for (let r = 0; r < t.length; ++r)
      e.push(t.charCodeAt(r) & 255);
    return e;
  }
  function af(t, e) {
    let r, n, o, i2 = [];
    for (let s = 0; s < t.length && !((e -= 2) < 0); ++s)
      r = t.charCodeAt(s), n = r >> 8, o = r % 256, i2.push(o), i2.push(n);
    return i2;
  }
  function ei(t) {
    return Qr.toByteArray(of(t));
  }
  function sr(t, e, r, n) {
    let o;
    for (o = 0; o < n && !(o + r >= e.length || o >= t.length); ++o)
      e[o + r] = t[o];
    return o;
  }
  function be(t, e) {
    return t instanceof e || t != null && t.constructor != null && t.constructor.name != null && t.constructor.name === e.name;
  }
  function on2(t) {
    return t !== t;
  }
  var uf = function() {
    let t = "0123456789abcdef", e = new Array(256);
    for (let r = 0; r < 16; ++r) {
      let n = r * 16;
      for (let o = 0; o < 16; ++o)
        e[n + o] = t[r] + t[o];
    }
    return e;
  }();
  function _e(t) {
    return typeof BigInt > "u" ? cf : t;
  }
  function cf() {
    throw new Error("BigInt not supported");
  }
});
var si = S((Yh, ii) => {
  a();
  var N = ii.exports = {}, Ee, xe;
  function sn() {
    throw new Error("setTimeout has not been defined");
  }
  function an() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      typeof setTimeout == "function" ? Ee = setTimeout : Ee = sn;
    } catch {
      Ee = sn;
    }
    try {
      typeof clearTimeout == "function" ? xe = clearTimeout : xe = an;
    } catch {
      xe = an;
    }
  })();
  function ri(t) {
    if (Ee === setTimeout)
      return setTimeout(t, 0);
    if ((Ee === sn || !Ee) && setTimeout)
      return Ee = setTimeout, setTimeout(t, 0);
    try {
      return Ee(t, 0);
    } catch {
      try {
        return Ee.call(null, t, 0);
      } catch {
        return Ee.call(this, t, 0);
      }
    }
  }
  function ff(t) {
    if (xe === clearTimeout)
      return clearTimeout(t);
    if ((xe === an || !xe) && clearTimeout)
      return xe = clearTimeout, clearTimeout(t);
    try {
      return xe(t);
    } catch {
      try {
        return xe.call(null, t);
      } catch {
        return xe.call(this, t);
      }
    }
  }
  var Te = [], at = false, Je, ar = -1;
  function lf() {
    !at || !Je || (at = false, Je.length ? Te = Je.concat(Te) : ar = -1, Te.length && ni());
  }
  function ni() {
    if (!at) {
      var t = ri(lf);
      at = true;
      for (var e = Te.length; e; ) {
        for (Je = Te, Te = []; ++ar < e; )
          Je && Je[ar].run();
        ar = -1, e = Te.length;
      }
      Je = null, at = false, ff(t);
    }
  }
  N.nextTick = function(t) {
    var e = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r = 1; r < arguments.length; r++)
        e[r - 1] = arguments[r];
    Te.push(new oi(t, e)), Te.length === 1 && !at && ri(ni);
  };
  function oi(t, e) {
    this.fun = t, this.array = e;
  }
  oi.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  N.title = "browser";
  N.browser = true;
  N.env = {};
  N.argv = [];
  N.version = "";
  N.versions = {};
  function Ie() {
  }
  N.on = Ie;
  N.addListener = Ie;
  N.once = Ie;
  N.off = Ie;
  N.removeListener = Ie;
  N.removeAllListeners = Ie;
  N.emit = Ie;
  N.prependListener = Ie;
  N.prependOnceListener = Ie;
  N.listeners = function(t) {
    return [];
  };
  N.binding = function(t) {
    throw new Error("process.binding is not supported");
  };
  N.cwd = function() {
    return "/";
  };
  N.chdir = function(t) {
    throw new Error("process.chdir is not supported");
  };
  N.umask = function() {
    return 0;
  };
});
var p, d, a = F(() => {
  ti().Buffer, p = si(), d = globalThis;
  globalThis && globalThis.process && globalThis.process.env && (globalThis.process.env.LIBP2P_FORCE_PNET = false);
});
function ci(t, e, r) {
  e = e || [], r = r || 0;
  for (var n = r; t >= mf; )
    e[r++] = t & 255 | ai, t /= 128;
  for (; t & pf; )
    e[r++] = t & 255 | ai, t >>>= 7;
  return e[r] = t | 0, ci.bytes = r - n + 1, e;
}
function un(t, n) {
  var r = 0, n = n || 0, o = 0, i2 = n, s, u = t.length;
  do {
    if (i2 >= u)
      throw un.bytes = 0, new RangeError("Could not decode varint");
    s = t[i2++], r += o < 28 ? (s & ui) << o : (s & ui) * Math.pow(2, o), o += 7;
  } while (s >= wf);
  return un.bytes = i2 - n, r;
}
var df, ai, hf, pf, mf, yf, wf, ui, gf, Df, bf, Ef, xf, Cf, Bf, Af, Tf, If, Sf, Uf, Lt, fi = F(() => {
  a();
  df = ci, ai = 128, hf = 127, pf = ~hf, mf = Math.pow(2, 31);
  yf = un, wf = 128, ui = 127;
  gf = Math.pow(2, 7), Df = Math.pow(2, 14), bf = Math.pow(2, 21), Ef = Math.pow(2, 28), xf = Math.pow(2, 35), Cf = Math.pow(2, 42), Bf = Math.pow(2, 49), Af = Math.pow(2, 56), Tf = Math.pow(2, 63), If = function(t) {
    return t < gf ? 1 : t < Df ? 2 : t < bf ? 3 : t < Ef ? 4 : t < xf ? 5 : t < Cf ? 6 : t < Bf ? 7 : t < Af ? 8 : t < Tf ? 9 : 10;
  }, Sf = { encode: df, decode: yf, encodingLength: If }, Uf = Sf, Lt = Uf;
});
var Pt, ut, ct, cr = F(() => {
  a();
  fi();
  Pt = (t) => [Lt.decode(t), Lt.decode.bytes], ut = (t, e, r = 0) => (Lt.encode(t, e, r), e), ct = (t) => Lt.encodingLength(t);
});
var li, Se, di, hi, Ne = F(() => {
  a();
  li = (t, e) => {
    if (t === e)
      return true;
    if (t.byteLength !== e.byteLength)
      return false;
    for (let r = 0; r < t.byteLength; r++)
      if (t[r] !== e[r])
        return false;
    return true;
  }, Se = (t) => {
    if (t instanceof Uint8Array && t.constructor.name === "Uint8Array")
      return t;
    if (t instanceof ArrayBuffer)
      return new Uint8Array(t);
    if (ArrayBuffer.isView(t))
      return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
    throw new Error("Unknown type, must be binary type");
  }, di = (t) => new TextEncoder().encode(t), hi = (t) => new TextDecoder().decode(t);
});
var Ue = {};
M(Ue, { Digest: () => Xe, create: () => $e, decode: () => ft, equals: () => fn });
var $e, ft, fn, Xe, Le = F(() => {
  a();
  Ne();
  cr();
  $e = (t, e) => {
    let r = e.byteLength, n = ct(t), o = n + ct(r), i2 = new Uint8Array(o + r);
    return ut(t, i2, 0), ut(r, i2, n), i2.set(e, o), new Xe(t, r, e, i2);
  }, ft = (t) => {
    let e = Se(t), [r, n] = Pt(e), [o, i2] = Pt(e.subarray(n)), s = e.subarray(n + i2);
    if (s.byteLength !== o)
      throw new Error("Incorrect length");
    return new Xe(r, o, s, e);
  }, fn = (t, e) => t === e ? true : t.code === e.code && t.size === e.size && li(t.bytes, e.bytes), Xe = class {
    constructor(e, r, n, o) {
      this.code = e, this.size = r, this.digest = n, this.bytes = o;
    }
  };
});
function Ff(t, e) {
  if (t.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var r = new Uint8Array(256), n = 0; n < r.length; n++)
    r[n] = 255;
  for (var o = 0; o < t.length; o++) {
    var i2 = t.charAt(o), s = i2.charCodeAt(0);
    if (r[s] !== 255)
      throw new TypeError(i2 + " is ambiguous");
    r[s] = o;
  }
  var u = t.length, h = t.charAt(0), w = Math.log(u) / Math.log(256), c = Math.log(256) / Math.log(u);
  function g(I) {
    if (I instanceof Uint8Array || (ArrayBuffer.isView(I) ? I = new Uint8Array(I.buffer, I.byteOffset, I.byteLength) : Array.isArray(I) && (I = Uint8Array.from(I))), !(I instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (I.length === 0)
      return "";
    for (var v = 0, $ = 0, P = 0, W = I.length; P !== W && I[P] === 0; )
      P++, v++;
    for (var ie = (W - P) * c + 1 >>> 0, q = new Uint8Array(ie); P !== W; ) {
      for (var he = I[P], se = 0, K = ie - 1; (he !== 0 || se < $) && K !== -1; K--, se++)
        he += 256 * q[K] >>> 0, q[K] = he % u >>> 0, he = he / u >>> 0;
      if (he !== 0)
        throw new Error("Non-zero carry");
      $ = se, P++;
    }
    for (var ae = ie - $; ae !== ie && q[ae] === 0; )
      ae++;
    for (var rt = h.repeat(v); ae < ie; ++ae)
      rt += t.charAt(q[ae]);
    return rt;
  }
  function B(I) {
    if (typeof I != "string")
      throw new TypeError("Expected String");
    if (I.length === 0)
      return new Uint8Array();
    var v = 0;
    if (I[v] !== " ") {
      for (var $ = 0, P = 0; I[v] === h; )
        $++, v++;
      for (var W = (I.length - v) * w + 1 >>> 0, ie = new Uint8Array(W); I[v]; ) {
        var q = r[I.charCodeAt(v)];
        if (q === 255)
          return;
        for (var he = 0, se = W - 1; (q !== 0 || he < P) && se !== -1; se--, he++)
          q += u * ie[se] >>> 0, ie[se] = q % 256 >>> 0, q = q / 256 >>> 0;
        if (q !== 0)
          throw new Error("Non-zero carry");
        P = he, v++;
      }
      if (I[v] !== " ") {
        for (var K = W - P; K !== W && ie[K] === 0; )
          K++;
        for (var ae = new Uint8Array($ + (W - K)), rt = $; K !== W; )
          ae[rt++] = ie[K++];
        return ae;
      }
    }
  }
  function k(I) {
    var v = B(I);
    if (v)
      return v;
    throw new Error(`Non-${e} character`);
  }
  return { encode: g, decodeUnsafe: B, decode: k };
}
var vf, kf, pi, mi = F(() => {
  a();
  vf = Ff, kf = vf, pi = kf;
});
var ln, dn, hn, yi, pn, lt, Pe, _f, Nf, _, pe = F(() => {
  a();
  mi();
  Ne();
  ln = class {
    constructor(e, r, n) {
      this.name = e, this.prefix = r, this.baseEncode = n;
    }
    encode(e) {
      if (e instanceof Uint8Array)
        return `${this.prefix}${this.baseEncode(e)}`;
      throw Error("Unknown type, must be binary type");
    }
  }, dn = class {
    constructor(e, r, n) {
      if (this.name = e, this.prefix = r, r.codePointAt(0) === void 0)
        throw new Error("Invalid prefix character");
      this.prefixCodePoint = r.codePointAt(0), this.baseDecode = n;
    }
    decode(e) {
      if (typeof e == "string") {
        if (e.codePointAt(0) !== this.prefixCodePoint)
          throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
        return this.baseDecode(e.slice(this.prefix.length));
      } else
        throw Error("Can only multibase decode strings");
    }
    or(e) {
      return yi(this, e);
    }
  }, hn = class {
    constructor(e) {
      this.decoders = e;
    }
    or(e) {
      return yi(this, e);
    }
    decode(e) {
      let r = e[0], n = this.decoders[r];
      if (n)
        return n.decode(e);
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }, yi = (t, e) => new hn({ ...t.decoders || { [t.prefix]: t }, ...e.decoders || { [e.prefix]: e } }), pn = class {
    constructor(e, r, n, o) {
      this.name = e, this.prefix = r, this.baseEncode = n, this.baseDecode = o, this.encoder = new ln(e, r, n), this.decoder = new dn(e, r, o);
    }
    encode(e) {
      return this.encoder.encode(e);
    }
    decode(e) {
      return this.decoder.decode(e);
    }
  }, lt = ({ name: t, prefix: e, encode: r, decode: n }) => new pn(t, e, r, n), Pe = ({ prefix: t, name: e, alphabet: r }) => {
    let { encode: n, decode: o } = pi(r, e);
    return lt({ prefix: t, name: e, encode: n, decode: (i2) => Se(o(i2)) });
  }, _f = (t, e, r, n) => {
    let o = {};
    for (let c = 0; c < e.length; ++c)
      o[e[c]] = c;
    let i2 = t.length;
    for (; t[i2 - 1] === "="; )
      --i2;
    let s = new Uint8Array(i2 * r / 8 | 0), u = 0, h = 0, w = 0;
    for (let c = 0; c < i2; ++c) {
      let g = o[t[c]];
      if (g === void 0)
        throw new SyntaxError(`Non-${n} character`);
      h = h << r | g, u += r, u >= 8 && (u -= 8, s[w++] = 255 & h >> u);
    }
    if (u >= r || 255 & h << 8 - u)
      throw new SyntaxError("Unexpected end of data");
    return s;
  }, Nf = (t, e, r) => {
    let n = e[e.length - 1] === "=", o = (1 << r) - 1, i2 = "", s = 0, u = 0;
    for (let h = 0; h < t.length; ++h)
      for (u = u << 8 | t[h], s += 8; s > r; )
        s -= r, i2 += e[o & u >> s];
    if (s && (i2 += e[o & u << r - s]), n)
      for (; i2.length * r & 7; )
        i2 += "=";
    return i2;
  }, _ = ({ name: t, prefix: e, bitsPerChar: r, alphabet: n }) => lt({ prefix: e, name: t, encode(o) {
    return Nf(o, n, r);
  }, decode(o) {
    return _f(o, n, r, t);
  } });
});
var dt = {};
M(dt, { base58btc: () => Y, base58flickr: () => $f });
var Y, $f, Re = F(() => {
  a();
  pe();
  Y = Pe({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" }), $f = Pe({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
});
var Rt = {};
M(Rt, { base32: () => Me, base32hex: () => Mf, base32hexpad: () => zf, base32hexpadupper: () => qf, base32hexupper: () => Of, base32pad: () => Pf, base32padupper: () => Rf, base32upper: () => Lf, base32z: () => Hf });
var Me, Lf, Pf, Rf, Mf, Of, zf, qf, Hf, ht = F(() => {
  a();
  pe();
  Me = _({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 }), Lf = _({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 }), Pf = _({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 }), Rf = _({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 }), Mf = _({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 }), Of = _({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 }), zf = _({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 }), qf = _({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 }), Hf = _({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
});
var dr = {};
M(dr, { CID: () => x });
var x, jf, Vf, Gf, Mt, Wf, wi, gi, fr, lr, Jf, Xf, Yf, Q = F(() => {
  a();
  cr();
  Le();
  Re();
  ht();
  Ne();
  x = class {
    constructor(e, r, n, o) {
      this.code = r, this.version = e, this.multihash = n, this.bytes = o, this.byteOffset = o.byteOffset, this.byteLength = o.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, { byteOffset: lr, byteLength: lr, code: fr, version: fr, multihash: fr, bytes: fr, _baseCache: lr, asCID: lr });
    }
    toV0() {
      switch (this.version) {
        case 0:
          return this;
        default: {
          let { code: e, multihash: r } = this;
          if (e !== Mt)
            throw new Error("Cannot convert a non dag-pb CID to CIDv0");
          if (r.code !== Wf)
            throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
          return x.createV0(r);
        }
      }
    }
    toV1() {
      switch (this.version) {
        case 0: {
          let { code: e, digest: r } = this.multihash, n = $e(e, r);
          return x.createV1(this.code, n);
        }
        case 1:
          return this;
        default:
          throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
    equals(e) {
      return e && this.code === e.code && this.version === e.version && fn(this.multihash, e.multihash);
    }
    toString(e) {
      let { bytes: r, version: n, _baseCache: o } = this;
      switch (n) {
        case 0:
          return Vf(r, o, e || Y.encoder);
        default:
          return Gf(r, o, e || Me.encoder);
      }
    }
    toJSON() {
      return { code: this.code, version: this.version, hash: this.multihash.bytes };
    }
    get [Symbol.toStringTag]() {
      return "CID";
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    static isCID(e) {
      return Xf(/^0\.0/, Yf), !!(e && (e[gi] || e.asCID === e));
    }
    get toBaseEncodedString() {
      throw new Error("Deprecated, use .toString()");
    }
    get codec() {
      throw new Error('"codec" property is deprecated, use integer "code" property instead');
    }
    get buffer() {
      throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
    }
    get multibaseName() {
      throw new Error('"multibaseName" property is deprecated');
    }
    get prefix() {
      throw new Error('"prefix" property is deprecated');
    }
    static asCID(e) {
      if (e instanceof x)
        return e;
      if (e != null && e.asCID === e) {
        let { version: r, code: n, multihash: o, bytes: i2 } = e;
        return new x(r, n, o, i2 || wi(r, n, o.bytes));
      } else if (e != null && e[gi] === true) {
        let { version: r, multihash: n, code: o } = e, i2 = ft(n);
        return x.create(r, o, i2);
      } else
        return null;
    }
    static create(e, r, n) {
      if (typeof r != "number")
        throw new Error("String codecs are no longer supported");
      switch (e) {
        case 0: {
          if (r !== Mt)
            throw new Error(`Version 0 CID must use dag-pb (code: ${Mt}) block encoding`);
          return new x(e, r, n, n.bytes);
        }
        case 1: {
          let o = wi(e, r, n.bytes);
          return new x(e, r, n, o);
        }
        default:
          throw new Error("Invalid version");
      }
    }
    static createV0(e) {
      return x.create(0, Mt, e);
    }
    static createV1(e, r) {
      return x.create(1, e, r);
    }
    static decode(e) {
      let [r, n] = x.decodeFirst(e);
      if (n.length)
        throw new Error("Incorrect length");
      return r;
    }
    static decodeFirst(e) {
      let r = x.inspectBytes(e), n = r.size - r.multihashSize, o = Se(e.subarray(n, n + r.multihashSize));
      if (o.byteLength !== r.multihashSize)
        throw new Error("Incorrect length");
      let i2 = o.subarray(r.multihashSize - r.digestSize), s = new Xe(r.multihashCode, r.digestSize, i2, o);
      return [r.version === 0 ? x.createV0(s) : x.createV1(r.codec, s), e.subarray(r.size)];
    }
    static inspectBytes(e) {
      let r = 0, n = () => {
        let [g, B] = Pt(e.subarray(r));
        return r += B, g;
      }, o = n(), i2 = Mt;
      if (o === 18 ? (o = 0, r = 0) : o === 1 && (i2 = n()), o !== 0 && o !== 1)
        throw new RangeError(`Invalid CID version ${o}`);
      let s = r, u = n(), h = n(), w = r + h, c = w - s;
      return { version: o, codec: i2, multihashCode: u, digestSize: h, multihashSize: c, size: w };
    }
    static parse(e, r) {
      let [n, o] = jf(e, r), i2 = x.decode(o);
      return i2._baseCache.set(n, e), i2;
    }
  }, jf = (t, e) => {
    switch (t[0]) {
      case "Q": {
        let r = e || Y;
        return [Y.prefix, r.decode(`${Y.prefix}${t}`)];
      }
      case Y.prefix: {
        let r = e || Y;
        return [Y.prefix, r.decode(t)];
      }
      case Me.prefix: {
        let r = e || Me;
        return [Me.prefix, r.decode(t)];
      }
      default: {
        if (e == null)
          throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
        return [t[0], e.decode(t)];
      }
    }
  }, Vf = (t, e, r) => {
    let { prefix: n } = r;
    if (n !== Y.prefix)
      throw Error(`Cannot string encode V0 in ${r.name} encoding`);
    let o = e.get(n);
    if (o == null) {
      let i2 = r.encode(t).slice(1);
      return e.set(n, i2), i2;
    } else
      return o;
  }, Gf = (t, e, r) => {
    let { prefix: n } = r, o = e.get(n);
    if (o == null) {
      let i2 = r.encode(t);
      return e.set(n, i2), i2;
    } else
      return o;
  }, Mt = 112, Wf = 18, wi = (t, e, r) => {
    let n = ct(t), o = n + ct(e), i2 = new Uint8Array(o + r.byteLength);
    return ut(t, i2, 0), ut(e, i2, n), i2.set(r, o), i2;
  }, gi = Symbol.for("@ipld/js-cid/CID"), fr = { writable: false, configurable: false, enumerable: true }, lr = { writable: false, enumerable: false, configurable: false }, Jf = "0.0.0-dev", Xf = (t, e) => {
    if (t.test(Jf))
      console.warn(e);
    else
      throw new Error(e);
  }, Yf = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
});
var yn, mn, wn = F(() => {
  a();
  Le();
  yn = ({ name: t, code: e, encode: r }) => new mn(t, e, r), mn = class {
    constructor(e, r, n) {
      this.name = e, this.code = r, this.encode = n;
    }
    digest(e) {
      if (e instanceof Uint8Array) {
        let r = this.encode(e);
        return r instanceof Uint8Array ? $e(this.code, r) : r.then((n) => $e(this.code, n));
      } else
        throw Error("Unknown type, must be binary type");
    }
  };
});
var gn = F(() => {
  a();
  Q();
  cr();
  Ne();
  wn();
  Le();
});
var Ci = S((mp, xi) => {
  a();
  xi.exports = xn;
  var Ei = 128, Zf = 127, Kf = ~Zf, el = Math.pow(2, 31);
  function xn(t, e, r) {
    if (Number.MAX_SAFE_INTEGER && t > Number.MAX_SAFE_INTEGER)
      throw xn.bytes = 0, new RangeError("Could not encode varint");
    e = e || [], r = r || 0;
    for (var n = r; t >= el; )
      e[r++] = t & 255 | Ei, t /= 128;
    for (; t & Kf; )
      e[r++] = t & 255 | Ei, t >>>= 7;
    return e[r] = t | 0, xn.bytes = r - n + 1, e;
  }
});
var Ti = S((yp, Ai) => {
  a();
  Ai.exports = Cn;
  var tl = 128, Bi = 127;
  function Cn(t, n) {
    var r = 0, n = n || 0, o = 0, i2 = n, s, u = t.length;
    do {
      if (i2 >= u || o > 49)
        throw Cn.bytes = 0, new RangeError("Could not decode varint");
      s = t[i2++], r += o < 28 ? (s & Bi) << o : (s & Bi) * Math.pow(2, o), o += 7;
    } while (s >= tl);
    return Cn.bytes = i2 - n, r;
  }
});
var Si = S((wp, Ii) => {
  a();
  var rl = Math.pow(2, 7), nl = Math.pow(2, 14), ol = Math.pow(2, 21), il = Math.pow(2, 28), sl = Math.pow(2, 35), al = Math.pow(2, 42), ul = Math.pow(2, 49), cl = Math.pow(2, 56), fl = Math.pow(2, 63);
  Ii.exports = function(t) {
    return t < rl ? 1 : t < nl ? 2 : t < ol ? 3 : t < il ? 4 : t < sl ? 5 : t < al ? 6 : t < ul ? 7 : t < cl ? 8 : t < fl ? 9 : 10;
  };
});
var pt = S((gp, Ui) => {
  a();
  Ui.exports = { encode: Ci(), decode: Ti(), encodingLength: Si() };
});
var Ws = S((vm, Gs) => {
  a();
  Gs.exports = function() {
    return Date.now();
  };
});
var Xs = S((km, Js) => {
  a();
  var Ur = Ws(), Pn = class {
    constructor(e, r, n) {
      let o = this;
      this._started = Ur(), this._rescheduled = 0, this._scheduled = r, this._args = n, this._triggered = false, this._timerWrapper = () => {
        o._rescheduled > 0 ? (o._scheduled = o._rescheduled - (Ur() - o._started), o._schedule(o._scheduled)) : (o._triggered = true, e.apply(null, o._args));
      }, this._timer = setTimeout(this._timerWrapper, r);
    }
    reschedule(e) {
      e || (e = this._scheduled);
      let r = Ur();
      r + e - (this._started + this._scheduled) < 0 ? (clearTimeout(this._timer), this._schedule(e)) : this._triggered ? this._schedule(e) : (this._started = r, this._rescheduled = e);
    }
    _schedule(e) {
      this._triggered = false, this._started = Ur(), this._rescheduled = 0, this._scheduled = e, this._timer = setTimeout(this._timerWrapper, e);
    }
    clear() {
      clearTimeout(this._timer);
    }
  };
  function ed() {
    if (typeof arguments[0] != "function")
      throw new Error("callback needed");
    if (typeof arguments[1] != "number")
      throw new Error("timeout needed");
    let t;
    if (arguments.length > 0) {
      t = new Array(arguments.length - 2);
      for (var e = 0; e < t.length; e++)
        t[e] = arguments[e + 2];
    }
    return new Pn(arguments[0], arguments[1], t);
  }
  Js.exports = ed;
});
var Zs = S((_m, Qs) => {
  a();
  var { AbortController: td } = globalThis, Ys = Xs(), Gt = class extends td {
    constructor(e) {
      super(), this._ms = e, this._timer = Ys(() => this.abort(), e), Object.setPrototypeOf(this, Gt.prototype);
    }
    abort() {
      return this._timer.clear(), super.abort();
    }
    clear() {
      this._timer.clear();
    }
    reset() {
      this._timer.clear(), this._timer = Ys(() => this.abort(), this._ms);
    }
  };
  Qs.exports = { TimeoutController: Gt };
});
var ea = S((Nm, Rn) => {
  a();
  function Ks(t) {
    let e = new globalThis.AbortController();
    function r() {
      e.abort();
      for (let n of t)
        !n || !n.removeEventListener || n.removeEventListener("abort", r);
    }
    for (let n of t)
      if (!(!n || !n.addEventListener)) {
        if (n.aborted) {
          r();
          break;
        }
        n.addEventListener("abort", r);
      }
    return e.signal;
  }
  Rn.exports = Ks;
  Rn.exports.anySignal = Ks;
});
var sa = S((Om, ia) => {
  a();
  var xt = 1e3, Ct = xt * 60, Bt = Ct * 60, Ze = Bt * 24, nd = Ze * 7, od = Ze * 365.25;
  ia.exports = function(t, e) {
    e = e || {};
    var r = typeof t;
    if (r === "string" && t.length > 0)
      return id(t);
    if (r === "number" && isFinite(t))
      return e.long ? ad(t) : sd(t);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t));
  };
  function id(t) {
    if (t = String(t), !(t.length > 100)) {
      var e = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
      if (!!e) {
        var r = parseFloat(e[1]), n = (e[2] || "ms").toLowerCase();
        switch (n) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return r * od;
          case "weeks":
          case "week":
          case "w":
            return r * nd;
          case "days":
          case "day":
          case "d":
            return r * Ze;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return r * Bt;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return r * Ct;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return r * xt;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return r;
          default:
            return;
        }
      }
    }
  }
  function sd(t) {
    var e = Math.abs(t);
    return e >= Ze ? Math.round(t / Ze) + "d" : e >= Bt ? Math.round(t / Bt) + "h" : e >= Ct ? Math.round(t / Ct) + "m" : e >= xt ? Math.round(t / xt) + "s" : t + "ms";
  }
  function ad(t) {
    var e = Math.abs(t);
    return e >= Ze ? Fr(t, e, Ze, "day") : e >= Bt ? Fr(t, e, Bt, "hour") : e >= Ct ? Fr(t, e, Ct, "minute") : e >= xt ? Fr(t, e, xt, "second") : t + " ms";
  }
  function Fr(t, e, r, n) {
    var o = e >= r * 1.5;
    return Math.round(t / r) + " " + n + (o ? "s" : "");
  }
});
var ua = S((zm, aa) => {
  a();
  function ud(t) {
    r.debug = r, r.default = r, r.coerce = h, r.disable = i2, r.enable = o, r.enabled = s, r.humanize = sa(), r.destroy = w, Object.keys(t).forEach((c) => {
      r[c] = t[c];
    }), r.names = [], r.skips = [], r.formatters = {};
    function e(c) {
      let g = 0;
      for (let B = 0; B < c.length; B++)
        g = (g << 5) - g + c.charCodeAt(B), g |= 0;
      return r.colors[Math.abs(g) % r.colors.length];
    }
    r.selectColor = e;
    function r(c) {
      let g, B = null, k, I;
      function v(...$) {
        if (!v.enabled)
          return;
        let P = v, W = Number(new Date()), ie = W - (g || W);
        P.diff = ie, P.prev = g, P.curr = W, g = W, $[0] = r.coerce($[0]), typeof $[0] != "string" && $.unshift("%O");
        let q = 0;
        $[0] = $[0].replace(/%([a-zA-Z%])/g, (se, K) => {
          if (se === "%%")
            return "%";
          q++;
          let ae = r.formatters[K];
          if (typeof ae == "function") {
            let rt = $[q];
            se = ae.call(P, rt), $.splice(q, 1), q--;
          }
          return se;
        }), r.formatArgs.call(P, $), (P.log || r.log).apply(P, $);
      }
      return v.namespace = c, v.useColors = r.useColors(), v.color = r.selectColor(c), v.extend = n, v.destroy = r.destroy, Object.defineProperty(v, "enabled", { enumerable: true, configurable: false, get: () => B !== null ? B : (k !== r.namespaces && (k = r.namespaces, I = r.enabled(c)), I), set: ($) => {
        B = $;
      } }), typeof r.init == "function" && r.init(v), v;
    }
    function n(c, g) {
      let B = r(this.namespace + (typeof g > "u" ? ":" : g) + c);
      return B.log = this.log, B;
    }
    function o(c) {
      r.save(c), r.namespaces = c, r.names = [], r.skips = [];
      let g, B = (typeof c == "string" ? c : "").split(/[\s,]+/), k = B.length;
      for (g = 0; g < k; g++)
        !B[g] || (c = B[g].replace(/\*/g, ".*?"), c[0] === "-" ? r.skips.push(new RegExp("^" + c.slice(1) + "$")) : r.names.push(new RegExp("^" + c + "$")));
    }
    function i2() {
      let c = [...r.names.map(u), ...r.skips.map(u).map((g) => "-" + g)].join(",");
      return r.enable(""), c;
    }
    function s(c) {
      if (c[c.length - 1] === "*")
        return true;
      let g, B;
      for (g = 0, B = r.skips.length; g < B; g++)
        if (r.skips[g].test(c))
          return false;
      for (g = 0, B = r.names.length; g < B; g++)
        if (r.names[g].test(c))
          return true;
      return false;
    }
    function u(c) {
      return c.toString().substring(2, c.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function h(c) {
      return c instanceof Error ? c.stack || c.message : c;
    }
    function w() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return r.enable(r.load()), r;
  }
  aa.exports = ud;
});
var ca = S((oe, vr) => {
  a();
  oe.formatArgs = fd;
  oe.save = ld;
  oe.load = dd;
  oe.useColors = cd;
  oe.storage = hd();
  oe.destroy = (() => {
    let t = false;
    return () => {
      t || (t = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })();
  oe.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function cd() {
    return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? true : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? false : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function fd(t) {
    if (t[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t[0] + (this.useColors ? "%c " : " ") + "+" + vr.exports.humanize(this.diff), !this.useColors)
      return;
    let e = "color: " + this.color;
    t.splice(1, 0, e, "color: inherit");
    let r = 0, n = 0;
    t[0].replace(/%[a-zA-Z%]/g, (o) => {
      o !== "%%" && (r++, o === "%c" && (n = r));
    }), t.splice(n, 0, e);
  }
  oe.log = console.debug || console.log || (() => {
  });
  function ld(t) {
    try {
      t ? oe.storage.setItem("debug", t) : oe.storage.removeItem("debug");
    } catch {
    }
  }
  function dd() {
    let t;
    try {
      t = oe.storage.getItem("debug");
    } catch {
    }
    return !t && typeof p < "u" && "env" in p && (t = p.env.DEBUG), t;
  }
  function hd() {
    try {
      return localStorage;
    } catch {
    }
  }
  vr.exports = ua()(oe);
  var { formatters: pd } = vr.exports;
  pd.j = function(t) {
    try {
      return JSON.stringify(t);
    } catch (e) {
      return "[UnexpectedJSONParseError]: " + e.message;
    }
  };
});
var On = {};
M(On, { base64: () => Mn, base64pad: () => md, base64url: () => yd, base64urlpad: () => wd });
var Mn, md, yd, wd, zn = F(() => {
  a();
  pe();
  Mn = _({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 }), md = _({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 }), yd = _({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 }), wd = _({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
});
var fa, qn = F(() => {
  a();
  Ne();
  fa = 85;
});
var da, Hn = F(() => {
  a();
  new TextEncoder(), new TextDecoder(), da = 512;
});
var wa = S((i0, ya) => {
  a();
  var bd = async (t) => {
    for await (let e of t)
      return e;
  };
  ya.exports = bd;
});
var Da = S((s0, ga) => {
  a();
  var Ed = async (t) => {
    let e;
    for await (let r of t)
      e = r;
    return e;
  };
  ga.exports = Ed;
});
var xa = S((a0, Ea) => {
  a();
  var ba = "[a-fA-F\\d:]", je = (t) => t && t.includeBoundaries ? `(?:(?<=\\s|^)(?=${ba})|(?<=${ba})(?=\\s|$))` : "", we = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", L = "[a-fA-F\\d]{1,4}", _r = `
(?:
(?:${L}:){7}(?:${L}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${L}:){6}(?:${we}|:${L}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${L}:){5}(?::${we}|(?::${L}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${L}:){4}(?:(?::${L}){0,1}:${we}|(?::${L}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${L}:){3}(?:(?::${L}){0,2}:${we}|(?::${L}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${L}:){2}(?:(?::${L}){0,3}:${we}|(?::${L}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${L}:){1}(?:(?::${L}){0,4}:${we}|(?::${L}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${L}){0,5}:${we}|(?::${L}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), xd = new RegExp(`(?:^${we}$)|(?:^${_r}$)`), Cd = new RegExp(`^${we}$`), Bd = new RegExp(`^${_r}$`), Vn = (t) => t && t.exact ? xd : new RegExp(`(?:${je(t)}${we}${je(t)})|(?:${je(t)}${_r}${je(t)})`, "g");
  Vn.v4 = (t) => t && t.exact ? Cd : new RegExp(`${je(t)}${we}${je(t)}`, "g");
  Vn.v6 = (t) => t && t.exact ? Bd : new RegExp(`${je(t)}${_r}${je(t)}`, "g");
  Ea.exports = Vn;
});
var Ba = S((u0, Ca) => {
  a();
  var Gn = xa(), At = (t) => Gn({ exact: true }).test(t);
  At.v4 = (t) => Gn.v4({ exact: true }).test(t);
  At.v6 = (t) => Gn.v6({ exact: true }).test(t);
  At.version = (t) => At(t) ? At.v4(t) ? 4 : 6 : void 0;
  Ca.exports = At;
});
var Wn = {};
M(Wn, { identity: () => Ad });
var Ad, Aa = F(() => {
  a();
  pe();
  Ne();
  Ad = lt({ prefix: "\0", name: "identity", encode: (t) => hi(t), decode: (t) => di(t) });
});
var Jn = {};
M(Jn, { base2: () => Td });
var Td, Ta = F(() => {
  a();
  pe();
  Td = _({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
});
var Xn = {};
M(Xn, { base8: () => Id });
var Id, Ia = F(() => {
  a();
  pe();
  Id = _({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
});
var Yn = {};
M(Yn, { base10: () => Sd });
var Sd, Sa = F(() => {
  a();
  pe();
  Sd = Pe({ prefix: "9", name: "base10", alphabet: "0123456789" });
});
var Qn = {};
M(Qn, { base16: () => Ud, base16upper: () => Fd });
var Ud, Fd, Ua = F(() => {
  a();
  pe();
  Ud = _({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 }), Fd = _({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
});
var Zn = {};
M(Zn, { base36: () => vd, base36upper: () => kd });
var vd, kd, Fa = F(() => {
  a();
  pe();
  vd = Pe({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" }), kd = Pe({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
});
var Kn = {};
M(Kn, { base256emoji: () => Pd });
function $d(t) {
  return t.reduce((e, r) => (e += _d[r], e), "");
}
function Ld(t) {
  let e = [];
  for (let r of t) {
    let n = Nd[r.codePointAt(0)];
    if (n === void 0)
      throw new Error(`Non-base256emoji character: ${r}`);
    e.push(n);
  }
  return new Uint8Array(e);
}
var va, _d, Nd, Pd, ka = F(() => {
  a();
  pe();
  va = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), _d = va.reduce((t, e, r) => (t[r] = e, t), []), Nd = va.reduce((t, e, r) => (t[e.codePointAt(0)] = r, t), []);
  Pd = lt({ prefix: "\u{1F680}", name: "base256emoji", encode: $d, decode: Ld });
});
var eo = {};
M(eo, { sha256: () => Rd, sha512: () => Md });
var _a, Rd, Md, Na = F(() => {
  a();
  wn();
  _a = (t) => async (e) => new Uint8Array(await crypto.subtle.digest(t, e)), Rd = yn({ name: "sha2-256", code: 18, encode: _a("SHA-256") }), Md = yn({ name: "sha2-512", code: 19, encode: _a("SHA-512") });
});
var to = {};
M(to, { identity: () => qd });
var $a, Od, La, zd, qd, Pa = F(() => {
  a();
  Ne();
  Le();
  $a = 0, Od = "identity", La = Se, zd = (t) => $e($a, La(t)), qd = { code: $a, name: Od, encode: La, digest: zd };
});
var ro, Ra = F(() => {
  a();
  Aa();
  Ta();
  Ia();
  Sa();
  Ua();
  ht();
  Fa();
  Re();
  zn();
  ka();
  Na();
  Pa();
  qn();
  Hn();
  gn();
  ro = { ...Wn, ...Jn, ...Xn, ...Yn, ...Qn, ...Rt, ...Zn, ...dt, ...On, ...Kn }, { ...eo, ...to };
});
function Nr(t = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(t) : new Uint8Array(t);
}
var no = F(() => {
  a();
});
function Oa(t, e, r, n) {
  return { name: t, prefix: e, encoder: { name: t, prefix: e, encode: r }, decoder: { decode: n } };
}
var Ma, oo, Hd, $r, io = F(() => {
  a();
  Ra();
  no();
  Ma = Oa("utf8", "u", (t) => {
    let e = new TextDecoder("utf8");
    return "u" + e.decode(t);
  }, (t) => new TextEncoder().encode(t.substring(1))), oo = Oa("ascii", "a", (t) => {
    let e = "a";
    for (let r = 0; r < t.length; r++)
      e += String.fromCharCode(t[r]);
    return e;
  }, (t) => {
    t = t.substring(1);
    let e = Nr(t.length);
    for (let r = 0; r < t.length; r++)
      e[r] = t.charCodeAt(r);
    return e;
  }), Hd = { utf8: Ma, "utf-8": Ma, hex: ro.base16, latin1: oo, ascii: oo, binary: oo, ...ro }, $r = Hd;
});
var Tt = {};
M(Tt, { toString: () => so });
function so(t, e = "utf8") {
  let r = $r[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("utf8") : r.encoder.encode(t).substring(1);
}
var Ke = F(() => {
  a();
  io();
});
var Va = S((I0, ja) => {
  a();
  var uo = Ba(), { toString: za } = (Ke(), R(Tt)), jd = uo, ao = uo.v4, qa = uo.v6, Ha = function(t, e, r) {
    r = ~~r;
    let n;
    if (ao(t))
      n = e || new Uint8Array(r + 4), t.split(/\./g).map(function(o) {
        n[r++] = parseInt(o, 10) & 255;
      });
    else if (qa(t)) {
      let o = t.split(":", 8), i2;
      for (i2 = 0; i2 < o.length; i2++) {
        let s = ao(o[i2]), u;
        s && (u = Ha(o[i2]), o[i2] = za(u.slice(0, 2), "base16")), u && ++i2 < 8 && o.splice(i2, 0, za(u.slice(2, 4), "base16"));
      }
      if (o[0] === "")
        for (; o.length < 8; )
          o.unshift("0");
      else if (o[o.length - 1] === "")
        for (; o.length < 8; )
          o.push("0");
      else if (o.length < 8) {
        for (i2 = 0; i2 < o.length && o[i2] !== ""; i2++)
          ;
        let s = [i2, "1"];
        for (i2 = 9 - o.length; i2 > 0; i2--)
          s.push("0");
        o.splice.apply(o, s);
      }
      for (n = e || new Uint8Array(r + 16), i2 = 0; i2 < o.length; i2++) {
        let s = parseInt(o[i2], 16);
        n[r++] = s >> 8 & 255, n[r++] = s & 255;
      }
    }
    if (!n)
      throw Error("Invalid ip address: " + t);
    return n;
  }, Vd = function(t, e, r) {
    e = ~~e, r = r || t.length - e;
    let n = [], o, i2 = new DataView(t.buffer);
    if (r === 4) {
      for (let s = 0; s < r; s++)
        n.push(t[e + s]);
      o = n.join(".");
    } else if (r === 16) {
      for (let s = 0; s < r; s += 2)
        n.push(i2.getUint16(e + s).toString(16));
      o = n.join(":"), o = o.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3"), o = o.replace(/:{3,4}/, "::");
    }
    return o;
  };
  ja.exports = { isIP: jd, isV4: ao, isV6: qa, toBytes: Ha, toString: Vd };
});
var Lr = S((S0, Wa) => {
  a();
  function Z(t) {
    if (typeof t == "number") {
      if (Z.codes[t])
        return Z.codes[t];
      throw new Error("no protocol with code: " + t);
    } else if (typeof t == "string") {
      if (Z.names[t])
        return Z.names[t];
      throw new Error("no protocol with name: " + t);
    }
    throw new Error("invalid protocol id type: " + t);
  }
  var de = -1;
  Z.lengthPrefixedVarSize = de;
  Z.V = de;
  Z.table = [[4, 32, "ip4"], [6, 16, "tcp"], [33, 16, "dccp"], [41, 128, "ip6"], [42, de, "ip6zone"], [53, de, "dns", "resolvable"], [54, de, "dns4", "resolvable"], [55, de, "dns6", "resolvable"], [56, de, "dnsaddr", "resolvable"], [132, 16, "sctp"], [273, 16, "udp"], [275, 0, "p2p-webrtc-star"], [276, 0, "p2p-webrtc-direct"], [277, 0, "p2p-stardust"], [290, 0, "p2p-circuit"], [301, 0, "udt"], [302, 0, "utp"], [400, de, "unix", false, "path"], [421, de, "ipfs"], [421, de, "p2p"], [443, 0, "https"], [444, 96, "onion"], [445, 296, "onion3"], [446, de, "garlic64"], [460, 0, "quic"], [477, 0, "ws"], [478, 0, "wss"], [479, 0, "p2p-websocket-star"], [480, 0, "http"], [777, de, "memory"]];
  Z.names = {};
  Z.codes = {};
  Z.table.map((t) => {
    let e = Ga.apply(null, t);
    return Z.codes[e.code] = e, Z.names[e.name] = e, null;
  });
  Z.object = Ga;
  function Ga(t, e, r, n, o) {
    return { code: t, size: e, name: r, resolvable: Boolean(n), path: Boolean(o) };
  }
  Wa.exports = Z;
});
var Ja = {};
M(Ja, { fromString: () => co });
function co(t, e = "utf8") {
  let r = $r[e];
  if (!r)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(t, "utf8") : r.decoder.decode(`${r.prefix}${t}`);
}
var fo = F(() => {
  a();
  io();
});
var lo = {};
M(lo, { concat: () => Gd });
function Gd(t, e) {
  e || (e = t.reduce((o, i2) => o + i2.length, 0));
  let r = Nr(e), n = 0;
  for (let o of t)
    r.set(o, n), n += o.length;
  return r;
}
var ho = F(() => {
  a();
  no();
});
var ru = S((v0, tu) => {
  a();
  var Pr = Va(), Qa = Lr(), { CID: Wd } = (Q(), R(dr)), { base32: Za } = (ht(), R(Rt)), { base58btc: Jd } = (Re(), R(dt)), Xd = (Le(), R(Ue)), It = pt(), { toString: Rr } = (Ke(), R(Tt)), { fromString: Ka } = (fo(), R(Ja)), { concat: Mr } = (ho(), R(lo));
  tu.exports = Wt;
  function Wt(t, e) {
    return e instanceof Uint8Array ? Wt.toString(t, e) : Wt.toBytes(t, e);
  }
  Wt.toString = function(e, r) {
    switch (Qa(e).code) {
      case 4:
      case 41:
        return Yd(r);
      case 6:
      case 273:
      case 33:
      case 132:
        return eu(r).toString();
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 777:
        return Zd(r);
      case 421:
        return eh(r);
      case 444:
        return Ya(r);
      case 445:
        return Ya(r);
      default:
        return Rr(r, "base16");
    }
  };
  Wt.toBytes = function(e, r) {
    switch (Qa(e).code) {
      case 4:
        return Xa(r);
      case 41:
        return Xa(r);
      case 6:
      case 273:
      case 33:
      case 132:
        return po(parseInt(r, 10));
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 777:
        return Qd(r);
      case 421:
        return Kd(r);
      case 444:
        return th(r);
      case 445:
        return rh(r);
      default:
        return Ka(r, "base16");
    }
  };
  function Xa(t) {
    if (!Pr.isIP(t))
      throw new Error("invalid ip address");
    return Pr.toBytes(t);
  }
  function Yd(t) {
    let e = Pr.toString(t);
    if (!e || !Pr.isIP(e))
      throw new Error("invalid ip address");
    return e;
  }
  function po(t) {
    let e = new ArrayBuffer(2);
    return new DataView(e).setUint16(0, t), new Uint8Array(e);
  }
  function eu(t) {
    return new DataView(t.buffer).getUint16(t.byteOffset);
  }
  function Qd(t) {
    let e = Ka(t), r = Uint8Array.from(It.encode(e.length));
    return Mr([r, e], r.length + e.length);
  }
  function Zd(t) {
    let e = It.decode(t);
    if (t = t.slice(It.decode.bytes), t.length !== e)
      throw new Error("inconsistent lengths");
    return Rr(t);
  }
  function Kd(t) {
    let e;
    t[0] === "Q" || t[0] === "1" ? e = Xd.decode(Jd.decode(`z${t}`)).bytes : e = Wd.parse(t).multihash.bytes;
    let r = Uint8Array.from(It.encode(e.length));
    return Mr([r, e], r.length + e.length);
  }
  function eh(t) {
    let e = It.decode(t), r = t.slice(It.decode.bytes);
    if (r.length !== e)
      throw new Error("inconsistent lengths");
    return Rr(r, "base58btc");
  }
  function th(t) {
    let e = t.split(":");
    if (e.length !== 2)
      throw new Error("failed to parse onion addr: " + e + " does not contain a port number");
    if (e[0].length !== 16)
      throw new Error("failed to parse onion addr: " + e[0] + " not a Tor onion address.");
    let r = Za.decode("b" + e[0]), n = parseInt(e[1], 10);
    if (n < 1 || n > 65536)
      throw new Error("Port number is not in range(1, 65536)");
    let o = po(n);
    return Mr([r, o], r.length + o.length);
  }
  function rh(t) {
    let e = t.split(":");
    if (e.length !== 2)
      throw new Error("failed to parse onion addr: " + e + " does not contain a port number");
    if (e[0].length !== 56)
      throw new Error("failed to parse onion addr: " + e[0] + " not a Tor onion3 address.");
    let r = Za.decode("b" + e[0]), n = parseInt(e[1], 10);
    if (n < 1 || n > 65536)
      throw new Error("Port number is not in range(1, 65536)");
    let o = po(n);
    return Mr([r, o], r.length + o.length);
  }
  function Ya(t) {
    let e = t.slice(0, t.length - 2), r = t.slice(t.length - 2), n = Rr(e, "base32"), o = eu(r);
    return n + ":" + o;
  }
});
var pu = S((k0, hu) => {
  a();
  var ou = ru(), mo = Lr(), Jt = pt(), { concat: nu } = (ho(), R(lo)), { toString: nh } = (Ke(), R(Tt));
  hu.exports = { stringToStringTuples: iu, stringTuplesToString: su, tuplesToStringTuples: uu, stringTuplesToTuples: au, bytesToTuples: yo, tuplesToBytes: cu, bytesToString: oh, stringToBytes: lu, fromString: ih, fromBytes: du, validateBytes: wo, isValidBytes: sh, cleanPath: Or, ParseError: go, protoFromTuple: Xt, sizeForAddr: fu };
  function iu(t) {
    let e = [], r = t.split("/").slice(1);
    if (r.length === 1 && r[0] === "")
      return [];
    for (let n = 0; n < r.length; n++) {
      let o = r[n], i2 = mo(o);
      if (i2.size === 0) {
        e.push([o]);
        continue;
      }
      if (n++, n >= r.length)
        throw go("invalid address: " + t);
      if (i2.path) {
        e.push([o, Or(r.slice(n).join("/"))]);
        break;
      }
      e.push([o, r[n]]);
    }
    return e;
  }
  function su(t) {
    let e = [];
    return t.map((r) => {
      let n = Xt(r);
      return e.push(n.name), r.length > 1 && e.push(r[1]), null;
    }), Or(e.join("/"));
  }
  function au(t) {
    return t.map((e) => {
      Array.isArray(e) || (e = [e]);
      let r = Xt(e);
      return e.length > 1 ? [r.code, ou.toBytes(r.code, e[1])] : [r.code];
    });
  }
  function uu(t) {
    return t.map((e) => {
      let r = Xt(e);
      return e[1] ? [r.code, ou.toString(r.code, e[1])] : [r.code];
    });
  }
  function cu(t) {
    return du(nu(t.map((e) => {
      let r = Xt(e), n = Uint8Array.from(Jt.encode(r.code));
      return e.length > 1 && (n = nu([n, e[1]])), n;
    })));
  }
  function fu(t, e) {
    return t.size > 0 ? t.size / 8 : t.size === 0 ? 0 : Jt.decode(e) + Jt.decode.bytes;
  }
  function yo(t) {
    let e = [], r = 0;
    for (; r < t.length; ) {
      let n = Jt.decode(t, r), o = Jt.decode.bytes, i2 = mo(n), s = fu(i2, t.slice(r + o));
      if (s === 0) {
        e.push([n]), r += o;
        continue;
      }
      let u = t.slice(r + o, r + o + s);
      if (r += s + o, r > t.length)
        throw go("Invalid address Uint8Array: " + nh(t, "base16"));
      e.push([n, u]);
    }
    return e;
  }
  function oh(t) {
    let e = yo(t), r = uu(e);
    return su(r);
  }
  function lu(t) {
    t = Or(t);
    let e = iu(t), r = au(e);
    return cu(r);
  }
  function ih(t) {
    return lu(t);
  }
  function du(t) {
    let e = wo(t);
    if (e)
      throw e;
    return Uint8Array.from(t);
  }
  function wo(t) {
    try {
      yo(t);
    } catch (e) {
      return e;
    }
  }
  function sh(t) {
    return wo(t) === void 0;
  }
  function Or(t) {
    return "/" + t.trim().split("/").filter((e) => e).join("/");
  }
  function go(t) {
    return new Error("Error parsing address: " + t);
  }
  function Xt(t) {
    return mo(t[0]);
  }
});
var Yt = S((_0, yu) => {
  a();
  function mu(t, e) {
    for (let r in e)
      Object.defineProperty(t, r, { value: e[r], enumerable: true, configurable: true });
    return t;
  }
  function ah(t, e, r) {
    if (!t || typeof t == "string")
      throw new TypeError("Please pass an Error to err-code");
    r || (r = {}), typeof e == "object" && (r = e, e = ""), e && (r.code = e);
    try {
      return mu(t, r);
    } catch {
      r.message = t.message, r.stack = t.stack;
      let o = function() {
      };
      return o.prototype = Object.create(Object.getPrototypeOf(t)), mu(new o(), r);
    }
  }
  yu.exports = ah;
});
var wu = {};
M(wu, { equals: () => uh });
function uh(t, e) {
  if (t === e)
    return true;
  if (t.byteLength !== e.byteLength)
    return false;
  for (let r = 0; r < t.byteLength; r++)
    if (t[r] !== e[r])
      return false;
  return true;
}
var gu = F(() => {
  a();
});
var bo = S((N0, Eu) => {
  a();
  var ge = pu(), St = Lr(), Du = pt(), { CID: ch } = (Q(), R(dr)), { base58btc: fh } = (Re(), R(dt)), lh = Yt(), dh = Symbol.for("nodejs.util.inspect.custom"), { toString: zr } = (Ke(), R(Tt)), { equals: hh } = (gu(), R(wu)), Do = /* @__PURE__ */ new Map(), bu = Symbol.for("@multiformats/js-multiaddr/multiaddr"), j = class {
    constructor(e) {
      if (e == null && (e = ""), Object.defineProperty(this, bu, { value: true }), e instanceof Uint8Array)
        this.bytes = ge.fromBytes(e);
      else if (typeof e == "string") {
        if (e.length > 0 && e.charAt(0) !== "/")
          throw new Error(`multiaddr "${e}" must start with a "/"`);
        this.bytes = ge.fromString(e);
      } else if (j.isMultiaddr(e))
        this.bytes = ge.fromBytes(e.bytes);
      else
        throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
    toString() {
      return ge.bytesToString(this.bytes);
    }
    toJSON() {
      return this.toString();
    }
    toOptions() {
      let e = {}, r = this.toString().split("/");
      return e.family = r[1] === "ip4" ? 4 : 6, e.host = r[2], e.transport = r[3], e.port = parseInt(r[4]), e;
    }
    protos() {
      return this.protoCodes().map((e) => Object.assign({}, St(e)));
    }
    protoCodes() {
      let e = [], r = this.bytes, n = 0;
      for (; n < r.length; ) {
        let o = Du.decode(r, n), i2 = Du.decode.bytes, s = St(o);
        n += ge.sizeForAddr(s, r.slice(n + i2)) + i2, e.push(o);
      }
      return e;
    }
    protoNames() {
      return this.protos().map((e) => e.name);
    }
    tuples() {
      return ge.bytesToTuples(this.bytes);
    }
    stringTuples() {
      let e = ge.bytesToTuples(this.bytes);
      return ge.tuplesToStringTuples(e);
    }
    encapsulate(e) {
      return e = new j(e), new j(this.toString() + e.toString());
    }
    decapsulate(e) {
      let r = e.toString(), n = this.toString(), o = n.lastIndexOf(r);
      if (o < 0)
        throw new Error("Address " + this + " does not contain subaddress: " + e);
      return new j(n.slice(0, o));
    }
    decapsulateCode(e) {
      let r = this.tuples();
      for (let n = r.length - 1; n >= 0; n--)
        if (r[n][0] === e)
          return new j(ge.tuplesToBytes(r.slice(0, n)));
      return this;
    }
    getPeerId() {
      try {
        let r = this.stringTuples().filter((n) => n[0] === St.names.ipfs.code).pop();
        if (r && r[1]) {
          let n = r[1];
          return n[0] === "Q" || n[0] === "1" ? zr(fh.decode(`z${n}`), "base58btc") : zr(ch.parse(n).multihash.bytes, "base58btc");
        }
        return null;
      } catch {
        return null;
      }
    }
    getPath() {
      let e = null;
      try {
        e = this.stringTuples().filter((r) => !!St(r[0]).path)[0][1], e || (e = null);
      } catch {
        e = null;
      }
      return e;
    }
    equals(e) {
      return hh(this.bytes, e.bytes);
    }
    async resolve() {
      let e = this.protos().find((o) => o.resolvable);
      if (!e)
        return [this];
      let r = Do.get(e.name);
      if (!r)
        throw lh(new Error(`no available resolver for ${e.name}`), "ERR_NO_AVAILABLE_RESOLVER");
      return (await r(this)).map((o) => new j(o));
    }
    nodeAddress() {
      let e = this.protoCodes(), r = this.protoNames(), n = this.toString().split("/").slice(1);
      if (n.length < 4)
        throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
      if (e[0] !== 4 && e[0] !== 41 && e[0] !== 54 && e[0] !== 55)
        throw new Error(`no protocol with name: "'${r[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
      if (n[2] !== "tcp" && n[2] !== "udp")
        throw new Error(`no protocol with name: "'${r[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
      return { family: e[0] === 41 || e[0] === 55 ? 6 : 4, address: n[1], port: parseInt(n[3]) };
    }
    isThinWaistAddress(e) {
      let r = (e || this).protos();
      return !(r.length !== 2 || r[0].code !== 4 && r[0].code !== 41 || r[1].code !== 6 && r[1].code !== 273);
    }
    static fromNodeAddress(e, r) {
      if (!e)
        throw new Error("requires node address object");
      if (!r)
        throw new Error("requires transport protocol");
      let n;
      switch (e.family) {
        case 4:
          n = "ip4";
          break;
        case 6:
          n = "ip6";
          break;
        default:
          throw Error(`Invalid addr family. Got '${e.family}' instead of 4 or 6`);
      }
      return new j("/" + [n, e.address, r, e.port].join("/"));
    }
    static isName(e) {
      return j.isMultiaddr(e) ? e.protos().some((r) => r.resolvable) : false;
    }
    static isMultiaddr(e) {
      return e instanceof j || Boolean(e && e[bu]);
    }
    [dh]() {
      return "<Multiaddr " + zr(this.bytes, "base16") + " - " + ge.bytesToString(this.bytes) + ">";
    }
    inspect() {
      return "<Multiaddr " + zr(this.bytes, "base16") + " - " + ge.bytesToString(this.bytes) + ">";
    }
  };
  j.protocols = St;
  j.resolvers = Do;
  function ph(t) {
    return new j(t);
  }
  Eu.exports = { Multiaddr: j, multiaddr: ph, protocols: St, resolvers: Do };
});
var ku = S(($0, vu) => {
  a();
  var { Multiaddr: Eo } = bo(), Bu = E("dns4"), Au = E("dns6"), Tu = E("dnsaddr"), et = V2(E("dns"), Tu, Bu, Au), Qt = V2(E("ip4"), E("ip6")), _t = V2(A(Qt, E("tcp")), A(et, E("tcp"))), xo = A(Qt, E("udp")), Iu = A(xo, E("utp")), Su = A(xo, E("quic")), Ft = V2(A(_t, E("ws")), A(et, E("ws"))), vt = V2(A(_t, E("wss")), A(et, E("wss"))), qr = V2(A(_t, E("http")), A(Qt, E("http")), A(et, E("http"))), Hr = V2(A(_t, E("https")), A(Qt, E("https")), A(et, E("https"))), Co = V2(A(Ft, E("p2p-webrtc-star"), E("p2p")), A(vt, E("p2p-webrtc-star"), E("p2p")), A(Ft, E("p2p-webrtc-star")), A(vt, E("p2p-webrtc-star"))), mh = V2(A(Ft, E("p2p-websocket-star"), E("p2p")), A(vt, E("p2p-websocket-star"), E("p2p")), A(Ft, E("p2p-websocket-star")), A(vt, E("p2p-websocket-star"))), Bo = V2(A(qr, E("p2p-webrtc-direct"), E("p2p")), A(Hr, E("p2p-webrtc-direct"), E("p2p")), A(qr, E("p2p-webrtc-direct")), A(Hr, E("p2p-webrtc-direct"))), kt = V2(Ft, vt, qr, Hr, Co, Bo, _t, Iu, Su, et), yh = V2(A(kt, E("p2p-stardust"), E("p2p")), A(kt, E("p2p-stardust"))), Ve = V2(A(kt, E("p2p")), Co, Bo, E("p2p")), xu = V2(A(Ve, E("p2p-circuit"), Ve), A(Ve, E("p2p-circuit")), A(E("p2p-circuit"), Ve), A(kt, E("p2p-circuit")), A(E("p2p-circuit"), kt), E("p2p-circuit")), Uu = () => V2(A(xu, Uu), xu), Ut = Uu(), Cu = V2(A(Ut, Ve, Ut), A(Ve, Ut), A(Ut, Ve), Ut, Ve);
  vu.exports = { DNS: et, DNS4: Bu, DNS6: Au, DNSADDR: Tu, IP: Qt, TCP: _t, UDP: xo, QUIC: Su, UTP: Iu, HTTP: qr, HTTPS: Hr, WebSockets: Ft, WebSocketsSecure: vt, WebSocketStar: mh, WebRTCStar: Co, WebRTCDirect: Bo, Reliable: kt, Stardust: yh, Circuit: Ut, P2P: Cu, IPFS: Cu };
  function Fu(t) {
    function e(r) {
      if (!Eo.isMultiaddr(r))
        try {
          r = new Eo(r);
        } catch {
          return false;
        }
      let n = t(r.protoNames());
      return n === null ? false : n === true || n === false ? n : n.length === 0;
    }
    return e;
  }
  function A(...t) {
    function e(r) {
      if (r.length < t.length)
        return null;
      let n = r;
      return t.some((o) => (n = typeof o == "function" ? o().partialMatch(r) : o.partialMatch(r), Array.isArray(n) && (r = n), n === null)), n;
    }
    return { toString: function() {
      return "{ " + t.join(" ") + " }";
    }, input: t, matches: Fu(e), partialMatch: e };
  }
  function V2(...t) {
    function e(n) {
      let o = null;
      return t.some((i2) => {
        let s = typeof i2 == "function" ? i2().partialMatch(n) : i2.partialMatch(n);
        return s ? (o = s, true) : false;
      }), o;
    }
    return { toString: function() {
      return "{ " + t.join(" ") + " }";
    }, input: t, matches: Fu(e), partialMatch: e };
  }
  function E(t) {
    let e = t;
    function r(o) {
      let i2;
      if (typeof o == "string" || o instanceof Uint8Array)
        try {
          i2 = new Eo(o);
        } catch {
          return false;
        }
      else
        i2 = o;
      let s = i2.protoNames();
      return s.length === 1 && s[0] === e;
    }
    function n(o) {
      return o.length === 0 ? null : o[0] === e ? o.slice(1) : null;
    }
    return { toString: function() {
      return e;
    }, matches: r, partialMatch: n };
  }
});
var To = S((L0, Nu) => {
  a();
  var wh = typeof navigator < "u" && navigator.product === "ReactNative";
  function gh() {
    return wh ? "http://localhost" : d.location ? d.location.protocol + "//" + d.location.host : "";
  }
  var Zt = d.URL, _u = gh(), Ao = class {
    constructor(e = "", r = _u) {
      this.super = new Zt(e, r), this.path = this.pathname + this.search, this.auth = this.username && this.password ? this.username + ":" + this.password : null, this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    get hash() {
      return this.super.hash;
    }
    get host() {
      return this.super.host;
    }
    get hostname() {
      return this.super.hostname;
    }
    get href() {
      return this.super.href;
    }
    get origin() {
      return this.super.origin;
    }
    get password() {
      return this.super.password;
    }
    get pathname() {
      return this.super.pathname;
    }
    get port() {
      return this.super.port;
    }
    get protocol() {
      return this.super.protocol;
    }
    get search() {
      return this.super.search;
    }
    get searchParams() {
      return this.super.searchParams;
    }
    get username() {
      return this.super.username;
    }
    set hash(e) {
      this.super.hash = e;
    }
    set host(e) {
      this.super.host = e;
    }
    set hostname(e) {
      this.super.hostname = e;
    }
    set href(e) {
      this.super.href = e;
    }
    set password(e) {
      this.super.password = e;
    }
    set pathname(e) {
      this.super.pathname = e;
    }
    set port(e) {
      this.super.port = e;
    }
    set protocol(e) {
      this.super.protocol = e;
    }
    set search(e) {
      this.super.search = e;
    }
    set username(e) {
      this.super.username = e;
    }
    static createObjectURL(e) {
      return Zt.createObjectURL(e);
    }
    static revokeObjectURL(e) {
      Zt.revokeObjectURL(e);
    }
    toJSON() {
      return this.super.toJSON();
    }
    toString() {
      return this.super.toString();
    }
    format() {
      return this.toString();
    }
  };
  function Dh(t) {
    if (typeof t == "string")
      return new Zt(t).toString();
    if (!(t instanceof Zt)) {
      let e = t.username && t.password ? `${t.username}:${t.password}@` : "", r = t.auth ? t.auth + "@" : "", n = t.port ? ":" + t.port : "", o = t.protocol ? t.protocol + "//" : "", i2 = t.host || "", s = t.hostname || "", u = t.search || (t.query ? "?" + t.query : ""), h = t.hash || "", w = t.pathname || "", c = t.path || w + u;
      return `${o}${e || r}${i2 || s + n}${c}${h}`;
    }
  }
  Nu.exports = { URLWithLegacySupport: Ao, URLSearchParams: d.URLSearchParams, defaultBase: _u, format: Dh };
});
var Pu = S((P0, Lu) => {
  a();
  var { URLWithLegacySupport: $u, format: bh } = To();
  Lu.exports = (t, e = {}, r = {}, n) => {
    let o = e.protocol ? e.protocol.replace(":", "") : "http";
    o = (r[o] || n || o) + ":";
    let i2;
    try {
      i2 = new $u(t);
    } catch {
      i2 = {};
    }
    let s = Object.assign({}, e, { protocol: o || i2.protocol, host: e.host || i2.host });
    return new $u(t, bh(s)).toString();
  };
});
var Mu = S((R0, Ru) => {
  a();
  var { URLWithLegacySupport: Eh, format: xh, URLSearchParams: Ch, defaultBase: Bh } = To(), Ah = Pu();
  Ru.exports = { URL: Eh, URLSearchParams: Ch, format: xh, relative: Ah, defaultBase: Bh };
});
var Ku = S((M0, Zu) => {
  a();
  var { base58btc: Th } = (Re(), R(dt)), { base32: Ih } = (ht(), R(Rt)), Sh = (Le(), R(Ue)), { Multiaddr: Ou } = bo(), Uh = ku(), { CID: Io } = (Q(), R(dr)), { URL: Fh } = Mu(), { toString: vh } = (Ke(), R(Tt)), So = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/, Nt = /^\/(ip[fn]s)\/([^/?#]+)/, Hu = 1, ju = 2, tr = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/, Vu = 1, Gu = 2, kh = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
  function _h(t) {
    let e = Uo(t);
    try {
      Sh.decode(Th.decode("z" + e));
    } catch {
      return false;
    }
    return true;
  }
  function Nh(t) {
    try {
      Ih.decode(t);
    } catch {
      return false;
    }
    return true;
  }
  function Kt(t) {
    try {
      return typeof t == "string" ? Boolean(Io.parse(t)) : t instanceof Uint8Array ? Boolean(Io.decode(t)) : Boolean(Io.asCID(t));
    } catch {
      return false;
    }
  }
  function Wu(t) {
    if (!t)
      return false;
    if (Ou.isMultiaddr(t))
      return true;
    try {
      return new Ou(t), true;
    } catch {
      return false;
    }
  }
  function $h(t) {
    return Wu(t) && Uh.P2P.matches(t);
  }
  function er(t, e, r = Hu, n = ju) {
    let o = Uo(t);
    if (!o)
      return false;
    let i2 = o.match(e);
    if (!i2 || i2[r] !== "ipfs")
      return false;
    let s = i2[n];
    return s && e === tr && (s = s.toLowerCase()), Kt(s);
  }
  function jr(t, e, r = Hu, n = ju) {
    let o = Uo(t);
    if (!o)
      return false;
    let i2 = o.match(e);
    if (!i2 || i2[r] !== "ipns")
      return false;
    let s = i2[n];
    if (s && e === tr) {
      if (s = s.toLowerCase(), Kt(s))
        return true;
      try {
        !s.includes(".") && s.includes("-") && (s = s.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-"));
        let { hostname: u } = new Fh(`http://${s}`);
        return kh.test(u);
      } catch {
        return false;
      }
    }
    return true;
  }
  function Ju(t) {
    return typeof t == "string";
  }
  function Uo(t) {
    return t instanceof Uint8Array ? vh(t, "base58btc") : Ju(t) ? t : false;
  }
  var Fo = (t) => er(t, tr, Gu, Vu), vo = (t) => jr(t, tr, Gu, Vu), Xu = (t) => Fo(t) || vo(t), Yu = (t) => er(t, So) || Fo(t), Qu = (t) => jr(t, So) || vo(t), zu = (t) => Yu(t) || Qu(t) || Xu(t), qu = (t) => er(t, Nt) || jr(t, Nt);
  Zu.exports = { multihash: _h, multiaddr: Wu, peerMultiaddr: $h, cid: Kt, base32cid: (t) => Nh(t) && Kt(t), ipfsSubdomain: Fo, ipnsSubdomain: vo, subdomain: Xu, subdomainGatewayPattern: tr, ipfsUrl: Yu, ipnsUrl: Qu, url: zu, pathGatewayPattern: So, ipfsPath: (t) => er(t, Nt), ipnsPath: (t) => jr(t, Nt), path: qu, pathPattern: Nt, urlOrPath: (t) => zu(t) || qu(t), cidPath: (t) => Ju(t) && !Kt(t) && er(`/ipfs/${t}`, Nt) };
});
var hc = S((Iy, dc) => {
  a();
  function zh(t) {
    let [e, r] = t[Symbol.asyncIterator] ? [t[Symbol.asyncIterator](), Symbol.asyncIterator] : [t[Symbol.iterator](), Symbol.iterator], n = [];
    return { peek: () => e.next(), push: (o) => {
      n.push(o);
    }, next: () => n.length ? { done: false, value: n.shift() } : e.next(), [r]() {
      return this;
    } };
  }
  dc.exports = zh;
});
var mc = S((Sy, pc) => {
  a();
  var qh = async (t) => {
    for await (let e of t)
      ;
  };
  pc.exports = qh;
});
var wc = S((Uy, yc) => {
  a();
  var Hh = async function* (t, e) {
    for await (let r of t)
      yield e(r);
  };
  yc.exports = Hh;
});
a();
a();
Q();
a();
gn();
var hr = ({ enumerable: t = true, configurable: e = false } = {}) => ({ enumerable: t, configurable: e, writable: false }), Dn = function* (t, e) {
  if (t != null && !(t instanceof Uint8Array))
    for (let [r, n] of Object.entries(t)) {
      let o = [...e, r];
      if (n != null && typeof n == "object")
        if (Array.isArray(n))
          for (let [i2, s] of n.entries()) {
            let u = [...o, i2], h = x.asCID(s);
            h ? yield [u.join("/"), h] : typeof s == "object" && (yield* Dn(s, u));
          }
        else {
          let i2 = x.asCID(n);
          i2 ? yield [o.join("/"), i2] : yield* Dn(n, o);
        }
    }
}, bn = function* (t, e) {
  if (t != null)
    for (let [r, n] of Object.entries(t)) {
      let o = [...e, r];
      if (yield o.join("/"), n != null && !(n instanceof Uint8Array) && typeof n == "object" && !x.asCID(n))
        if (Array.isArray(n))
          for (let [i2, s] of n.entries()) {
            let u = [...o, i2];
            yield u.join("/"), typeof s == "object" && !x.asCID(s) && (yield* bn(s, u));
          }
        else
          yield* bn(n, o);
    }
}, Qf = (t, e) => {
  let r = t;
  for (let [n, o] of e.entries()) {
    if (r = r[o], r == null)
      throw new Error(`Object has no property at ${e.slice(0, n + 1).map((s) => `[${JSON.stringify(s)}]`).join("")}`);
    let i2 = x.asCID(r);
    if (i2)
      return { value: i2, remaining: e.slice(n + 1).join("/") };
  }
  return { value: r };
}, En = class {
  constructor({ cid: e, bytes: r, value: n }) {
    if (!e || !r || typeof n > "u")
      throw new Error("Missing required argument");
    this.cid = e, this.bytes = r, this.value = n, this.asBlock = this, Object.defineProperties(this, { cid: hr(), bytes: hr(), value: hr(), asBlock: hr() });
  }
  links() {
    return Dn(this.value, []);
  }
  tree() {
    return bn(this.value, []);
  }
  get(e = "/") {
    return Qf(this.value, e.split("/").filter(Boolean));
  }
};
var bi = ({ bytes: t, cid: e, value: r, codec: n }) => {
  let o = r !== void 0 ? r : n && n.decode(t);
  if (o === void 0)
    throw new Error('Missing required argument, must either provide "value" or "codec"');
  return new En({ cid: e, bytes: t, value: o });
};
a();
Q();
a();
var Nn = J(pt(), 1);
a();
a();
a();
a();
var ll = ["string", "number", "bigint", "symbol"], dl = ["Function", "Generator", "AsyncGenerator", "GeneratorFunction", "AsyncGeneratorFunction", "AsyncFunction", "Observable", "Array", "Buffer", "Object", "RegExp", "Date", "Error", "Map", "Set", "WeakMap", "WeakSet", "ArrayBuffer", "SharedArrayBuffer", "DataView", "Promise", "URL", "HTMLElement", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"];
function Fi(t) {
  if (t === null)
    return "null";
  if (t === void 0)
    return "undefined";
  if (t === true || t === false)
    return "boolean";
  let e = typeof t;
  if (ll.includes(e))
    return e;
  if (e === "function")
    return "Function";
  if (Array.isArray(t))
    return "Array";
  if (hl(t))
    return "Buffer";
  let r = pl(t);
  return r || "Object";
}
function hl(t) {
  return t && t.constructor && t.constructor.isBuffer && t.constructor.isBuffer.call(null, t);
}
function pl(t) {
  let e = Object.prototype.toString.call(t).slice(8, -1);
  if (dl.includes(e))
    return e;
}
a();
var l = class {
  constructor(e, r, n) {
    this.major = e, this.majorEncoded = e << 5, this.name = r, this.terminal = n;
  }
  toString() {
    return `Type[${this.major}].${this.name}`;
  }
  compare(e) {
    return this.major < e.major ? -1 : this.major > e.major ? 1 : 0;
  }
};
l.uint = new l(0, "uint", true);
l.negint = new l(1, "negint", true);
l.bytes = new l(2, "bytes", true);
l.string = new l(3, "string", true);
l.array = new l(4, "array", false);
l.map = new l(5, "map", false);
l.tag = new l(6, "tag", false);
l.float = new l(7, "float", true);
l.false = new l(7, "false", true);
l.true = new l(7, "true", true);
l.null = new l(7, "null", true);
l.undefined = new l(7, "undefined", true);
l.break = new l(7, "break", true);
var b = class {
  constructor(e, r, n) {
    this.type = e, this.value = r, this.encodedLength = n, this.encodedBytes = void 0, this.byteValue = void 0;
  }
  toString() {
    return `Token[${this.type}].${this.value}`;
  }
};
a();
a();
var mt = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer == "function", ml = new TextDecoder(), yl = new TextEncoder();
function pr(t) {
  return mt && globalThis.Buffer.isBuffer(t);
}
function Bn(t) {
  return t instanceof Uint8Array ? pr(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t : Uint8Array.from(t);
}
var Ni = mt ? (t, e, r) => r - e > 64 ? globalThis.Buffer.from(t.subarray(e, r)).toString("utf8") : ki(t, e, r) : (t, e, r) => r - e > 64 ? ml.decode(t.subarray(e, r)) : ki(t, e, r), $i = mt ? (t) => t.length > 64 ? globalThis.Buffer.from(t) : vi(t) : (t) => t.length > 64 ? yl.encode(t) : vi(t), Ce = (t) => Uint8Array.from(t), yt = mt ? (t, e, r) => pr(t) ? new Uint8Array(t.subarray(e, r)) : t.slice(e, r) : (t, e, r) => t.slice(e, r), Li = mt ? (t, e) => (t = t.map((r) => r instanceof Uint8Array ? r : globalThis.Buffer.from(r)), Bn(globalThis.Buffer.concat(t, e))) : (t, e) => {
  let r = new Uint8Array(e), n = 0;
  for (let o of t)
    n + o.length > r.length && (o = o.subarray(0, r.length - n)), r.set(o, n), n += o.length;
  return r;
}, Pi = mt ? (t) => globalThis.Buffer.allocUnsafe(t) : (t) => new Uint8Array(t);
function Ri(t, e) {
  if (pr(t) && pr(e))
    return t.compare(e);
  for (let r = 0; r < t.length; r++)
    if (t[r] !== e[r])
      return t[r] < e[r] ? -1 : 1;
  return 0;
}
function vi(t, e = 1 / 0) {
  let r, n = t.length, o = null, i2 = [];
  for (let s = 0; s < n; ++s) {
    if (r = t.charCodeAt(s), r > 55295 && r < 57344) {
      if (!o) {
        if (r > 56319) {
          (e -= 3) > -1 && i2.push(239, 191, 189);
          continue;
        } else if (s + 1 === n) {
          (e -= 3) > -1 && i2.push(239, 191, 189);
          continue;
        }
        o = r;
        continue;
      }
      if (r < 56320) {
        (e -= 3) > -1 && i2.push(239, 191, 189), o = r;
        continue;
      }
      r = (o - 55296 << 10 | r - 56320) + 65536;
    } else
      o && (e -= 3) > -1 && i2.push(239, 191, 189);
    if (o = null, r < 128) {
      if ((e -= 1) < 0)
        break;
      i2.push(r);
    } else if (r < 2048) {
      if ((e -= 2) < 0)
        break;
      i2.push(r >> 6 | 192, r & 63 | 128);
    } else if (r < 65536) {
      if ((e -= 3) < 0)
        break;
      i2.push(r >> 12 | 224, r >> 6 & 63 | 128, r & 63 | 128);
    } else if (r < 1114112) {
      if ((e -= 4) < 0)
        break;
      i2.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, r & 63 | 128);
    } else
      throw new Error("Invalid code point");
  }
  return i2;
}
function ki(t, e, r) {
  let n = [];
  for (; e < r; ) {
    let o = t[e], i2 = null, s = o > 239 ? 4 : o > 223 ? 3 : o > 191 ? 2 : 1;
    if (e + s <= r) {
      let u, h, w, c;
      switch (s) {
        case 1:
          o < 128 && (i2 = o);
          break;
        case 2:
          u = t[e + 1], (u & 192) === 128 && (c = (o & 31) << 6 | u & 63, c > 127 && (i2 = c));
          break;
        case 3:
          u = t[e + 1], h = t[e + 2], (u & 192) === 128 && (h & 192) === 128 && (c = (o & 15) << 12 | (u & 63) << 6 | h & 63, c > 2047 && (c < 55296 || c > 57343) && (i2 = c));
          break;
        case 4:
          u = t[e + 1], h = t[e + 2], w = t[e + 3], (u & 192) === 128 && (h & 192) === 128 && (w & 192) === 128 && (c = (o & 15) << 18 | (u & 63) << 12 | (h & 63) << 6 | w & 63, c > 65535 && c < 1114112 && (i2 = c));
      }
    }
    i2 === null ? (i2 = 65533, s = 1) : i2 > 65535 && (i2 -= 65536, n.push(i2 >>> 10 & 1023 | 55296), i2 = 56320 | i2 & 1023), n.push(i2), e += s;
  }
  return wl(n);
}
var _i = 4096;
function wl(t) {
  let e = t.length;
  if (e <= _i)
    return String.fromCharCode.apply(String, t);
  let r = "", n = 0;
  for (; n < e; )
    r += String.fromCharCode.apply(String, t.slice(n, n += _i));
  return r;
}
var gl = 256, Ot = class {
  constructor(e = gl) {
    this.chunkSize = e, this.cursor = 0, this.maxCursor = -1, this.chunks = [], this._initReuseChunk = null;
  }
  reset() {
    this.cursor = 0, this.maxCursor = -1, this.chunks.length && (this.chunks = []), this._initReuseChunk !== null && (this.chunks.push(this._initReuseChunk), this.maxCursor = this._initReuseChunk.length - 1);
  }
  push(e) {
    let r = this.chunks[this.chunks.length - 1];
    if (this.cursor + e.length <= this.maxCursor + 1) {
      let o = r.length - (this.maxCursor - this.cursor) - 1;
      r.set(e, o);
    } else {
      if (r) {
        let o = r.length - (this.maxCursor - this.cursor) - 1;
        o < r.length && (this.chunks[this.chunks.length - 1] = r.subarray(0, o), this.maxCursor = this.cursor - 1);
      }
      e.length < 64 && e.length < this.chunkSize ? (r = Pi(this.chunkSize), this.chunks.push(r), this.maxCursor += r.length, this._initReuseChunk === null && (this._initReuseChunk = r), r.set(e, 0)) : (this.chunks.push(e), this.maxCursor += e.length);
    }
    this.cursor += e.length;
  }
  toBytes(e = false) {
    let r;
    if (this.chunks.length === 1) {
      let n = this.chunks[0];
      e && this.cursor > n.length / 2 ? (r = this.cursor === n.length ? n : n.subarray(0, this.cursor), this._initReuseChunk = null, this.chunks = []) : r = yt(n, 0, this.cursor);
    } else
      r = Li(this.chunks, this.cursor);
    return e && this.reset(), r;
  }
};
a();
var C = "CBOR decode error:", An = "CBOR encode error:";
function Fe(t, e, r) {
  if (t.length - e < r)
    throw new Error(`${C} not enough data for type`);
}
a();
a();
var z = [24, 256, 65536, 4294967296, BigInt("18446744073709551616")];
function ee(t, e, r) {
  Fe(t, e, 1);
  let n = t[e];
  if (r.strict === true && n < z[0])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  return n;
}
function te(t, e, r) {
  Fe(t, e, 2);
  let n = t[e] << 8 | t[e + 1];
  if (r.strict === true && n < z[1])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  return n;
}
function re(t, e, r) {
  Fe(t, e, 4);
  let n = t[e] * 16777216 + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3];
  if (r.strict === true && n < z[2])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  return n;
}
function ne(t, e, r) {
  Fe(t, e, 8);
  let n = t[e] * 16777216 + (t[e + 1] << 16) + (t[e + 2] << 8) + t[e + 3], o = t[e + 4] * 16777216 + (t[e + 5] << 16) + (t[e + 6] << 8) + t[e + 7], i2 = (BigInt(n) << BigInt(32)) + BigInt(o);
  if (r.strict === true && i2 < z[3])
    throw new Error(`${C} integer encoded in more bytes than necessary (strict decode)`);
  if (i2 <= Number.MAX_SAFE_INTEGER)
    return Number(i2);
  if (r.allowBigInt === true)
    return i2;
  throw new Error(`${C} integers outside of the safe integer range are not supported`);
}
function Mi(t, e, r, n) {
  return new b(l.uint, ee(t, e + 1, n), 2);
}
function Oi(t, e, r, n) {
  return new b(l.uint, te(t, e + 1, n), 3);
}
function zi(t, e, r, n) {
  return new b(l.uint, re(t, e + 1, n), 5);
}
function qi(t, e, r, n) {
  return new b(l.uint, ne(t, e + 1, n), 9);
}
function ce(t, e) {
  return H(t, 0, e.value);
}
function H(t, e, r) {
  if (r < z[0]) {
    let n = Number(r);
    t.push([e | n]);
  } else if (r < z[1]) {
    let n = Number(r);
    t.push([e | 24, n]);
  } else if (r < z[2]) {
    let n = Number(r);
    t.push([e | 25, n >>> 8, n & 255]);
  } else if (r < z[3]) {
    let n = Number(r);
    t.push([e | 26, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n & 255]);
  } else {
    let n = BigInt(r);
    if (n < z[4]) {
      let o = [e | 27, 0, 0, 0, 0, 0, 0, 0], i2 = Number(n & BigInt(4294967295)), s = Number(n >> BigInt(32) & BigInt(4294967295));
      o[8] = i2 & 255, i2 = i2 >> 8, o[7] = i2 & 255, i2 = i2 >> 8, o[6] = i2 & 255, i2 = i2 >> 8, o[5] = i2 & 255, o[4] = s & 255, s = s >> 8, o[3] = s & 255, s = s >> 8, o[2] = s & 255, s = s >> 8, o[1] = s & 255, t.push(o);
    } else
      throw new Error(`${C} encountered BigInt larger than allowable range`);
  }
}
ce.encodedSize = function(e) {
  return H.encodedSize(e.value);
};
H.encodedSize = function(e) {
  return e < z[0] ? 1 : e < z[1] ? 2 : e < z[2] ? 3 : e < z[3] ? 5 : 9;
};
ce.compareTokens = function(e, r) {
  return e.value < r.value ? -1 : e.value > r.value ? 1 : 0;
};
a();
function Hi(t, e, r, n) {
  return new b(l.negint, -1 - ee(t, e + 1, n), 2);
}
function ji(t, e, r, n) {
  return new b(l.negint, -1 - te(t, e + 1, n), 3);
}
function Vi(t, e, r, n) {
  return new b(l.negint, -1 - re(t, e + 1, n), 5);
}
var Tn = BigInt(-1), Gi = BigInt(1);
function Wi(t, e, r, n) {
  let o = ne(t, e + 1, n);
  if (typeof o != "bigint") {
    let i2 = -1 - o;
    if (i2 >= Number.MIN_SAFE_INTEGER)
      return new b(l.negint, i2, 9);
  }
  if (n.allowBigInt !== true)
    throw new Error(`${C} integers outside of the safe integer range are not supported`);
  return new b(l.negint, Tn - BigInt(o), 9);
}
function mr(t, e) {
  let r = e.value, n = typeof r == "bigint" ? r * Tn - Gi : r * -1 - 1;
  H(t, e.type.majorEncoded, n);
}
mr.encodedSize = function(e) {
  let r = e.value, n = typeof r == "bigint" ? r * Tn - Gi : r * -1 - 1;
  return n < z[0] ? 1 : n < z[1] ? 2 : n < z[2] ? 3 : n < z[3] ? 5 : 9;
};
mr.compareTokens = function(e, r) {
  return e.value < r.value ? 1 : e.value > r.value ? -1 : 0;
};
a();
function qt(t, e, r, n) {
  Fe(t, e, r + n);
  let o = yt(t, e + r, e + r + n);
  return new b(l.bytes, o, r + n);
}
function Ji(t, e, r, n) {
  return qt(t, e, 1, r);
}
function Xi(t, e, r, n) {
  return qt(t, e, 2, ee(t, e + 1, n));
}
function Yi(t, e, r, n) {
  return qt(t, e, 3, te(t, e + 1, n));
}
function Qi(t, e, r, n) {
  return qt(t, e, 5, re(t, e + 1, n));
}
function Zi(t, e, r, n) {
  let o = ne(t, e + 1, n);
  if (typeof o == "bigint")
    throw new Error(`${C} 64-bit integer bytes lengths not supported`);
  return qt(t, e, 9, o);
}
function yr(t) {
  return t.encodedBytes === void 0 && (t.encodedBytes = t.type === l.string ? $i(t.value) : t.value), t.encodedBytes;
}
function wt(t, e) {
  let r = yr(e);
  H(t, e.type.majorEncoded, r.length), t.push(r);
}
wt.encodedSize = function(e) {
  let r = yr(e);
  return H.encodedSize(r.length) + r.length;
};
wt.compareTokens = function(e, r) {
  return bl(yr(e), yr(r));
};
function bl(t, e) {
  return t.length < e.length ? -1 : t.length > e.length ? 1 : Ri(t, e);
}
a();
function Ht(t, e, r, n, o) {
  let i2 = r + n;
  Fe(t, e, i2);
  let s = new b(l.string, Ni(t, e + r, e + i2), i2);
  return o.retainStringBytes === true && (s.byteValue = yt(t, e + r, e + i2)), s;
}
function Ki(t, e, r, n) {
  return Ht(t, e, 1, r, n);
}
function es(t, e, r, n) {
  return Ht(t, e, 2, ee(t, e + 1, n), n);
}
function ts(t, e, r, n) {
  return Ht(t, e, 3, te(t, e + 1, n), n);
}
function rs(t, e, r, n) {
  return Ht(t, e, 5, re(t, e + 1, n), n);
}
function ns(t, e, r, n) {
  let o = ne(t, e + 1, n);
  if (typeof o == "bigint")
    throw new Error(`${C} 64-bit integer string lengths not supported`);
  return Ht(t, e, 9, o, n);
}
var os = wt;
a();
function gt(t, e, r, n) {
  return new b(l.array, n, r);
}
function is(t, e, r, n) {
  return gt(t, e, 1, r);
}
function ss(t, e, r, n) {
  return gt(t, e, 2, ee(t, e + 1, n));
}
function as(t, e, r, n) {
  return gt(t, e, 3, te(t, e + 1, n));
}
function us(t, e, r, n) {
  return gt(t, e, 5, re(t, e + 1, n));
}
function cs(t, e, r, n) {
  let o = ne(t, e + 1, n);
  if (typeof o == "bigint")
    throw new Error(`${C} 64-bit integer array lengths not supported`);
  return gt(t, e, 9, o);
}
function fs(t, e, r, n) {
  if (n.allowIndefinite === false)
    throw new Error(`${C} indefinite length items not allowed`);
  return gt(t, e, 1, 1 / 0);
}
function wr(t, e) {
  H(t, l.array.majorEncoded, e.value);
}
wr.compareTokens = ce.compareTokens;
wr.encodedSize = function(e) {
  return H.encodedSize(e.value);
};
a();
function Dt(t, e, r, n) {
  return new b(l.map, n, r);
}
function ls(t, e, r, n) {
  return Dt(t, e, 1, r);
}
function ds(t, e, r, n) {
  return Dt(t, e, 2, ee(t, e + 1, n));
}
function hs(t, e, r, n) {
  return Dt(t, e, 3, te(t, e + 1, n));
}
function ps(t, e, r, n) {
  return Dt(t, e, 5, re(t, e + 1, n));
}
function ms(t, e, r, n) {
  let o = ne(t, e + 1, n);
  if (typeof o == "bigint")
    throw new Error(`${C} 64-bit integer map lengths not supported`);
  return Dt(t, e, 9, o);
}
function ys(t, e, r, n) {
  if (n.allowIndefinite === false)
    throw new Error(`${C} indefinite length items not allowed`);
  return Dt(t, e, 1, 1 / 0);
}
function gr(t, e) {
  H(t, l.map.majorEncoded, e.value);
}
gr.compareTokens = ce.compareTokens;
gr.encodedSize = function(e) {
  return H.encodedSize(e.value);
};
a();
function ws(t, e, r, n) {
  return new b(l.tag, r, 1);
}
function gs(t, e, r, n) {
  return new b(l.tag, ee(t, e + 1, n), 2);
}
function Ds(t, e, r, n) {
  return new b(l.tag, te(t, e + 1, n), 3);
}
function bs(t, e, r, n) {
  return new b(l.tag, re(t, e + 1, n), 5);
}
function Es(t, e, r, n) {
  return new b(l.tag, ne(t, e + 1, n), 9);
}
function Dr(t, e) {
  H(t, l.tag.majorEncoded, e.value);
}
Dr.compareTokens = ce.compareTokens;
Dr.encodedSize = function(e) {
  return H.encodedSize(e.value);
};
a();
var Tl = 20, Il = 21, Sl = 22, Ul = 23;
function xs(t, e, r, n) {
  if (n.allowUndefined === false)
    throw new Error(`${C} undefined values are not supported`);
  return n.coerceUndefinedToNull === true ? new b(l.null, null, 1) : new b(l.undefined, void 0, 1);
}
function Cs(t, e, r, n) {
  if (n.allowIndefinite === false)
    throw new Error(`${C} indefinite length items not allowed`);
  return new b(l.break, void 0, 1);
}
function In(t, e, r) {
  if (r) {
    if (r.allowNaN === false && Number.isNaN(t))
      throw new Error(`${C} NaN values are not supported`);
    if (r.allowInfinity === false && (t === 1 / 0 || t === -1 / 0))
      throw new Error(`${C} Infinity values are not supported`);
  }
  return new b(l.float, t, e);
}
function Bs(t, e, r, n) {
  return In(Sn(t, e + 1), 3, n);
}
function As(t, e, r, n) {
  return In(Un(t, e + 1), 5, n);
}
function Ts(t, e, r, n) {
  return In(Fs(t, e + 1), 9, n);
}
function br(t, e, r) {
  let n = e.value;
  if (n === false)
    t.push([l.float.majorEncoded | Tl]);
  else if (n === true)
    t.push([l.float.majorEncoded | Il]);
  else if (n === null)
    t.push([l.float.majorEncoded | Sl]);
  else if (n === void 0)
    t.push([l.float.majorEncoded | Ul]);
  else {
    let o, i2 = false;
    (!r || r.float64 !== true) && (Ss(n), o = Sn(me, 1), n === o || Number.isNaN(n) ? (me[0] = 249, t.push(me.slice(0, 3)), i2 = true) : (Us(n), o = Un(me, 1), n === o && (me[0] = 250, t.push(me.slice(0, 5)), i2 = true))), i2 || (Fl(n), o = Fs(me, 1), me[0] = 251, t.push(me.slice(0, 9)));
  }
}
br.encodedSize = function(e, r) {
  let n = e.value;
  if (n === false || n === true || n === null || n === void 0)
    return 1;
  if (!r || r.float64 !== true) {
    Ss(n);
    let o = Sn(me, 1);
    if (n === o || Number.isNaN(n))
      return 3;
    if (Us(n), o = Un(me, 1), n === o)
      return 5;
  }
  return 9;
};
var Is = new ArrayBuffer(9), fe = new DataView(Is, 1), me = new Uint8Array(Is, 0);
function Ss(t) {
  if (t === 1 / 0)
    fe.setUint16(0, 31744, false);
  else if (t === -1 / 0)
    fe.setUint16(0, 64512, false);
  else if (Number.isNaN(t))
    fe.setUint16(0, 32256, false);
  else {
    fe.setFloat32(0, t);
    let e = fe.getUint32(0), r = (e & 2139095040) >> 23, n = e & 8388607;
    if (r === 255)
      fe.setUint16(0, 31744, false);
    else if (r === 0)
      fe.setUint16(0, (t & 2147483648) >> 16 | n >> 13, false);
    else {
      let o = r - 127;
      o < -24 ? fe.setUint16(0, 0) : o < -14 ? fe.setUint16(0, (e & 2147483648) >> 16 | 1 << 24 + o, false) : fe.setUint16(0, (e & 2147483648) >> 16 | o + 15 << 10 | n >> 13, false);
    }
  }
}
function Sn(t, e) {
  if (t.length - e < 2)
    throw new Error(`${C} not enough data for float16`);
  let r = (t[e] << 8) + t[e + 1];
  if (r === 31744)
    return 1 / 0;
  if (r === 64512)
    return -1 / 0;
  if (r === 32256)
    return NaN;
  let n = r >> 10 & 31, o = r & 1023, i2;
  return n === 0 ? i2 = o * 2 ** -24 : n !== 31 ? i2 = (o + 1024) * 2 ** (n - 25) : i2 = o === 0 ? 1 / 0 : NaN, r & 32768 ? -i2 : i2;
}
function Us(t) {
  fe.setFloat32(0, t, false);
}
function Un(t, e) {
  if (t.length - e < 4)
    throw new Error(`${C} not enough data for float32`);
  let r = (t.byteOffset || 0) + e;
  return new DataView(t.buffer, r, 4).getFloat32(0, false);
}
function Fl(t) {
  fe.setFloat64(0, t, false);
}
function Fs(t, e) {
  if (t.length - e < 8)
    throw new Error(`${C} not enough data for float64`);
  let r = (t.byteOffset || 0) + e;
  return new DataView(t.buffer, r, 8).getFloat64(0, false);
}
br.compareTokens = ce.compareTokens;
function U(t, e, r) {
  throw new Error(`${C} encountered invalid minor (${r}) for major ${t[e] >>> 5}`);
}
function Er(t) {
  return () => {
    throw new Error(`${C} ${t}`);
  };
}
var D = [];
for (let t = 0; t <= 23; t++)
  D[t] = U;
D[24] = Mi;
D[25] = Oi;
D[26] = zi;
D[27] = qi;
D[28] = U;
D[29] = U;
D[30] = U;
D[31] = U;
for (let t = 32; t <= 55; t++)
  D[t] = U;
D[56] = Hi;
D[57] = ji;
D[58] = Vi;
D[59] = Wi;
D[60] = U;
D[61] = U;
D[62] = U;
D[63] = U;
for (let t = 64; t <= 87; t++)
  D[t] = Ji;
D[88] = Xi;
D[89] = Yi;
D[90] = Qi;
D[91] = Zi;
D[92] = U;
D[93] = U;
D[94] = U;
D[95] = Er("indefinite length bytes/strings are not supported");
for (let t = 96; t <= 119; t++)
  D[t] = Ki;
D[120] = es;
D[121] = ts;
D[122] = rs;
D[123] = ns;
D[124] = U;
D[125] = U;
D[126] = U;
D[127] = Er("indefinite length bytes/strings are not supported");
for (let t = 128; t <= 151; t++)
  D[t] = is;
D[152] = ss;
D[153] = as;
D[154] = us;
D[155] = cs;
D[156] = U;
D[157] = U;
D[158] = U;
D[159] = fs;
for (let t = 160; t <= 183; t++)
  D[t] = ls;
D[184] = ds;
D[185] = hs;
D[186] = ps;
D[187] = ms;
D[188] = U;
D[189] = U;
D[190] = U;
D[191] = ys;
for (let t = 192; t <= 215; t++)
  D[t] = ws;
D[216] = gs;
D[217] = Ds;
D[218] = bs;
D[219] = Es;
D[220] = U;
D[221] = U;
D[222] = U;
D[223] = U;
for (let t = 224; t <= 243; t++)
  D[t] = Er("simple values are not supported");
D[244] = U;
D[245] = U;
D[246] = U;
D[247] = xs;
D[248] = Er("simple values are not supported");
D[249] = Bs;
D[250] = As;
D[251] = Ts;
D[252] = U;
D[253] = U;
D[254] = U;
D[255] = Cs;
var ye = [];
for (let t = 0; t < 24; t++)
  ye[t] = new b(l.uint, t, 1);
for (let t = -1; t >= -24; t--)
  ye[31 - t] = new b(l.negint, t, 1);
ye[64] = new b(l.bytes, new Uint8Array(0), 1);
ye[96] = new b(l.string, "", 1);
ye[128] = new b(l.array, 0, 1);
ye[160] = new b(l.map, 0, 1);
ye[244] = new b(l.false, false, 1);
ye[245] = new b(l.true, true, 1);
ye[246] = new b(l.null, null, 1);
function vs(t) {
  switch (t.type) {
    case l.false:
      return Ce([244]);
    case l.true:
      return Ce([245]);
    case l.null:
      return Ce([246]);
    case l.bytes:
      return t.value.length ? void 0 : Ce([64]);
    case l.string:
      return t.value === "" ? Ce([96]) : void 0;
    case l.array:
      return t.value === 0 ? Ce([128]) : void 0;
    case l.map:
      return t.value === 0 ? Ce([160]) : void 0;
    case l.uint:
      return t.value < 24 ? Ce([Number(t.value)]) : void 0;
    case l.negint:
      if (t.value >= -24)
        return Ce([31 - Number(t.value)]);
  }
}
var kl = { float64: false, mapSorter: $l, quickEncodeToken: vs };
function _l() {
  let t = [];
  return t[l.uint.major] = ce, t[l.negint.major] = mr, t[l.bytes.major] = wt, t[l.string.major] = os, t[l.array.major] = wr, t[l.map.major] = gr, t[l.tag.major] = Dr, t[l.float.major] = br, t;
}
var ks = _l(), Fn = new Ot(), bt = class {
  constructor(e, r) {
    this.obj = e, this.parent = r;
  }
  includes(e) {
    let r = this;
    do
      if (r.obj === e)
        return true;
    while (r = r.parent);
    return false;
  }
  static createCheck(e, r) {
    if (e && e.includes(r))
      throw new Error(`${An} object contains circular references`);
    return new bt(r, e);
  }
}, Oe = { null: new b(l.null, null), undefined: new b(l.undefined, void 0), true: new b(l.true, true), false: new b(l.false, false), emptyArray: new b(l.array, 0), emptyMap: new b(l.map, 0) }, ze = { number(t, e, r, n) {
  return !Number.isInteger(t) || !Number.isSafeInteger(t) ? new b(l.float, t) : t >= 0 ? new b(l.uint, t) : new b(l.negint, t);
}, bigint(t, e, r, n) {
  return t >= BigInt(0) ? new b(l.uint, t) : new b(l.negint, t);
}, Uint8Array(t, e, r, n) {
  return new b(l.bytes, t);
}, string(t, e, r, n) {
  return new b(l.string, t);
}, boolean(t, e, r, n) {
  return t ? Oe.true : Oe.false;
}, null(t, e, r, n) {
  return Oe.null;
}, undefined(t, e, r, n) {
  return Oe.undefined;
}, ArrayBuffer(t, e, r, n) {
  return new b(l.bytes, new Uint8Array(t));
}, DataView(t, e, r, n) {
  return new b(l.bytes, new Uint8Array(t.buffer, t.byteOffset, t.byteLength));
}, Array(t, e, r, n) {
  if (!t.length)
    return r.addBreakTokens === true ? [Oe.emptyArray, new b(l.break)] : Oe.emptyArray;
  n = bt.createCheck(n, t);
  let o = [], i2 = 0;
  for (let s of t)
    o[i2++] = xr(s, r, n);
  return r.addBreakTokens ? [new b(l.array, t.length), o, new b(l.break)] : [new b(l.array, t.length), o];
}, Object(t, e, r, n) {
  let o = e !== "Object", i2 = o ? t.keys() : Object.keys(t), s = o ? t.size : i2.length;
  if (!s)
    return r.addBreakTokens === true ? [Oe.emptyMap, new b(l.break)] : Oe.emptyMap;
  n = bt.createCheck(n, t);
  let u = [], h = 0;
  for (let w of i2)
    u[h++] = [xr(w, r, n), xr(o ? t.get(w) : t[w], r, n)];
  return Nl(u, r), r.addBreakTokens ? [new b(l.map, s), u, new b(l.break)] : [new b(l.map, s), u];
} };
ze.Map = ze.Object;
ze.Buffer = ze.Uint8Array;
for (let t of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))
  ze[`${t}Array`] = ze.DataView;
function xr(t, e = {}, r) {
  let n = Fi(t), o = e && e.typeEncoders && e.typeEncoders[n] || ze[n];
  if (typeof o == "function") {
    let s = o(t, n, e, r);
    if (s != null)
      return s;
  }
  let i2 = ze[n];
  if (!i2)
    throw new Error(`${An} unsupported type: ${n}`);
  return i2(t, n, e, r);
}
function Nl(t, e) {
  e.mapSorter && t.sort(e.mapSorter);
}
function $l(t, e) {
  let r = Array.isArray(t[0]) ? t[0][0] : t[0], n = Array.isArray(e[0]) ? e[0][0] : e[0];
  if (r.type !== n.type)
    return r.type.compare(n.type);
  let o = r.type.major, i2 = ks[o].compareTokens(r, n);
  return i2 === 0 && console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"), i2;
}
function _s(t, e, r, n) {
  if (Array.isArray(e))
    for (let o of e)
      _s(t, o, r, n);
  else
    r[e.type.major](t, e, n);
}
function Ll(t, e, r) {
  let n = xr(t, r);
  if (!Array.isArray(n) && r.quickEncodeToken) {
    let o = r.quickEncodeToken(n);
    if (o)
      return o;
    let i2 = e[n.type.major];
    if (i2.encodedSize) {
      let s = i2.encodedSize(n, r), u = new Ot(s);
      if (i2(u, n, r), u.chunks.length !== 1)
        throw new Error(`Unexpected error: pre-calculated length for ${n} was wrong`);
      return Bn(u.chunks[0]);
    }
  }
  return Fn.reset(), _s(Fn, n, e, r), Fn.toBytes(true);
}
function vn(t, e) {
  return e = Object.assign({}, kl, e), Ll(t, ks, e);
}
a();
var Pl = { strict: false, allowIndefinite: true, allowUndefined: true, allowBigInt: true }, kn = class {
  constructor(e, r = {}) {
    this.pos = 0, this.data = e, this.options = r;
  }
  done() {
    return this.pos >= this.data.length;
  }
  next() {
    let e = this.data[this.pos], r = ye[e];
    if (r === void 0) {
      let n = D[e];
      if (!n)
        throw new Error(`${C} no decoder for major type ${e >>> 5} (byte 0x${e.toString(16).padStart(2, "0")})`);
      let o = e & 31;
      r = n(this.data, this.pos, o, this.options);
    }
    return this.pos += r.encodedLength, r;
  }
}, jt = Symbol.for("DONE"), Cr = Symbol.for("BREAK");
function Rl(t, e, r) {
  let n = [];
  for (let o = 0; o < t.value; o++) {
    let i2 = Vt(e, r);
    if (i2 === Cr) {
      if (t.value === 1 / 0)
        break;
      throw new Error(`${C} got unexpected break to lengthed array`);
    }
    if (i2 === jt)
      throw new Error(`${C} found array but not enough entries (got ${o}, expected ${t.value})`);
    n[o] = i2;
  }
  return n;
}
function Ml(t, e, r) {
  let n = r.useMaps === true, o = n ? void 0 : {}, i2 = n ? /* @__PURE__ */ new Map() : void 0;
  for (let s = 0; s < t.value; s++) {
    let u = Vt(e, r);
    if (u === Cr) {
      if (t.value === 1 / 0)
        break;
      throw new Error(`${C} got unexpected break to lengthed map`);
    }
    if (u === jt)
      throw new Error(`${C} found map but not enough entries (got ${s} [no key], expected ${t.value})`);
    if (n !== true && typeof u != "string")
      throw new Error(`${C} non-string keys not supported (got ${typeof u})`);
    let h = Vt(e, r);
    if (h === jt)
      throw new Error(`${C} found map but not enough entries (got ${s} [no value], expected ${t.value})`);
    n ? i2.set(u, h) : o[u] = h;
  }
  return n ? i2 : o;
}
function Vt(t, e) {
  if (t.done())
    return jt;
  let r = t.next();
  if (r.type === l.break)
    return Cr;
  if (r.type.terminal)
    return r.value;
  if (r.type === l.array)
    return Rl(r, t, e);
  if (r.type === l.map)
    return Ml(r, t, e);
  if (r.type === l.tag) {
    if (e.tags && typeof e.tags[r.value] == "function") {
      let n = Vt(t, e);
      return e.tags[r.value](n);
    }
    throw new Error(`${C} tag not supported (${r.value})`);
  }
  throw new Error("unsupported");
}
function _n(t, e) {
  if (!(t instanceof Uint8Array))
    throw new Error(`${C} data to decode must be a Uint8Array`);
  e = Object.assign({}, Pl, e);
  let r = e.tokenizer || new kn(t, e), n = Vt(r, e);
  if (n === jt)
    throw new Error(`${C} did not find any content to decode`);
  if (n === Cr)
    throw new Error(`${C} got unexpected break`);
  if (!r.done())
    throw new Error(`${C} too many terminals, data makes no sense`);
  return n;
}
Q();
var Ns = 42;
function zl(t) {
  if (t.asCID !== t)
    return null;
  let e = x.asCID(t);
  if (!e)
    return null;
  let r = new Uint8Array(e.bytes.byteLength + 1);
  return r.set(e.bytes, 1), [new b(l.tag, Ns), new b(l.bytes, r)];
}
function ql() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function Hl(t) {
  if (Number.isNaN(t))
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  if (t === 1 / 0 || t === -1 / 0)
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  return null;
}
var jl = { float64: true, typeEncoders: { Object: zl, undefined: ql, number: Hl } };
function Vl(t) {
  if (t[0] !== 0)
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  return x.decode(t.subarray(1));
}
var $s = { allowIndefinite: false, coerceUndefinedToNull: true, allowNaN: false, allowInfinity: false, allowBigInt: true, strict: true, useMaps: false, tags: [] };
$s.tags[Ns] = Vl;
var Ls = (t) => vn(t, jl), Ps = (t) => _n(t, $s);
function $n(t) {
  let e = Ls({ version: 1, roots: t }), r = Nn.default.encode(e.length), n = new Uint8Array(r.length + e.length);
  return n.set(r, 0), n.set(e, r.length), n;
}
function Rs(t) {
  return { async setRoots(e) {
    let r = $n(e);
    await t.write(r);
  }, async writeBlock(e) {
    let { cid: r, bytes: n } = e;
    await t.write(new Uint8Array(Nn.default.encode(r.bytes.length + n.length))), await t.write(r.bytes), n.length && await t.write(n);
  }, async close() {
    await t.end();
  } };
}
a();
function Br() {
}
function Ms() {
  let t = [], e = null, r = Br, n = false, o = null, i2 = Br, s = () => (e || (e = new Promise((w) => {
    r = () => {
      e = null, r = Br, w();
    };
  })), e), u = { write(w) {
    t.push(w);
    let c = s();
    return i2(), c;
  }, async end() {
    n = true;
    let w = s();
    i2(), await w;
  } }, h = { async next() {
    let w = t.shift();
    return w ? (t.length === 0 && r(), { done: false, value: w }) : n ? (r(), { done: true, value: void 0 }) : (o || (o = new Promise((c) => {
      i2 = () => (o = null, i2 = Br, c(h.next()));
    })), o);
  } };
  return { writer: u, iterator: h };
}
a();
var He = J(pt(), 1);
Q();
Le();
a();
var qe = { Null: (t) => t === null, Int: (t) => Number.isInteger(t), Float: (t) => typeof t == "number" && Number.isFinite(t), String: (t) => typeof t == "string", Bool: (t) => typeof t == "boolean", Bytes: (t) => t instanceof Uint8Array, Link: (t) => !qe.Null(t) && typeof t == "object" && t.asCID === t, List: (t) => Array.isArray(t), Map: (t) => !qe.Null(t) && typeof t == "object" && t.asCID !== t && !qe.List(t) && !qe.Bytes(t) }, Et = { Int: qe.Int, "CarHeader > version": (t) => Et.Int(t), "CarHeader > roots (anon) > valueType (anon)": qe.Link, "CarHeader > roots (anon)": (t) => qe.List(t) && Array.prototype.every.call(t, Et["CarHeader > roots (anon) > valueType (anon)"]), "CarHeader > roots": (t) => Et["CarHeader > roots (anon)"](t), CarHeader: (t) => {
  let e = t && Object.keys(t);
  return qe.Map(t) && ["version"].every((r) => e.includes(r)) && Object.entries(t).every(([r, n]) => Et["CarHeader > " + r] && Et["CarHeader > " + r](n));
} }, Os = Et.CarHeader;
var Ln = { SHA2_256: 18, LENGTH: 32, DAG_PB: 112 }, zs = 16 + 8 + 8 + 8;
async function Ar(t) {
  let e = await t.upTo(8);
  if (!e.length)
    throw new Error("Unexpected end of data");
  let r = He.default.decode(e);
  return t.seek(He.default.decode.bytes), r;
}
async function Gl(t) {
  let e = await t.exactly(zs), r = new DataView(e.buffer, e.byteOffset, e.byteLength), n = 0, o = { version: 2, characteristics: [r.getBigUint64(n, true), r.getBigUint64(n += 8, true)], dataOffset: Number(r.getBigUint64(n += 8, true)), dataSize: Number(r.getBigUint64(n += 8, true)), indexOffset: Number(r.getBigUint64(n += 8, true)) };
  return t.seek(zs), o;
}
async function Tr(t, e) {
  let r = await Ar(t);
  if (r === 0)
    throw new Error("Invalid CAR header (zero length)");
  let n = await t.exactly(r);
  t.seek(r);
  let o = Ps(n);
  if (!Os(o))
    throw new Error("Invalid CAR header format");
  if (o.version !== 1 && o.version !== 2 || e !== void 0 && o.version !== e)
    throw new Error(`Invalid CAR version: ${o.version}${e !== void 0 ? ` (expected ${e})` : ""}`);
  let i2 = Array.isArray(o.roots);
  if (o.version === 1 && !i2 || o.version === 2 && i2)
    throw new Error("Invalid CAR header format");
  if (o.version === 1)
    return o;
  let s = await Gl(t);
  t.seek(s.dataOffset - t.pos);
  let u = await Tr(t, 1);
  return Object.assign(u, s);
}
async function Wl(t) {
  let e = await t.upTo(8);
  He.default.decode(e);
  let r = He.default.decode.bytes, n = He.default.decode(e.subarray(He.default.decode.bytes)), o = He.default.decode.bytes, i2 = r + o + n, s = await t.exactly(i2);
  return t.seek(i2), s;
}
async function Jl(t) {
  let e = await t.exactly(2);
  if (e[0] === Ln.SHA2_256 && e[1] === Ln.LENGTH) {
    let s = await t.exactly(34);
    t.seek(34);
    let u = ft(s);
    return x.create(0, Ln.DAG_PB, u);
  }
  let r = await Ar(t);
  if (r !== 1)
    throw new Error(`Unexpected CID version (${r})`);
  let n = await Ar(t), o = await Wl(t), i2 = ft(o);
  return x.create(r, n, i2);
}
async function qs(t) {
  let e = t.pos, r = await Ar(t);
  if (r === 0)
    throw new Error("Invalid CAR section (zero length)");
  r += t.pos - e;
  let n = await Jl(t), o = r - Number(t.pos - e);
  return { cid: n, length: r, blockLength: o };
}
async function Xl(t) {
  let { cid: e, blockLength: r } = await qs(t), n = await t.exactly(r);
  return t.seek(r), { bytes: n, cid: e };
}
async function Yl(t) {
  let e = t.pos, { cid: r, length: n, blockLength: o } = await qs(t), i2 = { cid: r, length: n, blockLength: o, offset: e, blockOffset: t.pos };
  return t.seek(i2.blockLength), i2;
}
function Hs(t) {
  let e = (async () => {
    let r = await Tr(t);
    if (r.version === 2) {
      let n = t.pos - r.dataOffset;
      t = Zl(t, r.dataSize - n);
    }
    return r;
  })();
  return { header: () => e, async *blocks() {
    for (await e; (await t.upTo(8)).length > 0; )
      yield await Xl(t);
  }, async *blocksIndex() {
    for (await e; (await t.upTo(8)).length > 0; )
      yield await Yl(t);
  } };
}
function Ir(t) {
  let e = 0;
  return { async upTo(r) {
    return t.subarray(e, e + Math.min(r, t.length - e));
  }, async exactly(r) {
    if (r > t.length - e)
      throw new Error("Unexpected end of data");
    return t.subarray(e, e + r);
  }, seek(r) {
    e += r;
  }, get pos() {
    return e;
  } };
}
function Ql(t) {
  let e = 0, r = 0, n = 0, o = new Uint8Array(0), i2 = async (s) => {
    r = o.length - n;
    let u = [o.subarray(n)];
    for (; r < s; ) {
      let w = await t();
      if (w == null)
        break;
      r < 0 ? w.length > r && u.push(w.subarray(-r)) : u.push(w), r += w.length;
    }
    o = new Uint8Array(u.reduce((w, c) => w + c.length, 0));
    let h = 0;
    for (let w of u)
      o.set(w, h), h += w.length;
    n = 0;
  };
  return { async upTo(s) {
    return o.length - n < s && await i2(s), o.subarray(n, n + Math.min(o.length - n, s));
  }, async exactly(s) {
    if (o.length - n < s && await i2(s), o.length - n < s)
      throw new Error("Unexpected end of data");
    return o.subarray(n, n + s);
  }, seek(s) {
    e += s, n += s;
  }, get pos() {
    return e;
  } };
}
function js(t) {
  let e = t[Symbol.asyncIterator]();
  async function r() {
    let n = await e.next();
    return n.done ? null : n.value;
  }
  return Ql(r);
}
function Zl(t, e) {
  let r = 0;
  return { async upTo(n) {
    let o = await t.upTo(n);
    return o.length + r > e && (o = o.subarray(0, e - r)), o;
  }, async exactly(n) {
    let o = await t.exactly(n);
    if (o.length + r > e)
      throw new Error("Unexpected end of data");
    return o;
  }, seek(n) {
    r += n, t.seek(n);
  }, get pos() {
    return t.pos;
  } };
}
var Qe = class {
  constructor(e, r) {
    this._encoder = r, this._mutex = r.setRoots(e), this._ended = false;
  }
  async put(e) {
    if (!(e.bytes instanceof Uint8Array) || !e.cid)
      throw new TypeError("Can only write {cid, bytes} objects");
    if (this._ended)
      throw new Error("Already closed");
    let r = x.asCID(e.cid);
    if (!r)
      throw new TypeError("Can only write {cid, bytes} objects");
    return this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid: r, bytes: e.bytes })), this._mutex;
  }
  async close() {
    if (this._ended)
      throw new Error("Already closed");
    return await this._mutex, this._ended = true, this._encoder.close();
  }
  static create(e) {
    e = Kl(e);
    let { encoder: r, iterator: n } = Vs(), o = new Qe(e, r), i2 = new Sr(n);
    return { writer: o, out: i2 };
  }
  static createAppender() {
    let { encoder: e, iterator: r } = Vs();
    e.setRoots = () => Promise.resolve();
    let n = new Qe([], e), o = new Sr(r);
    return { writer: n, out: o };
  }
  static async updateRootsInBytes(e, r) {
    let n = Ir(e);
    await Tr(n);
    let o = $n(r);
    if (Number(n.pos) !== o.length)
      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${n.pos} bytes, new header is ${o.length} bytes)`);
    return e.set(o, 0), e;
  }
}, Sr = class {
  constructor(e) {
    this._iterator = e;
  }
  [Symbol.asyncIterator]() {
    if (this._iterating)
      throw new Error("Multiple iterator not supported");
    return this._iterating = true, this._iterator;
  }
};
function Vs() {
  let t = Ms(), { writer: e, iterator: r } = t;
  return { encoder: Rs(e), iterator: r };
}
function Kl(t) {
  if (t === void 0)
    return [];
  if (!Array.isArray(t)) {
    let r = x.asCID(t);
    if (!r)
      throw new TypeError("roots must be a single CID or an array of CIDs");
    return [r];
  }
  let e = [];
  for (let r of t) {
    let n = x.asCID(r);
    if (!n)
      throw new TypeError("roots must be a single CID or an array of CIDs");
    e.push(n);
  }
  return e;
}
a();
var na = J(Zs(), 1), oa = J(ea(), 1);
a();
var rd = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
T.nanosecond = T.ns = 1 / 1e6;
T.\u00B5s = T.\u03BCs = T.us = T.microsecond = 1 / 1e3;
T.millisecond = T.ms = T[""] = 1;
T.second = T.sec = T.s = T.ms * 1e3;
T.minute = T.min = T.m = T.s * 60;
T.hour = T.hr = T.h = T.m * 60;
T.day = T.d = T.h * 24;
T.week = T.wk = T.w = T.d * 7;
T.month = T.b = T.d * (365.25 / 12);
T.year = T.yr = T.y = T.d * 365.25;
function T(t = "", e = "ms") {
  var r = null;
  return t = (t + "").replace(/(\d)[,_](\d)/g, "$1$2"), t.replace(rd, function(n, o, i2) {
    i2 = ta(i2), i2 && (r = (r || 0) + parseFloat(o, 10) * i2);
  }), r && r / (ta(e) || 1);
}
function ta(t) {
  return T[t] || T[t.toLowerCase().replace(/s$/, "")];
}
var ra = T;
a();
var ve = class extends Error {
  constructor(e = "request timed out") {
    super(e), this.name = "TimeoutError", this.code = ve.code;
  }
};
ve.code = "ERR_TIMEOUT";
function le(t, e) {
  return (...r) => {
    let n = r[e != null ? e : r.length - 1];
    if (!n || !n.timeout)
      return t(...r);
    let o = typeof n.timeout == "string" ? ra(n.timeout) : n.timeout, i2 = new na.TimeoutController(o);
    n.signal = (0, oa.anySignal)([n.signal, i2.signal]);
    let s = t(...r), u = new Promise((c, g) => {
      i2.signal.addEventListener("abort", () => {
        g(new ve());
      });
    }), h = Date.now(), w = () => {
      if (i2.signal.aborted)
        throw new ve();
      if (Date.now() - h > o)
        throw i2.abort(), new ve();
    };
    return s[Symbol.asyncIterator] ? async function* () {
      let c = s[Symbol.asyncIterator]();
      try {
        for (; ; ) {
          let { value: g, done: B } = await Promise.race([c.next(), u]);
          if (B)
            break;
          w(), yield g;
        }
      } catch (g) {
        throw w(), g;
      } finally {
        i2.clear(), c.return && c.return();
      }
    }() : (async () => {
      try {
        let c = await Promise.race([s, u]);
        return w(), c;
      } catch (c) {
        throw w(), c;
      } finally {
        i2.clear();
      }
    })();
  };
}
a();
var Be = J(ca(), 1);
Re();
ht();
zn();
Be.default.formatters.b = (t) => t == null ? "undefined" : Y.baseEncode(t);
Be.default.formatters.t = (t) => t == null ? "undefined" : Me.baseEncode(t);
Be.default.formatters.m = (t) => t == null ? "undefined" : Mn.baseEncode(t);
Be.default.formatters.p = (t) => t == null ? "undefined" : t.toString();
Be.default.formatters.c = (t) => t == null ? "undefined" : t.toString();
Be.default.formatters.k = (t) => t == null ? "undefined" : t.toString();
function kr(t) {
  return Object.assign((0, Be.default)(t), { error: (0, Be.default)(`${t}:error`), trace: (0, Be.default)(`${t}:trace`) });
}
qn();
Hn();
a();
Re();
var jn = async ({ cid: t, load: e, seen: r }) => {
  r = r || /* @__PURE__ */ new Set();
  let n = t.toString(Y);
  if (r.has(n))
    return;
  let o = await e(t);
  if (r.add(n), o !== null)
    for (let [, i2] of o.links())
      await jn({ cid: i2, load: e, seen: r });
};
var pa = kr("ipfs:components:dag:import"), gd = [fa, da];
function ma({ repo: t, preload: e, codecs: r }) {
  async function* n(o, i2 = {}) {
    i2.preload !== false && e(o);
    let s = x.asCID(o);
    if (!s)
      throw new Error(`Unexpected error converting CID type: ${o}`);
    pa(`Exporting ${s} as car`);
    let { writer: u, out: h } = await Qe.create([s]), w = null;
    (async () => {
      try {
        let c = Dd(t, u, { signal: i2.signal, timeout: i2.timeout }, r);
        await jn({ cid: s, load: c });
      } catch (c) {
        w = c;
      } finally {
        u.close();
      }
    })();
    for await (let c of h) {
      if (w)
        break;
      yield c;
    }
    if (w)
      throw w;
  }
  return le(n);
}
function Dd(t, e, r, n) {
  return async (o) => {
    let i2 = await n.getCodec(o.code);
    if (!i2)
      throw new Error(`Can't decode links in block with codec 0x${o.code.toString(16)} to form complete DAG`);
    let s = await t.blocks.get(o, r);
    return pa(`Adding block ${o} to car`), await e.put({ cid: o, bytes: s }), gd.includes(o.code) ? null : bi({ bytes: s, cid: o, codec: i2 });
  };
}
a();
var ic = J(wa(), 1), sc = J(Da(), 1);
a();
J(Ku(), 1);
Q();
a();
a();
a();
var ec = (t = 21) => crypto.getRandomValues(new Uint8Array(t)).reduce((e, r) => (r &= 63, r < 36 ? e += r.toString(36) : r < 62 ? e += (r - 26).toString(36).toUpperCase() : r > 62 ? e += "-" : e += "_", e), "");
Ke();
fo();
var ke = "/", tc = new TextEncoder().encode(ke), Vr = tc[0], G = class {
  constructor(e, r) {
    if (typeof e == "string")
      this._buf = co(e);
    else if (e instanceof Uint8Array)
      this._buf = e;
    else
      throw new Error("Invalid key, should be String of Uint8Array");
    if (r == null && (r = true), r && this.clean(), this._buf.byteLength === 0 || this._buf[0] !== Vr)
      throw new Error("Invalid key");
  }
  toString(e = "utf8") {
    return so(this._buf, e);
  }
  uint8Array() {
    return this._buf;
  }
  get [Symbol.toStringTag]() {
    return `Key(${this.toString()})`;
  }
  static withNamespaces(e) {
    return new G(e.join(ke));
  }
  static random() {
    return new G(ec().replace(/-/g, ""));
  }
  static asKey(e) {
    return e instanceof Uint8Array || typeof e == "string" ? new G(e) : e.uint8Array ? new G(e.uint8Array()) : null;
  }
  clean() {
    if ((!this._buf || this._buf.byteLength === 0) && (this._buf = tc), this._buf[0] !== Vr) {
      let e = new Uint8Array(this._buf.byteLength + 1);
      e.fill(Vr, 0, 1), e.set(this._buf, 1), this._buf = e;
    }
    for (; this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === Vr; )
      this._buf = this._buf.subarray(0, -1);
  }
  less(e) {
    let r = this.list(), n = e.list();
    for (let o = 0; o < r.length; o++) {
      if (n.length < o + 1)
        return false;
      let i2 = r[o], s = n[o];
      if (i2 < s)
        return true;
      if (i2 > s)
        return false;
    }
    return r.length < n.length;
  }
  reverse() {
    return G.withNamespaces(this.list().slice().reverse());
  }
  namespaces() {
    return this.list();
  }
  baseNamespace() {
    let e = this.namespaces();
    return e[e.length - 1];
  }
  list() {
    return this.toString().split(ke).slice(1);
  }
  type() {
    return Lh(this.baseNamespace());
  }
  name() {
    return Ph(this.baseNamespace());
  }
  instance(e) {
    return new G(this.toString() + ":" + e);
  }
  path() {
    let e = this.parent().toString();
    return e.endsWith(ke) || (e += ke), e += this.type(), new G(e);
  }
  parent() {
    let e = this.list();
    return e.length === 1 ? new G(ke) : new G(e.slice(0, -1).join(ke));
  }
  child(e) {
    return this.toString() === ke ? e : e.toString() === ke ? this : new G(this.toString() + e.toString(), false);
  }
  isAncestorOf(e) {
    return e.toString() === this.toString() ? false : e.toString().startsWith(this.toString());
  }
  isDecendantOf(e) {
    return e.toString() === this.toString() ? false : this.toString().startsWith(e.toString());
  }
  isTopLevel() {
    return this.list().length === 1;
  }
  concat(...e) {
    return G.withNamespaces([...this.namespaces(), ...Rh(e.map((r) => r.namespaces()))]);
  }
};
function Lh(t) {
  let e = t.split(":");
  return e.length < 2 ? "" : e.slice(0, -1).join(":");
}
function Ph(t) {
  let e = t.split(":");
  return e[e.length - 1];
}
function Rh(t) {
  return [].concat(...t);
}
var _o = J(Yt(), 1);
a();
Q();
var ko = J(Yt(), 1), rc = "/ipfs/";
function Gr(t) {
  if (t instanceof Uint8Array)
    try {
      t = x.decode(t);
    } catch (o) {
      throw (0, ko.default)(o, "ERR_INVALID_CID");
    }
  let e = x.asCID(t);
  if (e)
    return { cid: e, path: void 0 };
  t = t.toString(), t.startsWith(rc) && (t = t.substring(rc.length));
  let r = t.split("/"), n;
  try {
    e = x.parse(r.shift() || "");
  } catch (o) {
    throw (0, ko.default)(o, "ERR_INVALID_CID");
  }
  return r.length && (n = `/${r.join("/")}`), { cid: e, path: n };
}
a();
Q();
a();
new TextDecoder();
a();
new TextEncoder();
a();
Q();
new TextEncoder();
var nc = 112;
new G("/local/filesroot");
var oc = async function(t, e, r, n = {}) {
  let { cid: o, path: i2 } = Gr(r);
  i2 && (n.path = i2);
  let s = o, u = n.path || "";
  if (u.startsWith("/") && (u = u.substring(1)), n.path)
    try {
      for await (let { value: h, remainderPath: w } of Wr(o, n.path, e, t, { signal: n.signal })) {
        if (!x.asCID(h))
          break;
        u = w, s = h;
      }
    } catch (h) {
      throw h.message.startsWith("Object has no property") && (h.message = `no link named "${u.split("/")[0]}" under ${s}`, h.code = "ERR_NO_LINK"), h;
    }
  return { cid: s, remainderPath: u || "" };
};
var Wr = async function* (t, e, r, n, o) {
  let i2 = async (w) => {
    let c = await r.getCodec(w.code), g = await n.blocks.get(w, o);
    return c.decode(g);
  }, s = e.split("/").filter(Boolean), u = await i2(t), h = t;
  for (; s.length; ) {
    let w = s.shift();
    if (!w)
      throw (0, _o.default)(new Error(`Could not resolve path "${e}"`), "ERR_INVALID_PATH");
    if (t.code === nc && Array.isArray(u.Links)) {
      let c = u.Links.find((g) => g.Name === w);
      if (c) {
        yield { value: c.Hash, remainderPath: s.join("/") }, u = await i2(c.Hash), h = c.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(u, w))
      u = u[w], yield { value: u, remainderPath: s.join("/") };
    else
      throw (0, _o.default)(new Error(`no link named "${w}" under ${h}`), "ERR_NO_LINK");
    x.asCID(u) && (h = u, u = await i2(u));
  }
  yield { value: u, remainderPath: "" };
};
var ac = J(Yt(), 1);
function uc({ codecs: t, repo: e, preload: r }) {
  return le(async function(i2, s = {}) {
    if (s.preload !== false && r(i2), s.path) {
      let g = s.localResolve ? await (0, ic.default)(Wr(i2, s.path, t, e, s)) : await (0, sc.default)(Wr(i2, s.path, t, e, s));
      if (!g)
        throw (0, ac.default)(new Error("Not found"), "ERR_NOT_FOUND");
      return g;
    }
    let u = await t.getCodec(i2.code), h = await e.blocks.get(i2, s);
    return { value: u.decode(h), remainderPath: "" };
  });
}
a();
a();
var Jr = class {
  constructor(e, r, n) {
    this._version = e, this._roots = r, this._iterable = n, this._decoded = false;
  }
  get version() {
    return this._version;
  }
  async getRoots() {
    return this._roots;
  }
}, tt = class extends Jr {
  [Symbol.asyncIterator]() {
    if (this._decoded)
      throw new Error("Cannot decode more than once");
    if (!this._iterable)
      throw new Error("Block iterable not found");
    return this._decoded = true, this._iterable[Symbol.asyncIterator]();
  }
  static async fromBytes(e) {
    let { version: r, roots: n, iterator: o } = await cc(e);
    return new tt(r, n, o);
  }
  static async fromIterable(e) {
    let { version: r, roots: n, iterator: o } = await fc(e);
    return new tt(r, n, o);
  }
};
async function cc(t) {
  if (!(t instanceof Uint8Array))
    throw new TypeError("fromBytes() requires a Uint8Array");
  return lc(Ir(t));
}
async function fc(t) {
  if (!t || typeof t[Symbol.asyncIterator] != "function")
    throw new TypeError("fromIterable() requires an async iterable");
  return lc(js(t));
}
async function lc(t) {
  let e = Hs(t), { version: r, roots: n } = await e.header();
  return { version: r, roots: n, iterator: e.blocks() };
}
var gc = J(hc(), 1), Dc = J(mc(), 1), bc = J(wc(), 1);
var Ec = kr("ipfs:components:dag:import");
function xc({ repo: t }) {
  async function* e(r, n = {}) {
    let o = await t.gcLock.readLock();
    try {
      let i2 = { signal: n.signal, timeout: n.timeout }, s = (0, gc.default)(r), { value: u, done: h } = await s.peek();
      if (h)
        return;
      u && s.push(u);
      let w;
      u instanceof Uint8Array ? w = [s] : w = s;
      for await (let c of w) {
        let g = await jh(t, i2, c);
        if (n.pinRoots !== false)
          for (let B of g) {
            let k = "";
            try {
              await t.blocks.has(B) ? (Ec(`Pinning root ${B}`), await t.pins.pinRecursively(B)) : k = "blockstore: block not found";
            } catch (I) {
              k = I.message;
            }
            yield { root: { cid: B, pinErrorMsg: k } };
          }
      }
    } finally {
      o();
    }
  }
  return le(e);
}
async function jh(t, e, r) {
  let n = await tt.fromIterable(r), o = await n.getRoots();
  return await (0, Dc.default)(t.blocks.putMany((0, bc.default)(n, ({ cid: i2, bytes: s }) => (Ec(`Import block ${i2}`), { key: i2, value: s })), { signal: e.signal })), o;
}
a();
Q();
function Cc({ repo: t, codecs: e, hashers: r, preload: n }) {
  async function o(i2, s = {}) {
    let u = s.pin ? await t.gcLock.readLock() : null;
    try {
      let h = await e.getCodec(s.storeCodec || "dag-cbor");
      if (!h)
        throw new Error(`Unknown storeCodec ${s.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);
      if (s.inputCodec) {
        if (!(i2 instanceof Uint8Array))
          throw new Error("Can only inputCodec on raw bytes that can be decoded");
        let I = await e.getCodec(s.inputCodec);
        if (!I)
          throw new Error(`Unknown inputCodec ${s.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);
        i2 = I.decode(i2);
      }
      let w = s.version != null ? s.version : 1, c = await r.getHasher(s.hashAlg || "sha2-256");
      if (!c)
        throw new Error(`Unknown hash algorithm ${s.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
      let g = h.encode(i2), B = await c.digest(g), k = x.create(w, h.code, B);
      return await t.blocks.put(k, g, { signal: s.signal }), s.pin && await t.pins.pinRecursively(k), s.preload !== false && n(k), k;
    } finally {
      u && u();
    }
  }
  return le(o);
}
a();
function Bc({ repo: t, codecs: e, preload: r }) {
  async function n(o, i2 = {}) {
    let { cid: s } = Gr(o);
    return i2.preload !== false && r(s), oc(t, e, o, i2);
  }
  return le(n);
}
var Ac = class {
  constructor({ repo: e, codecs: r, hashers: n, preload: o }) {
    this.export = ma({ repo: e, preload: o, codecs: r }), this.get = uc({ codecs: r, repo: e, preload: o }), this.import = xc({ repo: e }), this.resolve = Bc({ repo: e, codecs: r, preload: o }), this.put = Cc({ repo: e, codecs: r, hashers: n, preload: o });
  }
};
/*!
* The buffer module from node.js, for the browser.
*
* @author   Feross Aboukhadijeh <https://feross.org>
* @license  MIT
*/
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
const code$3 = 0;
const name$3 = "identity";
const encode$b = coerce$6;
const digest = (input) => create$9(code$3, encode$b(input));
const identity$1 = {
  code: code$3,
  name: name$3,
  encode: encode$b,
  digest
};
const identity$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: identity$1
}, Symbol.toStringTag, { value: "Module" }));
const identity = from$b({
  prefix: "\0",
  name: "identity",
  encode: (buf2) => toString$6(buf2),
  decode: (str) => fromString$6(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648$6({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648$6({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX$6({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648$6({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648$6({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX$6({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX$6({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base64$1 = rfc4648$6({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648$6({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url$1 = rfc4648$6({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648$6({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: base64$1,
  base64pad,
  base64url: base64url$1,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
const alphabetBytesToChars = alphabet.reduce((p2, c, i2) => {
  p2[i2] = c;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c, i2) => {
  p2[c.codePointAt(0)] = i2;
  return p2;
}, []);
function encode$a(data) {
  return data.reduce((p2, c) => {
    p2 += alphabetBytesToChars[c];
    return p2;
  }, "");
}
function decode$e(str) {
  const byts = [];
  for (const char of str) {
    const byt = alphabetCharsToBytes[char.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from$b({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: encode$a,
  decode: decode$e
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name$2 = "json";
const code$2 = 512;
const encode$9 = (node) => textEncoder.encode(JSON.stringify(node));
const decode$d = (data) => JSON.parse(textDecoder.decode(data));
const json = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$2,
  code: code$2,
  encode: encode$9,
  decode: decode$d
}, Symbol.toStringTag, { value: "Module" }));
({
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$9,
  ...base36$1,
  ...base58$2,
  ...base64$2,
  ...base256emoji$1
});
const hashes = {
  ...sha2$3,
  ...identity$2
};
const codecs = {
  raw,
  json
};
var encode_1$1 = encode$8;
var MSB$2 = 128, REST$2 = 127, MSBALL$1 = ~REST$2, INT$1 = Math.pow(2, 31);
function encode$8(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT$1) {
    out[offset++] = num & 255 | MSB$2;
    num /= 128;
  }
  while (num & MSBALL$1) {
    out[offset++] = num & 255 | MSB$2;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$8.bytes = offset - oldOffset + 1;
  return out;
}
var decode$c = read$1;
var MSB$1$1 = 128, REST$1$1 = 127;
function read$1(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read$1.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1$1) << shift : (b2 & REST$1$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1$1);
  read$1.bytes = counter - offset;
  return res;
}
var N1$1 = Math.pow(2, 7);
var N2$1 = Math.pow(2, 14);
var N3$1 = Math.pow(2, 21);
var N4$1 = Math.pow(2, 28);
var N5$1 = Math.pow(2, 35);
var N6$1 = Math.pow(2, 42);
var N7$1 = Math.pow(2, 49);
var N8$1 = Math.pow(2, 56);
var N9$1 = Math.pow(2, 63);
var length$1 = function(value) {
  return value < N1$1 ? 1 : value < N2$1 ? 2 : value < N3$1 ? 3 : value < N4$1 ? 4 : value < N5$1 ? 5 : value < N6$1 ? 6 : value < N7$1 ? 7 : value < N8$1 ? 8 : value < N9$1 ? 9 : 10;
};
var varint$1 = {
  encode: encode_1$1,
  decode: decode$c,
  encodingLength: length$1
};
var _brrp_varint$1 = varint$1;
const decode$b = (data, offset = 0) => {
  const code2 = _brrp_varint$1.decode(data, offset);
  return [
    code2,
    _brrp_varint$1.decode.bytes
  ];
};
const encodeTo$1 = (int, target, offset = 0) => {
  _brrp_varint$1.encode(int, target, offset);
  return target;
};
const encodingLength$1 = (int) => {
  return _brrp_varint$1.encodingLength(int);
};
const equals$3 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce$1 = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const create$1 = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength$1(code2);
  const digestOffset = sizeOffset + encodingLength$1(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo$1(code2, bytes2, 0);
  encodeTo$1(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest$1(code2, size, digest2, bytes2);
};
const decode$a = (multihash) => {
  const bytes2 = coerce$1(multihash);
  const [code2, sizeOffset] = decode$b(bytes2);
  const [size, digestOffset] = decode$b(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest$1(code2, size, digest2, bytes2);
};
const equals$2 = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$3(a2.bytes, b2.bytes);
  }
};
class Digest$1 {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
function base$1(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src$1 = base$1;
var _brrp__multiformats_scope_baseX$1 = src$1;
class Encoder$1 {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder$1 {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or$1(this, decoder);
  }
}
class ComposedDecoder$1 {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or$1(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or$1 = (left, right) => new ComposedDecoder$1({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec$1 {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder$1(name2, prefix, baseEncode);
    this.decoder = new Decoder$1(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from$1 = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec$1(name2, prefix, encode2, decode2);
const baseX$1 = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX$1(alphabet2, name2);
  return from$1({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce$1(decode2(text))
  });
};
const decode$9 = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$7 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648$1 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from$1({
    prefix,
    name: name2,
    encode(input) {
      return encode$7(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$9(input, alphabet2, bitsPerChar, name2);
    }
  });
};
const base58btc$1 = baseX$1({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX$1({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base32$1 = rfc4648$1({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648$1({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class CID$1 {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden$1,
      byteLength: hidden$1,
      code: readonly$1,
      version: readonly$1,
      multihash: readonly$1,
      bytes: readonly$1,
      _baseCache: hidden$1,
      asCID: hidden$1
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE$1) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE$1) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID$1.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create$1(code2, digest2);
        return CID$1.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals$2(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0$1(bytes2, _baseCache, base3 || base58btc$1.encoder);
      default:
        return toStringV1$1(bytes2, _baseCache, base3 || base32$1.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate$1(/^0\.0/, IS_CID_DEPRECATION$1);
    return !!(value && (value[cidSymbol$1] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID$1) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID$1(version2, code2, multihash, bytes2 || encodeCID$1(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol$1] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$a(multihash);
      return CID$1.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE$1) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE$1}) block encoding`);
        } else {
          return new CID$1(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID$1(version2, code2, digest2.bytes);
        return new CID$1(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID$1.create(0, DAG_PB_CODE$1, digest2);
  }
  static createV1(code2, digest2) {
    return CID$1.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID$1.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID$1.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce$1(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest$1(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID$1.createV0(digest2) : CID$1.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$b(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE$1;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes$1(source, base3);
    const cid = CID$1.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes$1 = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc$1;
      return [
        base58btc$1.prefix,
        decoder.decode(`${base58btc$1.prefix}${source}`)
      ];
    }
    case base58btc$1.prefix: {
      const decoder = base3 || base58btc$1;
      return [
        base58btc$1.prefix,
        decoder.decode(source)
      ];
    }
    case base32$1.prefix: {
      const decoder = base3 || base32$1;
      return [
        base32$1.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0$1 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc$1.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1$1 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE$1 = 112;
const SHA_256_CODE$1 = 18;
const encodeCID$1 = (version2, code2, multihash) => {
  const codeOffset = encodingLength$1(version2);
  const hashOffset = codeOffset + encodingLength$1(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo$1(version2, bytes2, 0);
  encodeTo$1(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol$1 = Symbol.for("@ipld/js-cid/CID");
const readonly$1 = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden$1 = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version$1 = "0.0.0-dev";
const deprecate$1 = (range, message) => {
  if (range.test(version$1)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION$1 = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
const base64 = rfc4648$1({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
rfc4648$1({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
rfc4648$1({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
rfc4648$1({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
class JSONEncoder extends Array {
  constructor() {
    super();
    this.inRecursive = [];
  }
  prefix(buf2) {
    const recurs = this.inRecursive[this.inRecursive.length - 1];
    if (recurs) {
      if (recurs.type === Type.array) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          buf2.push([44]);
        }
      }
      if (recurs.type === Type.map) {
        recurs.elements++;
        if (recurs.elements !== 1) {
          if (recurs.elements % 2 === 1) {
            buf2.push([44]);
          } else {
            buf2.push([58]);
          }
        }
      }
    }
  }
  [Type.uint.major](buf2, token) {
    this.prefix(buf2);
    const is2 = String(token.value);
    const isa = [];
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
    }
    buf2.push(isa);
  }
  [Type.negint.major](buf2, token) {
    this[Type.uint.major](buf2, token);
  }
  [Type.bytes.major](_buf, _token) {
    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`);
  }
  [Type.string.major](buf2, token) {
    this.prefix(buf2);
    const byts = fromString$7(JSON.stringify(token.value));
    buf2.push(byts.length > 32 ? asU8A(byts) : byts);
  }
  [Type.array.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.array,
      elements: 0
    });
    buf2.push([91]);
  }
  [Type.map.major](buf2, _token) {
    this.prefix(buf2);
    this.inRecursive.push({
      type: Type.map,
      elements: 0
    });
    buf2.push([123]);
  }
  [Type.tag.major](_buf, _token) {
  }
  [Type.float.major](buf2, token) {
    if (token.type.name === "break") {
      const recurs = this.inRecursive.pop();
      if (recurs) {
        if (recurs.type === Type.array) {
          buf2.push([93]);
        } else if (recurs.type === Type.map) {
          buf2.push([125]);
        } else {
          throw new Error("Unexpected recursive type; this should not happen!");
        }
        return;
      }
      throw new Error("Unexpected break; this should not happen!");
    }
    if (token.value === void 0) {
      throw new Error(`${encodeErrPrefix} unsupported type: undefined`);
    }
    this.prefix(buf2);
    if (token.type.name === "true") {
      buf2.push([
        116,
        114,
        117,
        101
      ]);
      return;
    } else if (token.type.name === "false") {
      buf2.push([
        102,
        97,
        108,
        115,
        101
      ]);
      return;
    } else if (token.type.name === "null") {
      buf2.push([
        110,
        117,
        108,
        108
      ]);
      return;
    }
    const is2 = String(token.value);
    const isa = [];
    let dp = false;
    for (let i2 = 0; i2 < is2.length; i2++) {
      isa[i2] = is2.charCodeAt(i2);
      if (!dp && (isa[i2] === 46 || isa[i2] === 101 || isa[i2] === 69)) {
        dp = true;
      }
    }
    if (!dp) {
      isa.push(46);
      isa.push(48);
    }
    buf2.push(isa);
  }
}
function mapSorter(e1, e2) {
  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {
    throw new Error(`${encodeErrPrefix} complex map keys are not supported`);
  }
  const keyToken1 = e1[0];
  const keyToken2 = e2[0];
  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {
    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`);
  }
  if (keyToken1 < keyToken2) {
    return -1;
  }
  if (keyToken1 > keyToken2) {
    return 1;
  }
  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`);
}
const defaultEncodeOptions = {
  addBreakTokens: true,
  mapSorter
};
function encode$6(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, new JSONEncoder(), options);
}
class Tokenizer {
  constructor(data, options = {}) {
    this.pos = 0;
    this.data = data;
    this.options = options;
    this.modeStack = ["value"];
    this.lastToken = "";
  }
  done() {
    return this.pos >= this.data.length;
  }
  ch() {
    return this.data[this.pos];
  }
  currentMode() {
    return this.modeStack[this.modeStack.length - 1];
  }
  skipWhitespace() {
    let c = this.ch();
    while (c === 32 || c === 9 || c === 13 || c === 10) {
      c = this.data[++this.pos];
    }
  }
  expect(str) {
    if (this.data.length - this.pos < str.length) {
      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);
    }
    for (let i2 = 0; i2 < str.length; i2++) {
      if (this.data[this.pos++] !== str[i2]) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...str)}'`);
      }
    }
  }
  parseNumber() {
    const startPos = this.pos;
    let negative = false;
    let float2 = false;
    const swallow = (chars2) => {
      while (!this.done()) {
        const ch = this.ch();
        if (chars2.includes(ch)) {
          this.pos++;
        } else {
          break;
        }
      }
    };
    if (this.ch() === 45) {
      negative = true;
      this.pos++;
    }
    if (this.ch() === 48) {
      this.pos++;
      if (this.ch() === 46) {
        this.pos++;
        float2 = true;
      } else {
        return new Token(Type.uint, 0, this.pos - startPos);
      }
    }
    swallow([
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57
    ]);
    if (negative && this.pos === startPos + 1) {
      throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
    }
    if (!this.done() && this.ch() === 46) {
      if (float2) {
        throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);
      }
      float2 = true;
      this.pos++;
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) {
      float2 = true;
      this.pos++;
      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) {
        this.pos++;
      }
      swallow([
        48,
        49,
        50,
        51,
        52,
        53,
        54,
        55,
        56,
        57
      ]);
    }
    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this.pos));
    const num = parseFloat(numStr);
    if (float2) {
      return new Token(Type.float, num, this.pos - startPos);
    }
    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {
      return new Token(num >= 0 ? Type.uint : Type.negint, num, this.pos - startPos);
    }
    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this.pos - startPos);
  }
  parseString() {
    if (this.ch() !== 34) {
      throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);
    }
    this.pos++;
    for (let i2 = this.pos, l2 = 0; i2 < this.data.length && l2 < 65536; i2++, l2++) {
      const ch = this.data[i2];
      if (ch === 92 || ch < 32 || ch >= 128) {
        break;
      }
      if (ch === 34) {
        const str = String.fromCharCode.apply(null, this.data.subarray(this.pos, i2));
        this.pos = i2 + 1;
        return new Token(Type.string, str, l2);
      }
    }
    const startPos = this.pos;
    const chars2 = [];
    const readu4 = () => {
      if (this.pos + 4 >= this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);
      }
      let u4 = 0;
      for (let i2 = 0; i2 < 4; i2++) {
        let ch = this.ch();
        if (ch >= 48 && ch <= 57) {
          ch -= 48;
        } else if (ch >= 97 && ch <= 102) {
          ch = ch - 97 + 10;
        } else if (ch >= 65 && ch <= 70) {
          ch = ch - 65 + 10;
        } else {
          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);
        }
        u4 = u4 * 16 + ch;
        this.pos++;
      }
      return u4;
    };
    const readUtf8Char = () => {
      const firstByte = this.ch();
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (this.pos + bytesPerSequence > this.data.length) {
        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);
      }
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = this.data[this.pos + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = this.data[this.pos + 1];
          thirdByte = this.data[this.pos + 2];
          fourthByte = this.data[this.pos + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        chars2.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      chars2.push(codePoint);
      this.pos += bytesPerSequence;
    };
    while (!this.done()) {
      const ch = this.ch();
      let ch1;
      switch (ch) {
        case 92:
          this.pos++;
          if (this.done()) {
            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);
          }
          ch1 = this.ch();
          this.pos++;
          switch (ch1) {
            case 34:
            case 39:
            case 92:
            case 47:
              chars2.push(ch1);
              break;
            case 98:
              chars2.push(8);
              break;
            case 116:
              chars2.push(9);
              break;
            case 110:
              chars2.push(10);
              break;
            case 102:
              chars2.push(12);
              break;
            case 114:
              chars2.push(13);
              break;
            case 117:
              chars2.push(readu4());
              break;
            default:
              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`);
          }
          break;
        case 34:
          this.pos++;
          return new Token(Type.string, decodeCodePointsArray(chars2), this.pos - startPos);
        default:
          if (ch < 32) {
            throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);
          } else if (ch < 128) {
            chars2.push(ch);
            this.pos++;
          } else {
            readUtf8Char();
          }
      }
    }
    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`);
  }
  parseValue() {
    switch (this.ch()) {
      case 123:
        this.modeStack.push("obj-start");
        this.pos++;
        return new Token(Type.map, Infinity, 1);
      case 91:
        this.modeStack.push("array-start");
        this.pos++;
        return new Token(Type.array, Infinity, 1);
      case 34: {
        return this.parseString();
      }
      case 110:
        this.expect([
          110,
          117,
          108,
          108
        ]);
        return new Token(Type.null, null, 4);
      case 102:
        this.expect([
          102,
          97,
          108,
          115,
          101
        ]);
        return new Token(Type.false, false, 5);
      case 116:
        this.expect([
          116,
          114,
          117,
          101
        ]);
        return new Token(Type.true, true, 4);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return this.parseNumber();
      default:
        throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`);
    }
  }
  next() {
    this.skipWhitespace();
    switch (this.currentMode()) {
      case "value":
        this.modeStack.pop();
        return this.parseValue();
      case "array-value": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "array-start": {
        this.modeStack.pop();
        if (this.ch() === 93) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        this.modeStack.push("array-value");
        this.skipWhitespace();
        return this.parseValue();
      }
      case "obj-key":
        if (this.ch() === 125) {
          this.modeStack.pop();
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        if (this.ch() !== 44) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.skipWhitespace();
      case "obj-start": {
        this.modeStack.pop();
        if (this.ch() === 125) {
          this.pos++;
          this.skipWhitespace();
          return new Token(Type.break, void 0, 1);
        }
        const token = this.parseString();
        this.skipWhitespace();
        if (this.ch() !== 58) {
          throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);
        }
        this.pos++;
        this.modeStack.push("obj-value");
        return token;
      }
      case "obj-value": {
        this.modeStack.pop();
        this.modeStack.push("obj-key");
        this.skipWhitespace();
        return this.parseValue();
      }
      default:
        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`);
    }
  }
}
function decode$8(data, options) {
  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options);
  return decode$O(data, options);
}
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID$1.asCID(obj);
  if (!cid) {
    return null;
  }
  const cidString = cid.toString();
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.string, cidString, cidString.length),
    new Token(Type.break, void 0, 1)
  ];
}
function bytesEncoder(bytes2) {
  const bytesString = base64.encode(bytes2).slice(1);
  return [
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "/", 1),
    new Token(Type.map, Infinity, 1),
    new Token(Type.string, "bytes", 5),
    new Token(Type.string, bytesString, bytesString.length),
    new Token(Type.break, void 0, 1),
    new Token(Type.break, void 0, 1)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
const encodeOptions = {
  typeEncoders: {
    Object: cidEncoder,
    Uint8Array: bytesEncoder,
    Buffer: bytesEncoder,
    undefined: undefinedEncoder,
    number: numberEncoder
  }
};
class DagJsonTokenizer extends Tokenizer {
  constructor(data, options) {
    super(data, options);
    this.tokenBuffer = [];
  }
  done() {
    return this.tokenBuffer.length === 0 && super.done();
  }
  _next() {
    if (this.tokenBuffer.length > 0) {
      return this.tokenBuffer.pop();
    }
    return super.next();
  }
  next() {
    const token = this._next();
    if (token.type === Type.map) {
      const keyToken = this._next();
      if (keyToken.type === Type.string && keyToken.value === "/") {
        const valueToken = this._next();
        if (valueToken.type === Type.string) {
          const breakToken = this._next();
          if (breakToken.type !== Type.break) {
            throw new Error("Invalid encoded CID form");
          }
          this.tokenBuffer.push(valueToken);
          return new Token(Type.tag, 42, 0);
        }
        if (valueToken.type === Type.map) {
          const innerKeyToken = this._next();
          if (innerKeyToken.type === Type.string && innerKeyToken.value === "bytes") {
            const innerValueToken = this._next();
            if (innerValueToken.type === Type.string) {
              for (let i2 = 0; i2 < 2; i2++) {
                const breakToken = this._next();
                if (breakToken.type !== Type.break) {
                  throw new Error("Invalid encoded Bytes form");
                }
              }
              const bytes2 = base64.decode(`m${innerValueToken.value}`);
              return new Token(Type.bytes, bytes2, innerValueToken.value.length);
            }
            this.tokenBuffer.push(innerValueToken);
          }
          this.tokenBuffer.push(innerKeyToken);
        }
        this.tokenBuffer.push(valueToken);
      }
      this.tokenBuffer.push(keyToken);
    }
    return token;
  }
}
const decodeOptions = {
  allowIndefinite: false,
  allowUndefined: false,
  allowNaN: false,
  allowInfinity: false,
  allowBigInt: true,
  strict: true,
  useMaps: false,
  tags: []
};
decodeOptions.tags[42] = CID$1.parse;
const name$1 = "dag-json";
const code$1 = 297;
const encode$5 = (node) => encode$6(node, encodeOptions);
const decode$7 = (data) => {
  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(data, decodeOptions) });
  return decode$8(data, options);
};
const dagJSON = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: name$1,
  code: code$1,
  encode: encode$5,
  decode: decode$7
}, Symbol.toStringTag, { value: "Module" }));
function base(ALPHABET, name2) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i2 = 0; i2 < ALPHABET.length; i2++) {
    var x2 = ALPHABET.charAt(i2);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i2;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i3 = 0;
      for (var it1 = size - 1; (carry !== 0 || i3 < length2) && it1 !== -1; it1--, i3++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      pbegin++;
    }
    var it2 = size - length2;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i3 = 0;
      for (var it3 = size - 1; (carry !== 0 || i3 < length2) && it3 !== -1; it3--, i3++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i3;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length2;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer2 = decodeUnsafe(string2);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name2} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const equals$1 = (aa, bb) => {
  if (aa === bb)
    return true;
  if (aa.byteLength !== bb.byteLength) {
    return false;
  }
  for (let ii = 0; ii < aa.byteLength; ii++) {
    if (aa[ii] !== bb[ii]) {
      return false;
    }
  }
  return true;
};
const coerce = (o) => {
  if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
    return o;
  if (o instanceof ArrayBuffer)
    return new Uint8Array(o);
  if (ArrayBuffer.isView(o)) {
    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
class Encoder {
  constructor(name2, prefix, baseEncode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
  }
  encode(bytes2) {
    if (bytes2 instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes2)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name2, prefix, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    if (prefix.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text) {
    if (typeof text === "string") {
      if (text.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders2) {
    this.decoders = decoders2;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input) {
    const prefix = input[0];
    const decoder = this.decoders[prefix];
    if (decoder) {
      return decoder.decode(input);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left, right) => new ComposedDecoder({
  ...left.decoders || { [left.prefix]: left },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name2, prefix, baseEncode, baseDecode) {
    this.name = name2;
    this.prefix = prefix;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name2, prefix, baseEncode);
    this.decoder = new Decoder(name2, prefix, baseDecode);
  }
  encode(input) {
    return this.encoder.encode(input);
  }
  decode(input) {
    return this.decoder.decode(input);
  }
}
const from = ({ name: name2, prefix, encode: encode2, decode: decode2 }) => new Codec(name2, prefix, encode2, decode2);
const baseX = ({ prefix, name: name2, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name2);
  return from({
    prefix,
    name: name2,
    encode: encode2,
    decode: (text) => coerce(decode2(text))
  });
};
const decode$6 = (string2, alphabet2, bitsPerChar, name2) => {
  const codes2 = {};
  for (let i2 = 0; i2 < alphabet2.length; ++i2) {
    codes2[alphabet2[i2]] = i2;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer2 = 0;
  let written = 0;
  for (let i2 = 0; i2 < end2; ++i2) {
    const value = codes2[string2[i2]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name2} character`);
    }
    buffer2 = buffer2 << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer2 >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$4 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer2 = 0;
  for (let i2 = 0; i2 < data.length; ++i2) {
    buffer2 = buffer2 << 8 | data[i2];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer2 >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer2 << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name: name2, prefix, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix,
    name: name2,
    encode(input) {
      return encode$4(input, alphabet2, bitsPerChar);
    },
    decode(input) {
      return decode$6(input, alphabet2, bitsPerChar, name2);
    }
  });
};
rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
function toBase64url(b2) {
  return base64url.encode(b2).slice(1);
}
function fromBase64url(s) {
  return base64url.decode(`u${s}`);
}
var encode_1 = encode$3;
var MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode$3(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode$3.bytes = offset - oldOffset + 1;
  return out;
}
var decode$5 = read;
var MSB$1 = 128, REST$1 = 127;
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b2, l2 = buf2.length;
  do {
    if (counter >= l2) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b2 = buf2[counter++];
    res += shift < 28 ? (b2 & REST$1) << shift : (b2 & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b2 >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
  encode: encode_1,
  decode: decode$5,
  encodingLength: length
};
var _brrp_varint = varint;
const decode$4 = (data, offset = 0) => {
  const code2 = _brrp_varint.decode(data, offset);
  return [
    code2,
    _brrp_varint.decode.bytes
  ];
};
const encodeTo = (int, target, offset = 0) => {
  _brrp_varint.encode(int, target, offset);
  return target;
};
const encodingLength = (int) => {
  return _brrp_varint.encodingLength(int);
};
const create = (code2, digest2) => {
  const size = digest2.byteLength;
  const sizeOffset = encodingLength(code2);
  const digestOffset = sizeOffset + encodingLength(size);
  const bytes2 = new Uint8Array(digestOffset + size);
  encodeTo(code2, bytes2, 0);
  encodeTo(size, bytes2, sizeOffset);
  bytes2.set(digest2, digestOffset);
  return new Digest(code2, size, digest2, bytes2);
};
const decode$3 = (multihash) => {
  const bytes2 = coerce(multihash);
  const [code2, sizeOffset] = decode$4(bytes2);
  const [size, digestOffset] = decode$4(bytes2.subarray(sizeOffset));
  const digest2 = bytes2.subarray(sizeOffset + digestOffset);
  if (digest2.byteLength !== size) {
    throw new Error("Incorrect length");
  }
  return new Digest(code2, size, digest2, bytes2);
};
const equals = (a2, b2) => {
  if (a2 === b2) {
    return true;
  } else {
    return a2.code === b2.code && a2.size === b2.size && equals$1(a2.bytes, b2.bytes);
  }
};
class Digest {
  constructor(code2, size, digest2, bytes2) {
    this.code = code2;
    this.size = size;
    this.digest = digest2;
    this.bytes = bytes2;
  }
}
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class CID {
  constructor(version2, code2, multihash, bytes2) {
    this.code = code2;
    this.version = version2;
    this.multihash = multihash;
    this.bytes = bytes2;
    this.byteOffset = bytes2.byteOffset;
    this.byteLength = bytes2.byteLength;
    this.asCID = this;
    this._baseCache = /* @__PURE__ */ new Map();
    Object.defineProperties(this, {
      byteOffset: hidden,
      byteLength: hidden,
      code: readonly,
      version: readonly,
      multihash: readonly,
      bytes: readonly,
      _baseCache: hidden,
      asCID: hidden
    });
  }
  toV0() {
    switch (this.version) {
      case 0: {
        return this;
      }
      default: {
        const { code: code2, multihash } = this;
        if (code2 !== DAG_PB_CODE) {
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        }
        if (multihash.code !== SHA_256_CODE) {
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        }
        return CID.createV0(multihash);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: code2, digest: digest2 } = this.multihash;
        const multihash = create(code2, digest2);
        return CID.createV1(this.code, multihash);
      }
      case 1: {
        return this;
      }
      default: {
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
      }
    }
  }
  equals(other) {
    return other && this.code === other.code && this.version === other.version && equals(this.multihash, other.multihash);
  }
  toString(base3) {
    const { bytes: bytes2, version: version2, _baseCache } = this;
    switch (version2) {
      case 0:
        return toStringV0(bytes2, _baseCache, base3 || base58btc.encoder);
      default:
        return toStringV1(bytes2, _baseCache, base3 || base32.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(value) {
    deprecate(/^0\.0/, IS_CID_DEPRECATION);
    return !!(value && (value[cidSymbol] || value.asCID === value));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(value) {
    if (value instanceof CID) {
      return value;
    } else if (value != null && value.asCID === value) {
      const { version: version2, code: code2, multihash, bytes: bytes2 } = value;
      return new CID(version2, code2, multihash, bytes2 || encodeCID(version2, code2, multihash.bytes));
    } else if (value != null && value[cidSymbol] === true) {
      const { version: version2, multihash, code: code2 } = value;
      const digest2 = decode$3(multihash);
      return CID.create(version2, code2, digest2);
    } else {
      return null;
    }
  }
  static create(version2, code2, digest2) {
    if (typeof code2 !== "number") {
      throw new Error("String codecs are no longer supported");
    }
    switch (version2) {
      case 0: {
        if (code2 !== DAG_PB_CODE) {
          throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
        } else {
          return new CID(version2, code2, digest2, digest2.bytes);
        }
      }
      case 1: {
        const bytes2 = encodeCID(version2, code2, digest2.bytes);
        return new CID(version2, code2, digest2, bytes2);
      }
      default: {
        throw new Error("Invalid version");
      }
    }
  }
  static createV0(digest2) {
    return CID.create(0, DAG_PB_CODE, digest2);
  }
  static createV1(code2, digest2) {
    return CID.create(1, code2, digest2);
  }
  static decode(bytes2) {
    const [cid, remainder] = CID.decodeFirst(bytes2);
    if (remainder.length) {
      throw new Error("Incorrect length");
    }
    return cid;
  }
  static decodeFirst(bytes2) {
    const specs = CID.inspectBytes(bytes2);
    const prefixSize = specs.size - specs.multihashSize;
    const multihashBytes = coerce(bytes2.subarray(prefixSize, prefixSize + specs.multihashSize));
    if (multihashBytes.byteLength !== specs.multihashSize) {
      throw new Error("Incorrect length");
    }
    const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
    const digest2 = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
    const cid = specs.version === 0 ? CID.createV0(digest2) : CID.createV1(specs.codec, digest2);
    return [
      cid,
      bytes2.subarray(specs.size)
    ];
  }
  static inspectBytes(initialBytes) {
    let offset = 0;
    const next = () => {
      const [i2, length2] = decode$4(initialBytes.subarray(offset));
      offset += length2;
      return i2;
    };
    let version2 = next();
    let codec = DAG_PB_CODE;
    if (version2 === 18) {
      version2 = 0;
      offset = 0;
    } else if (version2 === 1) {
      codec = next();
    }
    if (version2 !== 0 && version2 !== 1) {
      throw new RangeError(`Invalid CID version ${version2}`);
    }
    const prefixSize = offset;
    const multihashCode = next();
    const digestSize = next();
    const size = offset + digestSize;
    const multihashSize = size - prefixSize;
    return {
      version: version2,
      codec,
      multihashCode,
      digestSize,
      multihashSize,
      size
    };
  }
  static parse(source, base3) {
    const [prefix, bytes2] = parseCIDtoBytes(source, base3);
    const cid = CID.decode(bytes2);
    cid._baseCache.set(prefix, source);
    return cid;
  }
}
const parseCIDtoBytes = (source, base3) => {
  switch (source[0]) {
    case "Q": {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(`${base58btc.prefix}${source}`)
      ];
    }
    case base58btc.prefix: {
      const decoder = base3 || base58btc;
      return [
        base58btc.prefix,
        decoder.decode(source)
      ];
    }
    case base32.prefix: {
      const decoder = base3 || base32;
      return [
        base32.prefix,
        decoder.decode(source)
      ];
    }
    default: {
      if (base3 == null) {
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      }
      return [
        source[0],
        base3.decode(source)
      ];
    }
  }
};
const toStringV0 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  if (prefix !== base58btc.prefix) {
    throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
  }
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2).slice(1);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const toStringV1 = (bytes2, cache, base3) => {
  const { prefix } = base3;
  const cid = cache.get(prefix);
  if (cid == null) {
    const cid2 = base3.encode(bytes2);
    cache.set(prefix, cid2);
    return cid2;
  } else {
    return cid;
  }
};
const DAG_PB_CODE = 112;
const SHA_256_CODE = 18;
const encodeCID = (version2, code2, multihash) => {
  const codeOffset = encodingLength(version2);
  const hashOffset = codeOffset + encodingLength(code2);
  const bytes2 = new Uint8Array(hashOffset + multihash.byteLength);
  encodeTo(version2, bytes2, 0);
  encodeTo(code2, bytes2, codeOffset);
  bytes2.set(multihash, hashOffset);
  return bytes2;
};
const cidSymbol = Symbol.for("@ipld/js-cid/CID");
const readonly = {
  writable: false,
  configurable: false,
  enumerable: true
};
const hidden = {
  writable: false,
  enumerable: false,
  configurable: false
};
const version = "0.0.0-dev";
const deprecate = (range, message) => {
  if (range.test(version)) {
    console.warn(message);
  } else {
    throw new Error(message);
  }
};
const IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
function fromSplit$1(split) {
  const [protectedHeader, payload, signature] = split;
  return {
    payload,
    signatures: [{ protected: protectedHeader, signature }],
    link: CID.decode(fromBase64url(payload))
  };
}
function encodeSignature(signature) {
  const encoded = {
    signature: fromBase64url(signature.signature)
  };
  if (signature.header)
    encoded.header = signature.header;
  if (signature.protected)
    encoded.protected = fromBase64url(signature.protected);
  return encoded;
}
function encode$2(jws) {
  const payload = fromBase64url(jws.payload);
  try {
    CID.decode(payload);
  } catch (e) {
    throw new Error("Not a valid DagJWS");
  }
  return {
    payload,
    signatures: jws.signatures.map(encodeSignature)
  };
}
function decodeSignature(encoded) {
  const sign = {
    signature: toBase64url(encoded.signature)
  };
  if (encoded.header)
    sign.header = encoded.header;
  if (encoded.protected)
    sign.protected = toBase64url(encoded.protected);
  return sign;
}
function decode$2(encoded) {
  const decoded = {
    payload: toBase64url(encoded.payload),
    signatures: encoded.signatures.map(decodeSignature)
  };
  decoded.link = CID.decode(new Uint8Array(encoded.payload));
  return decoded;
}
function fromSplit(split) {
  const [protectedHeader, encrypted_key, iv, ciphertext, tag] = split;
  const jwe = {
    ciphertext,
    iv,
    protected: protectedHeader,
    tag
  };
  if (encrypted_key)
    jwe.recipients = [{ encrypted_key }];
  return jwe;
}
function encodeRecipient(recipient) {
  const encRec = {};
  if (recipient.encrypted_key)
    encRec.encrypted_key = fromBase64url(recipient.encrypted_key);
  if (recipient.header)
    encRec.header = recipient.header;
  return encRec;
}
function encode$1(jwe) {
  const encJwe = {
    ciphertext: fromBase64url(jwe.ciphertext),
    protected: fromBase64url(jwe.protected),
    iv: fromBase64url(jwe.iv),
    tag: fromBase64url(jwe.tag)
  };
  if (jwe.aad)
    encJwe.aad = fromBase64url(jwe.aad);
  if (jwe.recipients)
    encJwe.recipients = jwe.recipients.map(encodeRecipient);
  if (jwe.unprotected)
    encJwe.unprotected = jwe.unprotected;
  return encJwe;
}
function decodeRecipient(encoded) {
  const recipient = {};
  if (encoded.encrypted_key)
    recipient.encrypted_key = toBase64url(encoded.encrypted_key);
  if (encoded.header)
    recipient.header = encoded.header;
  return recipient;
}
function decode$1(encoded) {
  const jwe = {
    ciphertext: toBase64url(encoded.ciphertext),
    protected: toBase64url(encoded.protected),
    iv: toBase64url(encoded.iv),
    tag: toBase64url(encoded.tag)
  };
  if (encoded.aad)
    jwe.aad = toBase64url(encoded.aad);
  if (encoded.recipients)
    jwe.recipients = encoded.recipients.map(decodeRecipient);
  if (encoded.unprotected)
    jwe.unprotected = encoded.unprotected;
  return jwe;
}
const name = "dag-jose";
const code = 133;
function isDagJWS(jose) {
  return "payload" in jose && typeof jose.payload === "string" && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWS(jose) {
  return "payload" in jose && jose.payload instanceof Uint8Array && "signatures" in jose && Array.isArray(jose.signatures);
}
function isEncodedJWE(jose) {
  return "ciphertext" in jose && jose.ciphertext instanceof Uint8Array && "iv" in jose && jose.iv instanceof Uint8Array && "protected" in jose && jose.protected instanceof Uint8Array && "tag" in jose && jose.tag instanceof Uint8Array;
}
function isDagJWE(jose) {
  return "ciphertext" in jose && typeof jose.ciphertext === "string" && "iv" in jose && typeof jose.iv === "string" && "protected" in jose && typeof jose.protected === "string" && "tag" in jose && typeof jose.tag === "string";
}
function toGeneral(jose) {
  if (typeof jose === "string") {
    const split = jose.split(".");
    if (split.length === 3) {
      return fromSplit$1(split);
    } else if (split.length === 5) {
      return fromSplit(split);
    }
    throw new Error("Not a valid JOSE string");
  }
  if (isDagJWS(jose) || isDagJWE(jose)) {
    return jose;
  }
  throw new Error("Not a valid unencoded JOSE object");
}
function encode(obj) {
  if (typeof obj === "string") {
    obj = toGeneral(obj);
  }
  let encodedJose;
  if (isDagJWS(obj)) {
    encodedJose = encode$2(obj);
  } else if (isDagJWE(obj)) {
    encodedJose = encode$1(obj);
  } else {
    throw new Error("Not a valid JOSE object");
  }
  return new Uint8Array(encode$y(encodedJose));
}
function decode(data) {
  let encoded;
  try {
    encoded = decode$J(data);
  } catch (e) {
    throw new Error("Not a valid DAG-JOSE object");
  }
  if (isEncodedJWS(encoded)) {
    return decode$2(encoded);
  } else if (isEncodedJWE(encoded)) {
    return decode$1(encoded);
  } else {
    throw new Error("Not a valid DAG-JOSE object");
  }
}
const dagJOSE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name,
  code,
  toGeneral,
  encode,
  decode
}, Symbol.toStringTag, { value: "Module" }));
const LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
class Multicodecs {
  constructor(options) {
    this._codecsByName = {};
    this._codecsByCode = {};
    this._loadCodec = options.loadCodec || LOAD_CODEC;
    for (const codec of options.codecs) {
      this.addCodec(codec);
    }
  }
  addCodec(codec) {
    if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
      throw new Error(`Resolver already exists for codec "${codec.name}"`);
    }
    this._codecsByName[codec.name] = codec;
    this._codecsByCode[codec.code] = codec;
  }
  removeCodec(codec) {
    delete this._codecsByName[codec.name];
    delete this._codecsByCode[codec.code];
  }
  async getCodec(code2) {
    const table2 = typeof code2 === "string" ? this._codecsByName : this._codecsByCode;
    if (table2[code2]) {
      return table2[code2];
    }
    const codec = await this._loadCodec(code2);
    if (table2[code2] == null) {
      this.addCodec(codec);
    }
    return codec;
  }
  listCodecs() {
    return Object.values(this._codecsByName);
  }
}
const LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
class Multihashes {
  constructor(options) {
    this._hashersByName = {};
    this._hashersByCode = {};
    this._loadHasher = options.loadHasher || LOAD_HASHER;
    for (const hasher of options.hashers) {
      this.addHasher(hasher);
    }
  }
  addHasher(hasher) {
    if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
      throw new Error(`Resolver already exists for codec "${hasher.name}"`);
    }
    this._hashersByName[hasher.name] = hasher;
    this._hashersByCode[hasher.code] = hasher;
  }
  removeHasher(hasher) {
    delete this._hashersByName[hasher.name];
    delete this._hashersByCode[hasher.code];
  }
  async getHasher(code2) {
    const table2 = typeof code2 === "string" ? this._hashersByName : this._hashersByCode;
    if (table2[code2]) {
      return table2[code2];
    }
    const hasher = await this._loadHasher(code2);
    if (table2[code2] == null) {
      this.addHasher(hasher);
    }
    return hasher;
  }
  listHashers() {
    return Object.values(this._hashersByName);
  }
}
async function* makeIterable(array) {
  let nextIndex = 0;
  while (nextIndex < array.length) {
    yield array[nextIndex++];
  }
}
function notFoundError(err) {
  err = err || new Error("Not Found");
  return errCode$1(err, "ERR_NOT_FOUND");
}
class MemoryBlockstore extends BaseBlockstore {
  constructor() {
    super();
    this.data = {};
  }
  open() {
    return Promise.resolve();
  }
  close() {
    return Promise.resolve();
  }
  async put(key, val) {
    this.data[base32$d.encode(key.multihash.bytes)] = val;
  }
  async get(key) {
    const exists = await this.has(key);
    if (!exists)
      throw notFoundError();
    return this.data[base32$d.encode(key.multihash.bytes)];
  }
  async has(key) {
    return this.data[base32$d.encode(key.multihash.bytes)] !== void 0;
  }
  async delete(key) {
    delete this.data[base32$d.encode(key.multihash.bytes)];
  }
  async *_all() {
    yield* Object.entries(this.data).map(([key, value]) => ({ key: CID$9.createV1(code$a, decode$R(base32$d.decode(key))), value }));
  }
  async *_allKeys() {
    yield* Object.entries(this.data).map(([key]) => CID$9.createV1(code$a, decode$R(base32$d.decode(key))));
  }
}
class DagRepo extends Ac {
  constructor({ repo, codecs: codecs2, options }) {
    const multihashHashers = Object.values(hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
    const hashers = new Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    super({
      repo,
      codecs: codecs2,
      hashers,
      preload: (cid) => {
        return;
      }
    });
    Object.assign(this, mitt());
    this.repo = repo;
    this.rootCID;
    this.tx = {
      pending: Transaction.create(),
      checkSize: async (data) => {
        const t = Transaction.create();
        await t.add(data);
        return t.size;
      },
      getExistingTx: async () => {
        let existingTx = {};
        try {
          let last = this.tx.pending.last;
          if (!last)
            return;
          let lastBlock = await this.tx.pending.get(last);
          existingTx = lastBlock.value;
        } catch (error) {
          return existingTx;
        }
        return existingTx;
      },
      addData: async (data) => {
        return await this.tx.pending.add(data);
      },
      addTag: async (tag, tagNode) => {
        return await this.tx.add(tag, tagNode);
      },
      add: async (tag, tagNode) => {
        if (!tagNode)
          return;
        tagNode = Object.fromEntries(Object.entries(tagNode).map(([k, v]) => v === void 0 ? [k, null] : [k, v]));
        let prev = false;
        let existingTx = await this.tx.getExistingTx() || null;
        if (existingTx && existingTx[tag]) {
          prev = !!existingTx[tag] ? existingTx[tag] : false;
        } else if (this.rootCID) {
          try {
            let rootObj = (await this.get(this.rootCID)).value;
            prev = !!rootObj[tag] ? rootObj[tag] : false;
          } catch (msg) {
          }
        }
        let tagNodeCid = await this.tx.pending.add(tagNode);
        let filtered = existingTx && Object.keys(existingTx).length !== 0 ? Object.fromEntries(Object.entries(existingTx).filter(([k, v]) => v.hasOwnProperty("obj") && v.hasOwnProperty("prev"))) : null;
        let newBlock = filtered && Object.keys(filtered).length !== 0 ? Object.assign({}, filtered, { [tag]: { obj: tagNodeCid, prev } }) : { [tag]: { obj: tagNodeCid, prev } };
        let txCid = await this.tx.pending.add(newBlock);
        this.emit("added", txCid);
        return txCid;
      },
      commit: async () => {
        let existingTx = await this.tx.getExistingTx();
        let currentDag = {};
        try {
          if (this.rootCID)
            currentDag = (await this.get(this.rootCID)).value;
          let merged = Object.assign({}, currentDag, Object.fromEntries(Object.entries(existingTx).filter(([k, v]) => v.hasOwnProperty("obj") && v.hasOwnProperty("prev"))));
          this.rootCID = await this.tx.pending.add(merged);
        } catch (error) {
          if (this.rootCID)
            console.log("thats odd", { error });
        }
        const buffer2 = await this.tx.pending.commit();
        await this.importBuffer(buffer2);
        this.tx.pending = Transaction.create();
        if (this.rootCID)
          this.emit("rootCID", this.rootCID.toString());
        return buffer2;
      }
    };
  }
  async latest(tag, path) {
    const append = path ? `/${path}` : "";
    const res = await this.get(this.rootCID, { path: `/${tag}/obj${append}` });
    return res.value;
  }
  async importBuffers(buffers) {
    let root;
    for (const buffer2 of buffers) {
      root = await this.importBuffer(buffer2);
    }
    return root;
  }
  async importBuffer(buffer2) {
    return importBuffer(this, buffer2);
  }
}
async function importBuffer(dag2, buffer2) {
  const it = await makeIterable([buffer2]);
  const [{ root }] = await itAll(dag2.import(it));
  return root.cid;
}
async function createDagRepo(options = {}) {
  const id = {
    name: identity$1.name,
    code: identity$1.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const blockCodecs = Object.values(codecs);
  [dagCBOR, dagJSON, dagJOSE, id].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const repoPath = options.path || "ipfs";
  let repo;
  if (options == null ? void 0 : options.persist) {
    repo = createRepo(console.log, multicodecs, {
      path: repoPath,
      autoMigrate: true
    });
  } else {
    repo = createRepo$1(repoPath, (codeOrName) => multicodecs.getCodec(codeOrName), {
      blocks: new MemoryBlockstore(),
      datastore: new MemoryDatastore(),
      root: new MemoryDatastore(),
      keys: new MemoryDatastore(),
      pins: new MemoryDatastore()
    }, options);
  }
  const initConfig = {};
  try {
    await repo.init(initConfig);
    await repo.open();
  } catch (err) {
    throw err;
  }
  const repoConfig = await repo.config.getAll();
  return new DagRepo({
    repo,
    codecs: multicodecs,
    options: { ...options, repoConfig }
  });
}
const contactCard = 'function V() {\r\n}\r\nconst ht = (e) => e;\r\nfunction at(e) {\r\n  return e();\r\n}\r\nfunction G1() {\r\n  return /* @__PURE__ */ Object.create(null);\r\n}\r\nfunction F(e) {\r\n  e.forEach(at);\r\n}\r\nfunction j1(e) {\r\n  return typeof e == "function";\r\n}\r\nfunction s1(e, t) {\r\n  return e != e ? t == t : e !== t || e && typeof e == "object" || typeof e == "function";\r\n}\r\nlet y1;\r\nfunction I1(e, t) {\r\n  return y1 || (y1 = document.createElement("a")), y1.href = t, e === y1.href;\r\n}\r\nfunction G(e, t, n, o) {\r\n  if (e) {\r\n    const l = dt(e, t, n, o);\r\n    return e[0](l);\r\n  }\r\n}\r\nfunction dt(e, t, n, o) {\r\n  return e[1] && o ? function(l, s) {\r\n    for (const c in s)\r\n      l[c] = s[c];\r\n    return l;\r\n  }(n.ctx.slice(), e[1](o(t))) : n.ctx;\r\n}\r\nfunction I(e, t, n, o) {\r\n  if (e[2] && o) {\r\n    const l = e[2](o(n));\r\n    if (t.dirty === void 0)\r\n      return l;\r\n    if (typeof l == "object") {\r\n      const s = [], c = Math.max(t.dirty.length, l.length);\r\n      for (let r = 0; r < c; r += 1)\r\n        s[r] = t.dirty[r] | l[r];\r\n      return s;\r\n    }\r\n    return t.dirty | l;\r\n  }\r\n  return t.dirty;\r\n}\r\nfunction Q(e, t, n, o, l, s) {\r\n  if (l) {\r\n    const c = dt(t, n, o, s);\r\n    e.p(c, l);\r\n  }\r\n}\r\nfunction J(e) {\r\n  if (e.ctx.length > 32) {\r\n    const t = [], n = e.ctx.length / 32;\r\n    for (let o = 0; o < n; o++)\r\n      t[o] = -1;\r\n    return t;\r\n  }\r\n  return -1;\r\n}\r\nconst ut = typeof window < "u";\r\nlet vt = ut ? () => window.performance.now() : () => Date.now(), V1 = ut ? (e) => requestAnimationFrame(e) : V;\r\nconst u1 = /* @__PURE__ */ new Set();\r\nfunction pt(e) {\r\n  u1.forEach((t) => {\r\n    t.c(e) || (u1.delete(t), t.f());\r\n  }), u1.size !== 0 && V1(pt);\r\n}\r\nfunction k(e, t) {\r\n  e.appendChild(t);\r\n}\r\nfunction L1(e, t, n) {\r\n  const o = q1(e);\r\n  if (!o.getElementById(t)) {\r\n    const l = g("style");\r\n    l.id = t, l.textContent = n, mt(o, l);\r\n  }\r\n}\r\nfunction q1(e) {\r\n  if (!e)\r\n    return document;\r\n  const t = e.getRootNode ? e.getRootNode() : e.ownerDocument;\r\n  return t && t.host ? t : e.ownerDocument;\r\n}\r\nfunction xt(e) {\r\n  const t = g("style");\r\n  return mt(q1(e), t), t.sheet;\r\n}\r\nfunction mt(e, t) {\r\n  return k(e.head || e, t), t.sheet;\r\n}\r\nfunction j(e, t, n) {\r\n  e.insertBefore(t, n || null);\r\n}\r\nfunction w(e) {\r\n  e.parentNode.removeChild(e);\r\n}\r\nfunction g(e) {\r\n  return document.createElement(e);\r\n}\r\nfunction C1(e) {\r\n  return document.createElementNS("http://www.w3.org/2000/svg", e);\r\n}\r\nfunction S1(e) {\r\n  return document.createTextNode(e);\r\n}\r\nfunction B() {\r\n  return S1(" ");\r\n}\r\nfunction R(e, t, n, o) {\r\n  return e.addEventListener(t, n, o), () => e.removeEventListener(t, n, o);\r\n}\r\nfunction h(e, t, n) {\r\n  n == null ? e.removeAttribute(t) : e.getAttribute(t) !== n && e.setAttribute(t, n);\r\n}\r\nfunction Q1(e, t, n) {\r\n  e.setAttributeNS("http://www.w3.org/1999/xlink", t, n);\r\n}\r\nfunction J1(e, t) {\r\n  e.value = t == null ? "" : t;\r\n}\r\nfunction p1(e, t, n, o) {\r\n  n === null ? e.style.removeProperty(t) : e.style.setProperty(t, n, o ? "important" : "");\r\n}\r\nfunction ft(e, t, { bubbles: n = !1, cancelable: o = !1 } = {}) {\r\n  const l = document.createEvent("CustomEvent");\r\n  return l.initCustomEvent(e, n, o, t), l;\r\n}\r\nconst M1 = /* @__PURE__ */ new Map();\r\nlet h1, b1 = 0;\r\nfunction W1(e, t, n, o, l, s, c, r = 0) {\r\n  const d = 16.666 / o;\r\n  let u = `{\r\n`;\r\n  for (let b = 0; b <= 1; b += d) {\r\n    const z = t + (n - t) * s(b);\r\n    u += 100 * b + `%{${c(z, 1 - z)}}\r\n`;\r\n  }\r\n  const i = u + `100% {${c(n, 1 - n)}}\r\n}`, a = `__svelte_${function(b) {\r\n    let z = 5381, L = b.length;\r\n    for (; L--; )\r\n      z = (z << 5) - z ^ b.charCodeAt(L);\r\n    return z >>> 0;\r\n  }(i)}_${r}`, p = q1(e), { stylesheet: f, rules: C } = M1.get(p) || function(b, z) {\r\n    const L = { stylesheet: xt(z), rules: {} };\r\n    return M1.set(b, L), L;\r\n  }(p, e);\r\n  C[a] || (C[a] = !0, f.insertRule(`@keyframes ${a} ${i}`, f.cssRules.length));\r\n  const x = e.style.animation || "";\r\n  return e.style.animation = `${x ? `${x}, ` : ""}${a} ${o}ms linear ${l}ms 1 both`, b1 += 1, a;\r\n}\r\nfunction m1(e) {\r\n  h1 = e;\r\n}\r\nfunction Z1() {\r\n  const e = function() {\r\n    if (!h1)\r\n      throw new Error("Function called outside component initialization");\r\n    return h1;\r\n  }();\r\n  return (t, n, { cancelable: o = !1 } = {}) => {\r\n    const l = e.$$.callbacks[t];\r\n    if (l) {\r\n      const s = ft(t, n, { cancelable: o });\r\n      return l.slice().forEach((c) => {\r\n        c.call(e, s);\r\n      }), !s.defaultPrevented;\r\n    }\r\n    return !0;\r\n  };\r\n}\r\nfunction $t(e, t) {\r\n  const n = e.$$.callbacks[t.type];\r\n  n && n.slice().forEach((o) => o.call(this, t));\r\n}\r\nconst d1 = [], D = [], z1 = [], A1 = [], gt = Promise.resolve();\r\nlet P1 = !1;\r\nfunction l1(e) {\r\n  z1.push(e);\r\n}\r\nfunction e1(e) {\r\n  A1.push(e);\r\n}\r\nconst E1 = /* @__PURE__ */ new Set();\r\nlet a1, w1 = 0;\r\nfunction X1() {\r\n  const e = h1;\r\n  do {\r\n    for (; w1 < d1.length; ) {\r\n      const t = d1[w1];\r\n      w1++, m1(t), yt(t.$$);\r\n    }\r\n    for (m1(null), d1.length = 0, w1 = 0; D.length; )\r\n      D.pop()();\r\n    for (let t = 0; t < z1.length; t += 1) {\r\n      const n = z1[t];\r\n      E1.has(n) || (E1.add(n), n());\r\n    }\r\n    z1.length = 0;\r\n  } while (d1.length);\r\n  for (; A1.length; )\r\n    A1.pop()();\r\n  P1 = !1, E1.clear(), m1(e);\r\n}\r\nfunction yt(e) {\r\n  if (e.fragment !== null) {\r\n    e.update(), F(e.before_update);\r\n    const t = e.dirty;\r\n    e.dirty = [-1], e.fragment && e.fragment.p(e.ctx, t), e.after_update.forEach(l1);\r\n  }\r\n}\r\nfunction N1(e, t, n) {\r\n  e.dispatchEvent(ft(`${t ? "intro" : "outro"}${n}`));\r\n}\r\nconst k1 = /* @__PURE__ */ new Set();\r\nlet U;\r\nfunction R1() {\r\n  U = { r: 0, c: [], p: U };\r\n}\r\nfunction O1() {\r\n  U.r || F(U.c), U = U.p;\r\n}\r\nfunction $(e, t) {\r\n  e && e.i && (k1.delete(e), e.i(t));\r\n}\r\nfunction y(e, t, n, o) {\r\n  if (e && e.o) {\r\n    if (k1.has(e))\r\n      return;\r\n    k1.add(e), U.c.push(() => {\r\n      k1.delete(e), o && (n && e.d(1), o());\r\n    }), e.o(t);\r\n  } else\r\n    o && o();\r\n}\r\nconst wt = { duration: 0 };\r\nfunction Y1(e, t, n, o) {\r\n  let l = t(e, n), s = o ? 0 : 1, c = null, r = null, d = null;\r\n  function u() {\r\n    d && function(p, f) {\r\n      const C = (p.style.animation || "").split(", "), x = C.filter(f ? (z) => z.indexOf(f) < 0 : (z) => z.indexOf("__svelte") === -1), b = C.length - x.length;\r\n      b && (p.style.animation = x.join(", "), b1 -= b, b1 || V1(() => {\r\n        b1 || (M1.forEach((z) => {\r\n          const { ownerNode: L } = z.stylesheet;\r\n          L && w(L);\r\n        }), M1.clear());\r\n      }));\r\n    }(e, d);\r\n  }\r\n  function i(p, f) {\r\n    const C = p.b - s;\r\n    return f *= Math.abs(C), { a: s, b: p.b, d: C, duration: f, start: p.start, end: p.start + f, group: p.group };\r\n  }\r\n  function a(p) {\r\n    const { delay: f = 0, duration: C = 300, easing: x = ht, tick: b = V, css: z } = l || wt, L = { start: vt() + f, b: p };\r\n    p || (L.group = U, U.r += 1), c || r ? r = L : (z && (u(), d = W1(e, s, p, C, f, x, z)), p && b(0, 1), c = i(L, C), l1(() => N1(e, p, "start")), function(K) {\r\n      let W;\r\n      u1.size === 0 && V1(pt), new Promise((A) => {\r\n        u1.add(W = { c: K, f: A });\r\n      });\r\n    }((K) => {\r\n      if (r && K > r.start && (c = i(r, C), r = null, N1(e, c.b, "start"), z && (u(), d = W1(e, s, c.b, c.duration, 0, x, l.css))), c) {\r\n        if (K >= c.end)\r\n          b(s = c.b, 1 - s), N1(e, c.b, "end"), r || (c.b ? u() : --c.group.r || F(c.group.c)), c = null;\r\n        else if (K >= c.start) {\r\n          const W = K - c.start;\r\n          s = c.a + c.d * x(W / c.duration), b(s, 1 - s);\r\n        }\r\n      }\r\n      return !(!c && !r);\r\n    }));\r\n  }\r\n  return { run(p) {\r\n    j1(l) ? (a1 || (a1 = Promise.resolve(), a1.then(() => {\r\n      a1 = null;\r\n    })), a1).then(() => {\r\n      l = l(), a(p);\r\n    }) : a(p);\r\n  }, end() {\r\n    u(), c = r = null;\r\n  } };\r\n}\r\nfunction n1(e, t, n) {\r\n  const o = e.$$.props[t];\r\n  o !== void 0 && (e.$$.bound[o] = n, n(e.$$.ctx[o]));\r\n}\r\nfunction P(e) {\r\n  e && e.c();\r\n}\r\nfunction E(e, t, n, o) {\r\n  const { fragment: l, on_mount: s, on_destroy: c, after_update: r } = e.$$;\r\n  l && l.m(t, n), o || l1(() => {\r\n    const d = s.map(at).filter(j1);\r\n    c ? c.push(...d) : F(d), e.$$.on_mount = [];\r\n  }), r.forEach(l1);\r\n}\r\nfunction N(e, t) {\r\n  const n = e.$$;\r\n  n.fragment !== null && (F(n.on_destroy), n.fragment && n.fragment.d(t), n.on_destroy = n.fragment = null, n.ctx = []);\r\n}\r\nfunction c1(e, t, n, o, l, s, c, r = [-1]) {\r\n  const d = h1;\r\n  m1(e);\r\n  const u = e.$$ = { fragment: null, ctx: null, props: s, update: V, not_equal: l, bound: G1(), on_mount: [], on_destroy: [], on_disconnect: [], before_update: [], after_update: [], context: new Map(t.context || (d ? d.$$.context : [])), callbacks: G1(), dirty: r, skip_bound: !1, root: t.target || d.$$.root };\r\n  c && c(u.root);\r\n  let i = !1;\r\n  if (u.ctx = n ? n(e, t.props || {}, (a, p, ...f) => {\r\n    const C = f.length ? f[0] : p;\r\n    return u.ctx && l(u.ctx[a], u.ctx[a] = C) && (!u.skip_bound && u.bound[a] && u.bound[a](C), i && function(x, b) {\r\n      x.$$.dirty[0] === -1 && (d1.push(x), P1 || (P1 = !0, gt.then(X1)), x.$$.dirty.fill(0)), x.$$.dirty[b / 31 | 0] |= 1 << b % 31;\r\n    }(e, a)), p;\r\n  }) : [], u.update(), i = !0, F(u.before_update), u.fragment = !!o && o(u.ctx), t.target) {\r\n    if (t.hydrate) {\r\n      const a = function(p) {\r\n        return Array.from(p.childNodes);\r\n      }(t.target);\r\n      u.fragment && u.fragment.l(a), a.forEach(w);\r\n    } else\r\n      u.fragment && u.fragment.c();\r\n    t.intro && $(e.$$.fragment), E(e, t.target, t.anchor, t.customElement), X1();\r\n  }\r\n  m1(d);\r\n}\r\nclass r1 {\r\n  $destroy() {\r\n    N(this, 1), this.$destroy = V;\r\n  }\r\n  $on(t, n) {\r\n    const o = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\r\n    return o.push(n), () => {\r\n      const l = o.indexOf(n);\r\n      l !== -1 && o.splice(l, 1);\r\n    };\r\n  }\r\n  $set(t) {\r\n    var n;\r\n    this.$$set && (n = t, Object.keys(n).length !== 0) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);\r\n  }\r\n}\r\nfunction bt(e) {\r\n  let t, n, o, l;\r\n  const s = e[5].default, c = G(s, e, e[4], null);\r\n  return { c() {\r\n    t = g("span"), c && c.c(), h(t, "contenteditable", ""), e[0] === void 0 && l1(() => e[7].call(t));\r\n  }, m(r, d) {\r\n    j(r, t, d), c && c.m(t, null), e[6](t), e[0] !== void 0 && (t.textContent = e[0]), n = !0, o || (l = [R(t, "input", e[7]), R(t, "keydown", e[2]), R(t, "blur", e[2])], o = !0);\r\n  }, p(r, [d]) {\r\n    c && c.p && (!n || 16 & d) && Q(c, s, r, r[4], n ? I(s, r[4], d, null) : J(r[4]), null), 1 & d && r[0] !== t.textContent && (t.textContent = r[0]);\r\n  }, i(r) {\r\n    n || ($(c, r), n = !0);\r\n  }, o(r) {\r\n    y(c, r), n = !1;\r\n  }, d(r) {\r\n    r && w(t), c && c.d(r), e[6](null), o = !1, F(l);\r\n  } };\r\n}\r\nfunction zt(e, t, n) {\r\n  let { $$slots: o = {}, $$scope: l } = t;\r\n  const s = Z1();\r\n  let c, { item: r } = t, { options: d = { singleLine: !0 } } = t;\r\n  return e.$$set = (u) => {\r\n    "item" in u && n(0, r = u.item), "options" in u && n(3, d = u.options), "$$scope" in u && n(4, l = u.$$scope);\r\n  }, e.$$.update = () => {\r\n    1 & e.$$.dirty && r && s("change", { item: r });\r\n  }, [r, c, (u) => {\r\n    u.keyCode === 13 && d.singleLine && (u.preventDefault(), c.blur());\r\n  }, d, l, o, function(u) {\r\n    D[u ? "unshift" : "push"](() => {\r\n      c = u, n(1, c);\r\n    });\r\n  }, function() {\r\n    r = this.textContent, n(0, r);\r\n  }];\r\n}\r\nclass o1 extends r1 {\r\n  constructor(t) {\r\n    super(), c1(this, t, zt, bt, s1, { item: 0, options: 3 });\r\n  }\r\n}\r\nfunction kt(e) {\r\n  let t;\r\n  return { c() {\r\n    t = g("div"), t.innerHTML = \'<svg><symbol id="avatar" class="icon" width="32px" height="32px" viewBox="0 0 752 752"><path d="M105 2a129 129 0 0 0 1 253c11 1 33 2 44 0 26-5 48-16 67-35a126 126 0 0 0 38-114A129 129 0 0 0 150 2c-10-2-35-2-45 0zm31 30c23 4 41 24 45 51l3 9 2 6c0 4-1 6-5 14l-7 15c-3 8-11 19-16 24s-5 7-2 13c5 10 13 16 35 23l16 5-3 4a117 117 0 0 1-151 0l-4-4 4-1 17-6c19-6 27-13 31-25l2-5-4-4c-5-6-12-16-15-23l-7-11c-4-6-7-14-7-18 0-3 3-9 5-9l1-3 2-11c6-26 26-43 50-45l8 1z"></path></symbol><symbol id="address" class="icon" width="32px" height="32px" viewBox="0 0 752 752"><path d="M412 414a111 111 0 0 1 90-77v-40h31c7 0 13-6 13-13v-15c0-5-2-9-7-11L355 153c-4-2-8-2-12 0l-65 37v-13c0-5-4-9-9-9h-29c-5 0-8 4-8 9v39l-74 42c-4 2-7 7-7 11v15c0 7 6 13 13 13h31v180c0 12 9 21 20 21h203c-13-25-15-56-6-84z"></path><path d="M592 412a81 81 0 0 0-109-36 82 82 0 0 0-36 109l61 108c5 9 18 9 23 0l61-108c12-22 12-49 0-73zm-73 72a35 35 0 1 1 0-70 35 35 0 1 1 0 70z"></path></symbol><symbol id="email" class="icon" width="32px" height="32px" viewBox="0 0 752 752"><path d="m582.1 312.4-197.5-128c-4.3-2.8-10-2.8-14.4 0l-199 128c-3.8 2.4-7.8 6.6-7.8 11v230.3c0 7.3 9.3 15.6 16.6 15.6h394.5c7.3 0 14.1-8.3 14.1-15.6V323.4c0-4.4-2.7-8.6-6.4-11zm-385 35.2 113 73.3-113 103zm131.8 88 41.2 26.8a13.2 13.2 0 0 0 14.3 0l41.1-26.8 115 104.7H214zM451.5 421l113-73.3V524zm-74.3-209.8 173.1 112.3-173 112.3-173.1-112.3zm0 200.6c20.7 0 40.9-7.3 56.7-20.6A13.2 13.2 0 0 0 417 371a62 62 0 1 1 22.2-47.5c0 6-4.9 10.9-10.8 10.9a11 11 0 0 1-10.9-10v-.9a40.3 40.3 0 1 0-12.3 29 37 37 0 0 0 60.3-29 88.4 88.4 0 1 0-88.3 88.4zm0-74.3a14 14 0 1 1 0-28 14 14 0 0 1 0 28z"></path></symbol><symbol id="phone" class="icon" width="32px" height="32px" viewBox="0 0 752 752"><path fill-rule="evenodd" d="m587 561-3 3c-96 96-241-7-315-81S92 264 188 168l3-3 107 106-13 14a39 39 0 0 0-5 49 503 503 0 0 0 138 138c16 11 36 9 49-5l14-13zm-92-118 104 103c7-14 4-33-8-45l-51-51a39 39 0 0 0-45-7zM206 153l103 104c7-15 5-33-7-45l-51-51a39 39 0 0 0-45-8z"></path></symbol><symbol id="arrow-left" class="icon" viewBox="0 0 24 24"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></symbol><symbol id="arrow-right" class="icon" viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></symbol><symbol id="arrow-up" class="icon" viewBox="0 0 24 24"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></symbol><symbol id="arrow-down" class="icon" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></symbol><symbol id="check" class="icon" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></symbol><symbol id="close" class="icon" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></symbol><symbol id="download" class="icon" viewBox="0 0 24 24"><path d="M21 15V19A2 2 0 0 1 19 21H5A2 2 0 0 1 3 19V15"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></symbol><symbol id="edit" class="icon" viewBox="0 0 24 24"><path d="M20 14.66V20a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h5.34"></path><polygon points="18 2 22 6 12 16 8 16 8 12 18 2"></polygon></symbol><symbol id="github" class="icon" viewBox="0 0 24 24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 2C6.47715 2 2 6.47715 2 12C2 17.5229 6.47715 22 12 22C17.5229 22 22 17.5229 22 12C22 6.47715 17.5229 2 12 2ZM0 12C0 5.3726 5.3726 0 12 0C18.6274 0 24 5.3726 24 12C24 18.6274 18.6274 24 12 24C5.3726 24 0 18.6274 0 12Z" fill="currentColor" stroke="none"></path><path fill-rule="evenodd" clip-rule="evenodd" d="M9.59162 22.7357C9.49492 22.6109 9.49492 21.4986 9.59162 19.399C8.55572 19.4347 7.90122 19.3628 7.62812 19.1833C7.21852 18.9139 6.80842 18.0833 6.44457 17.4979C6.08072 16.9125 5.27312 16.8199 4.94702 16.6891C4.62091 16.5582 4.53905 16.0247 5.84562 16.4282C7.15222 16.8316 7.21592 17.9303 7.62812 18.1872C8.04032 18.4441 9.02572 18.3317 9.47242 18.1259C9.91907 17.9201 9.88622 17.1538 9.96587 16.8503C10.0666 16.5669 9.71162 16.5041 9.70382 16.5018C9.26777 16.5018 6.97697 16.0036 6.34772 13.7852C5.71852 11.5669 6.52907 10.117 6.96147 9.49369C7.24972 9.07814 7.22422 8.19254 6.88497 6.83679C8.11677 6.67939 9.06732 7.06709 9.73672 7.99999C9.73737 8.00534 10.6143 7.47854 12.0001 7.47854C13.386 7.47854 13.8777 7.90764 14.2571 7.99999C14.6365 8.09234 14.94 6.36699 17.2834 6.83679C16.7942 7.79839 16.3844 8.99999 16.6972 9.49369C17.0099 9.98739 18.2372 11.5573 17.4833 13.7852C16.9807 15.2706 15.9927 16.1761 14.5192 16.5018C14.3502 16.5557 14.2658 16.6427 14.2658 16.7627C14.2658 16.9427 14.4942 16.9624 14.8233 17.8058C15.0426 18.368 15.0585 19.9739 14.8708 22.6234C14.3953 22.7445 14.0254 22.8257 13.7611 22.8673C13.2924 22.9409 12.7835 22.9822 12.2834 22.9982C11.7834 23.0141 11.6098 23.0123 10.9185 22.948C10.4577 22.9051 10.0154 22.8343 9.59162 22.7357Z" fill="currentColor" stroke="none"></path></symbol><symbol id="git-branch" class="icon" viewBox="0 0 24 24"><line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path></symbol><symbol id="log-in" class="icon" viewBox="0 0 24 24"><path d="M15 3H19A2 2 0 0 1 21 5V19A2 2 0 0 1 19 21H15"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line></symbol><symbol id="maximize" class="icon" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></symbol><symbol id="maximize-2" class="icon" viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></symbol><symbol id="menu" class="icon" viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></symbol><symbol id="message-square" class="icon" viewBox="0 0 24 24"><g transform="translate(0, 1)"><path d="M16.5 19H11V15H18V11H22V19H19.5L18 20.5L16.5 19Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M2 3H18V15H8.5L6.5 17L4.5 15H2V3Z" fill="currentColor" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"></path><path d="M6 11H9" stroke="white" stroke-width="1.5" stroke-linecap="round"></path><path d="M6 7H12" stroke="white" stroke-width="1.5" stroke-linecap="round"></path></g></symbol><symbol id="minus" class="icon" viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"></line></symbol><symbol id="plus" class="icon" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></symbol><symbol id="save" class="icon" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></symbol><symbol id="link" class="icon" viewBox="0 0 24 24"><path d="M9,7L6,7A2 2 0 0 0 6,17L9,17"></path><path d="M15,7L18,7A2 2 0 0 1 18,17L15,17"></path><path d="M7,12L17,12"></path></symbol><symbol id="chevron" class="icon" viewBox="0 0 24 24"><path d="M2,7 L12,17 L20,7"></path></symbol><symbol id="delete" class="icon" viewBox="0 0 24 24"><path fill="currentColor" stroke="none" d="M22 4.2h-5.6L15 1.6c-.1-.2-.4-.4-.7-.4H9.6c-.2 0-.5.2-.6.4L7.6 4.2H2c-.4 0-.8.4-.8.8s.4.8.8.8h1.8V22c0 .4.3.8.8.8h15c.4 0 .8-.3.8-.8V5.8H22c.4 0 .8-.3.8-.8s-.4-.8-.8-.8zM10.8 16.5c0 .4-.3.8-.8.8s-.8-.3-.8-.8V10c0-.4.3-.8.8-.8s.8.3.8.8v6.5zm4 0c0 .4-.3.8-.8.8s-.8-.3-.8-.8V10c0-.4.3-.8.8-.8s.8.3.8.8v6.5z"></path></symbol><symbol id="scanQR" class="icon" width="100%" height="100%" viewBox="0 0 760 760"><path d="M684 630c-31-34-9-38-2-84 7-34 13-75-2-123l-34-64c-22-39-51-89-58-117v-2c-6-24-9-43-9-60-2-22-4-35-20-41h-2c-11-3-22-5-33 2V59c0-22-20-41-43-41H205c-25 0-42 19-42 41v49s-29-26-49-30c-5 0-21 2-32 13a44 44 0 0 0-11 43c2 11 31 50 65 69 7 7 15 11 27 15v3h-5c-49 4-69 64-31 94-34 20-34 65-2 87a54 52 0 0 0 38 92v72c0 23 17 62 42 62h89c13 30 25 41 69 50h7c11 4 31 8 47 6l2 2 7 13c6 11 11 22 13 35 2 6 9 11 16 9 6-3 11-9 9-16-3-15-9-28-16-38l-9-13c-2-7-4-9-11-13l-2-2h-9c-11 2-31-3-43-5l-6-2c-32-6-34-4-47-26h160c23 0 43-17 43-41 0 0-20-60-18-86s24-65 24-65l18-30c9-24-4-47-18-78l-9-15c-11-23-20-47-20-75-2-11 5-41 20-63 7-8 16-19 29-17l5 24c0 17 2 39 11 64 7 33 34 82 58 123l33 63c12 41 7 78 0 112-6 45-31 58 9 101 12 5 20-4 18-15zM205 41h276c9 0 18 9 18 18v19H187V59c0-9 7-18 18-18zm-58 143c-18-11-51-48-51-54-3-7-3-17 4-22 5-4 14-4 16-6 4 0 47 30 47 30v58zm11 60a30 29 0 1 1 0 58 30 29 0 0 1 0-58zm0 145a30 29 0 1 1 0-58 30 29 0 0 1 0 58zm-29 54a30 29 0 1 1 60 0 30 29 0 0 1-60 0zm85 0c0-18-9-33-22-41 31-22 31-67-3-87 34-21 34-69-2-88V102h312v62c-15 26-24 59-22 76 0 30 11 58 22 82 31 267-67 211-312 211v-45c16-9 27-26 27-45zm267 161H205c-11 0-18-28-18-38v-9h312v9c0 10-9 38-18 38z"></path><path d="m306 191-2 18v18h5c4 0 4 2 4 3 1 4 0 5-4 5-5 0-5 0-5 10 0 8 0 8 5 8 4 0 5-1 5-5l3-3c5 0 5 0 5 13 2 13 2 13 5 13 4 2 5 0 5-3s2-5 5-5 3 0 3-5 0-5 5-5 5 0 5-3c0-5 0-5-5-5-3 0-5 0-5 5 0 3 0 3-3 3-5 0-5 0-5-18l-1-16-4-2c-3 0-5-1-5-5l-3-3c-3 0-5-2-5-10s-1-8-3-10z"></path><path d="m352 191-2 5c0 3 0 3-8 3-10 0-10 0-10 5 0 3 0 5 5 5 3 0 3 0 3 13v13h18v9c0 9 0 9 5 9h5v-26h10c8 0 8 0 8-5s0-5-8-5c-10 0-10 0-10-5 0-3 0-3-5-3s-5 0-5 3c0 4 2 5 5 5 5 0 5 2 5 5 0 5 0 5-5 5-3 0-5-2-5-5s-1-5-4-5c-4 0-4 0-4-10 0-8 0-8 5-8 3 0 3 0 3-5-1-3-4-6-6-3zm26 2c-1 5 0 6 5 6 3 0 3 0 3-5-1-5-8-6-9-1zm-146 29v31h62v-62h-62Zm54 0v23h-46v-46h46z"></path><path d="M250 222v13h26v-26h-26Zm146 0v31h63v-62h-63zm54 0v23h-46v-46h46z"></path><path d="M414 222v13h27v-26h-27zm-37 15v10l4 6c5 0 5 0 5-8 0-10 0-10-3-10zm-25 18-2 5c0 2 2 3 5 3s3 0 3-5c-1-3-4-6-6-3zm-122 10v10l5 6c5 0 5 2 5 5 0 5 0 5-5 5h-5v26h20v5c0 5 0 5 5 5 3 0 3 0 3-5 0-3-1-5-5-5l-3-3c0-3-1-5-5-5-5 0-5 0-5-10 0-8 0-8 5-8s5 0 5 5c0 12 0 13 5 13 3 0 3 2 3 5s2 3 5 3c5 0 5 0 5-3s-1-5-5-5c-5 0-5 0-5-10v-8h10c8 0 8 0 8 5 0 3 2 3 5 3 5 0 5 0 5 5s0 5-5 5-5 0-5 10c0 8 0 8-3 8s-5 2-5 4c0 4 5 6 13 4 4 0 5-1 5-4 0-2 2-4 5-4s3 2 3 5 2 3 15 3c5 0 5 0 5 5s0 5 5 5c3 0 3 0 3 10 0 8 0 8 5 8h5v-13c2-13 2-13 5-15 2 0 3-1 3-4 0-4 2-4 5-4 5 0 5 0 5 5s8 5 8 0c2-3 2-3 10-5 9 0 9 0 9-5s0-5-10-5c-9 0-9 0-9-3s2-5 5-5c4 0 5-1 5-5 0-3 0-5-5-5-3 0-5-1-5-5 0-1 0-3 5-3 4-1 5-1 5-10 0-8 0-8-5-8h-8c-5 0-5 0-5 8-1 9-1 9-5 10-3 0-5 2-5 5 0 2 0 3-3 3-5 0-5 0-5 5s0 5-5 5c-3 0-5 0-5 3 0 4 0 5-3 5-5 0-5 0-5 5 0 4 0 5 5 5 3 0 3 0 3 4 0 6-8 6-8 1-1-3-1-5-10-5-10 0-10 0-10-5s0-5-3-5-5-1-5-5c0-3 0-3 10-3 8 0 8 0 8 5 0 3 0 3 5 3 7-1 7-6 0-8-5 0-5 0-5-10 0-8 0-8 5-8 4 0 5 2 5 5 0 5 8 5 8 0 0-3 2-5 5-5 4 0 4-1 4-5 1-3 0-3-14-5-13 0-13 0-13-3 0-5 0-5-5-5s-5 0-5 3c0 4 2 5 5 5 5 0 5 2 5 5 0 5 0 5-5 5s-5 0-5-5v-5h-36v-3c0-7-8-7-8-2 0 4-1 5-5 5-5 0-5 0-5-3s2-5 5-5c4 0 5-2 5-5s-1-3-10-5zm64 29c0 5 0 5-3 5s-5 0-5-3 2-5 5-5 3 2 3 5zm56 10c0 4-1 5-5 5-3 0-5 2-5 5 0 2 0 3-3 3s-5 0-5-3 2-5 5-5 3 0 3-5 0-5 5-5c4 0 4 2 4 5z"></path><path d="M268 268c2 3 2 3 13 3 12 0 13 0 13-3v-5h-26Zm74-3c-2 2-2 6 2 6 3 2 6 0 6-3-1-5-6-6-8-3zm35 2c0 3 3 6 6 6l3-6c0-4 0-4-3-4zm29-2c-2 2-2 6 2 6 3 2 6 0 6-3-1-5-6-6-8-3zm16 8c0 8 0 8-4 8s-4 0-4 5c0 4 2 5 5 5 2 0 3-1 3-5 0-5 2-5 5-5 4 0 5 0 5-3 0-5 0-5 10-5 8 0 8 0 8 3 0 4-1 5-5 5-3 0-4 2-4 5 0 4-2 5-5 5-2 0-4 2-4 5s2 3 4 3c3 0 5 2 5 5 0 4 1 5 4 5 4 0 5 2 5 5s2 3 5 3h5v-52l-19-2h-19zm-36 5c0 3 0 3-3 3-5 0-6 2-6 7 3 5 8 3 9-2 0-3 2-5 5-5 4 0 5-1 5-5 0-3 0-3-5-3s-5 0-5 3zm10 26c0 13 0 13 5 13 3 0 3 0 3-13s0-13-3-13c-5 0-5 0-5 13zm28 7-2 3c0 2 2 3 5 3 5 0 5 0 5-5 0-3 0-3-3-3zm-8 8-2 5c0 2 2 3 5 3s3 0 3-5c-1-3-4-6-6-3zm-30 12c0 3-1 4-5 4s-4 2-4 15 0 13-4 13c-5 0-5 0-5 5s0 5-8 5c-10 0-10 0-10 4 0 3 2 4 5 4s3 0 3 5 0 5-3 5-5-1-5-5c0-3-1-5-5-5-3 0-5 2-5 5 0 4-1 5-3 5-3 0-5-1-5-5 0-3-1-5-5-5-3 0-5 2-5 5 0 4-1 5-5 5s-4 8 0 8 5 2 5 5c0 5 0 5-3 5s-5-1-5-5c0-3-1-5-5-5-3 2-3 2-3 10v10h8c7 0 8-1 8-5 0-5 0-5 10-5 8 0 8 0 8 5 2 4 2 4 10 5h8v-10c2-8 2-10 5-10 4 0 5-1 5-4 0-4 2-4 4-4 5 0 5 0 5 8 1 9 1 9 4 10 5 0 5 0 5-8v-10h15c13 0 13 0 13 4 0 3-1 4-5 4-3 0-3 2-3 10v10h54v-10c0-8-1-8-5-8-3 0-5 0-5 3 0 5-1 5-5 5-3 0-4-1-4-5 0-5 0-5 4-5s5 0 5-3 2-5 5-5c4 0 4-1 4-5 0-3 0-3-9-3h-9v16h-10c-9 0-9 0-9-3s-1-5-4-5c-4 0-4 0-4-5 0-3 0-5 4-5 3 0 4 0 4-3 0-5 0-5 19-5l18-1v-7l-18-2c-19 0-19 0-19-3s2-5 5-5c4 0 5-1 5-5 0-5 0-5-5-5-3 0-5-1-5-5-1-3-1-3-9-5-9 0-9 0-9-4s0-4-9-4-9 0-9 4zm28 27v15h-26l-2-15v-13h14l14 2v13zm-37 20c0 3 0 3-4 3-3 0-5 0-5-3s2-5 5-5c4 0 4 2 4 5zm-27 26c0 5 0 5-5 5s-5 0-5-3c0-5 2-7 7-7 2 0 3 2 3 5z"></path><path d="M396 360c0 3 2 3 5 3s3 0 3-3 0-5-3-5-5 2-5 5zm36-28c0 3 2 3 5 3 4 0 4 0 4-3s0-5-4-5c-3 0-5 2-5 5zm-202 5c-1 7 2 8 10 8 9 0 10-1 10-5 0-3-1-3-10-5zm30 0-2 5c0 3 0 3 5 3 4 0 5-1 5-3 0-5-5-8-8-5zm28 0-2 5c0 2 2 3 5 3s3 0 3-5c0-3-4-6-6-3zm54 0c-3 2-2 8 3 8 4 0 5-1 5-3 0-3-1-7-5-7zm108 0v10c2 7 2 7 5 7 4 1 5 0 5-9 0-8-1-8-5-10zm-146 13c2 5 9 7 10 2 0-5-1-7-6-7-4 0-4 0-4 5zm46 0c0 4 2 4 5 4 2 0 3 0 3-4 0-5 0-5-4-5s-4 0-4 5zm-118 36v32h62v-63h-62Zm54 0v23h-46v-46h46z"></path><path d="M250 386v13h26v-26h-26Zm54-13c0 8 0 8 5 8 4-1 4-1 4-9 1-7 0-7-4-9-5 0-5 0-5 10zm36-8c-1 5 2 8 5 8 4 0 5-1 5-5 0-3-1-5-5-5zm-8 13c0 3 2 3 5 3s3 0 3-3 0-5-3-5-5 2-5 5zm90 5c-1 5 2 8 5 8 4 0 5-1 5-5 0-3-1-5-5-5zm-54 31c0 4 2 5 5 5 4 0 4 0 4-5s0-5-5-5c-4 0-4 0-4 5z"></path></symbol></svg>\', p1(t, "display", "none");\r\n  }, m(n, o) {\r\n    j(n, t, o);\r\n  }, p: V, i: V, o: V, d(n) {\r\n    n && w(t);\r\n  } };\r\n}\r\nclass jt extends r1 {\r\n  constructor(t) {\r\n    super(), c1(this, t, null, kt, s1, {});\r\n  }\r\n}\r\nfunction Ct(e) {\r\n  L1(e, "svelte-wxgj7p", ".icon.svelte-wxgj7p{position:relative;overflow:hidden;vertical-align:middle;-o-object-fit:contain;object-fit:contain;transform-origin:center center;stroke:currentColor;stroke-width:1;stroke-linecap:round;stroke-linejoin:round;fill:currentColor}");\r\n}\r\nfunction tt(e) {\r\n  let t, n, o, l, s, c, r;\r\n  const d = e[3].default, u = G(d, e, e[2], null);\r\n  return c = new jt({}), { c() {\r\n    t = C1("svg"), n = C1("use"), l = B(), u && u.c(), s = B(), P(c.$$.fragment), Q1(n, "xlink:href", o = "#" + e[0]), h(t, "width", e[1]), h(t, "height", e[1]), h(t, "class", "icon  svelte-wxgj7p");\r\n  }, m(i, a) {\r\n    j(i, t, a), k(t, n), j(i, l, a), u && u.m(i, a), j(i, s, a), E(c, i, a), r = !0;\r\n  }, p(i, a) {\r\n    (!r || 1 & a && o !== (o = "#" + i[0])) && Q1(n, "xlink:href", o), (!r || 2 & a) && h(t, "width", i[1]), (!r || 2 & a) && h(t, "height", i[1]), u && u.p && (!r || 4 & a) && Q(u, d, i, i[2], r ? I(d, i[2], a, null) : J(i[2]), null);\r\n  }, i(i) {\r\n    r || ($(u, i), $(c.$$.fragment, i), r = !0);\r\n  }, o(i) {\r\n    y(u, i), y(c.$$.fragment, i), r = !1;\r\n  }, d(i) {\r\n    i && w(t), i && w(l), u && u.d(i), i && w(s), N(c, i);\r\n  } };\r\n}\r\nfunction Mt(e) {\r\n  let t, n, o = e[0] && tt(e);\r\n  return { c() {\r\n    o && o.c(), t = S1("");\r\n  }, m(l, s) {\r\n    o && o.m(l, s), j(l, t, s), n = !0;\r\n  }, p(l, [s]) {\r\n    l[0] ? o ? (o.p(l, s), 1 & s && $(o, 1)) : (o = tt(l), o.c(), $(o, 1), o.m(t.parentNode, t)) : o && (R1(), y(o, 1, 1, () => {\r\n      o = null;\r\n    }), O1());\r\n  }, i(l) {\r\n    n || ($(o), n = !0);\r\n  }, o(l) {\r\n    y(o), n = !1;\r\n  }, d(l) {\r\n    o && o.d(l), l && w(t);\r\n  } };\r\n}\r\nfunction Lt(e, t, n) {\r\n  let { $$slots: o = {}, $$scope: l } = t, { name: s } = t, { size: c = "100%" } = t;\r\n  return e.$$set = (r) => {\r\n    "name" in r && n(0, s = r.name), "size" in r && n(1, c = r.size), "$$scope" in r && n(2, l = r.$$scope);\r\n  }, [s, c, l, o];\r\n}\r\nclass _t extends r1 {\r\n  constructor(t) {\r\n    super(), c1(this, t, Lt, Mt, s1, { name: 0, size: 1 }, Ct);\r\n  }\r\n}\r\nfunction Bt(e) {\r\n  L1(e, "svelte-nn8bp4", `.m-2.svelte-nn8bp4{margin:0.5rem\r\n}.flex.svelte-nn8bp4{display:flex\r\n}.h-8.svelte-nn8bp4{height:2rem\r\n}.w-8.svelte-nn8bp4{width:2rem\r\n}.items-center.svelte-nn8bp4{align-items:center\r\n}.justify-center.svelte-nn8bp4{justify-content:center\r\n}.bg-contain.svelte-nn8bp4{background-size:contain\r\n}.bg-no-repeat.svelte-nn8bp4{background-repeat:no-repeat\r\n}.text-center.svelte-nn8bp4{text-align:center\r\n}.align-middle.svelte-nn8bp4{vertical-align:middle\r\n}.text-slate-500.svelte-nn8bp4{--tw-text-opacity:1;color:rgb(100 116 139 / var(--tw-text-opacity))\r\n}`);\r\n}\r\nconst Ht = (e) => ({}), et = (e) => ({});\r\nfunction Et(e) {\r\n  let t, n, o, l, s;\r\n  const c = e[2].first, r = G(c, e, e[1], et), d = r || function(a) {\r\n    let p, f, C;\r\n    return f = new _t({ props: { name: a[0] } }), { c() {\r\n      p = g("div"), P(f.$$.fragment), h(p, "class", "text-slate-500 svelte-nn8bp4");\r\n    }, m(x, b) {\r\n      j(x, p, b), E(f, p, null), C = !0;\r\n    }, p(x, b) {\r\n      const z = {};\r\n      1 & b && (z.name = x[0]), f.$set(z);\r\n    }, i(x) {\r\n      C || ($(f.$$.fragment, x), C = !0);\r\n    }, o(x) {\r\n      y(f.$$.fragment, x), C = !1;\r\n    }, d(x) {\r\n      x && w(p), N(f);\r\n    } };\r\n  }(e), u = e[2].default, i = G(u, e, e[1], null);\r\n  return { c() {\r\n    t = g("div"), n = g("div"), d && d.c(), o = B(), l = g("div"), i && i.c(), h(n, "class", "align-middle w-8 h-8 svelte-nn8bp4"), h(l, "class", "align-middle svelte-nn8bp4"), h(t, "class", "flex align-middle items-center text-center justify-center bg-contain bg-no-repeat m-2 svelte-nn8bp4");\r\n  }, m(a, p) {\r\n    j(a, t, p), k(t, n), d && d.m(n, null), k(t, o), k(t, l), i && i.m(l, null), s = !0;\r\n  }, p(a, [p]) {\r\n    r ? r.p && (!s || 2 & p) && Q(r, c, a, a[1], s ? I(c, a[1], p, Ht) : J(a[1]), et) : d && d.p && (!s || 1 & p) && d.p(a, s ? p : -1), i && i.p && (!s || 2 & p) && Q(i, u, a, a[1], s ? I(u, a[1], p, null) : J(a[1]), null);\r\n  }, i(a) {\r\n    s || ($(d, a), $(i, a), s = !0);\r\n  }, o(a) {\r\n    y(d, a), y(i, a), s = !1;\r\n  }, d(a) {\r\n    a && w(t), d && d.d(a), i && i.d(a);\r\n  } };\r\n}\r\nfunction Nt(e, t, n) {\r\n  let { $$slots: o = {}, $$scope: l } = t, { name: s = null } = t;\r\n  return e.$$set = (c) => {\r\n    "name" in c && n(0, s = c.name), "$$scope" in c && n(1, l = c.$$scope);\r\n  }, [s, l, o];\r\n}\r\nclass f1 extends r1 {\r\n  constructor(t) {\r\n    super(), c1(this, t, Nt, Et, s1, { name: 0 }, Bt);\r\n  }\r\n}\r\nfunction Vt(e) {\r\n  const t = e - 1;\r\n  return t * t * t + 1;\r\n}\r\nfunction nt(e) {\r\n  return --e * e * e * e * e + 1;\r\n}\r\nfunction ot(e, { delay: t = 0, duration: n = 400, easing: o = Vt, x: l = 0, y: s = 0, opacity: c = 0 } = {}) {\r\n  const r = getComputedStyle(e), d = +r.opacity, u = r.transform === "none" ? "" : r.transform, i = d * (1 - c);\r\n  return { delay: t, duration: n, easing: o, css: (a, p) => `\r\n			transform: ${u} translate(${(1 - a) * l}px, ${(1 - a) * s}px);\r\n			opacity: ${d - i * p}` };\r\n}\r\nfunction At(e) {\r\n  L1(e, "svelte-17dj42", `.z-50.svelte-17dj42{z-index:50\r\n}.mx-4.svelte-17dj42{margin-left:1rem;margin-right:1rem\r\n}.mx-1.svelte-17dj42{margin-left:0.25rem;margin-right:0.25rem\r\n}.flex.svelte-17dj42{display:flex\r\n}.h-10.svelte-17dj42{height:2.5rem\r\n}.w-10.svelte-17dj42{width:2.5rem\r\n}.flex-row.svelte-17dj42{flex-direction:row\r\n}.flex-col.svelte-17dj42{flex-direction:column\r\n}.justify-end.svelte-17dj42{justify-content:flex-end\r\n}.rounded-sm.svelte-17dj42{border-radius:0.125rem\r\n}.border.svelte-17dj42{border-width:1px\r\n}.border-slate-300.svelte-17dj42{--tw-border-opacity:1;border-color:rgb(203 213 225 / var(--tw-border-opacity))\r\n}.bg-slate-50.svelte-17dj42{--tw-bg-opacity:1;background-color:rgb(248 250 252 / var(--tw-bg-opacity))\r\n}.p-4.svelte-17dj42{padding:1rem\r\n}.text-left.svelte-17dj42{text-align:left\r\n}.text-sm.svelte-17dj42{font-size:0.875rem;line-height:1.25rem\r\n}.shadow-lg.svelte-17dj42{--tw-shadow:0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)\r\n}`);\r\n}\r\nfunction lt(e) {\r\n  let t, n, o, l, s, c;\r\n  const r = [qt, Pt], d = [];\r\n  function u(i, a) {\r\n    return i[1] ? 1 : 0;\r\n  }\r\n  return o = u(e), l = d[o] = r[o](e), { c() {\r\n    t = g("div"), n = g("div"), l.c(), h(n, "class", "text-left border-slate-300 svelte-17dj42"), h(t, "class", "flex flex-row justify-end z-50 bg-slate-50 border shadow-lg p-4 mx-4 rounded-sm svelte-17dj42");\r\n  }, m(i, a) {\r\n    j(i, t, a), k(t, n), d[o].m(n, null), c = !0;\r\n  }, p(i, a) {\r\n    let p = o;\r\n    o = u(e = i), o === p ? d[o].p(e, a) : (R1(), y(d[p], 1, 1, () => {\r\n      d[p] = null;\r\n    }), O1(), l = d[o], l ? l.p(e, a) : (l = d[o] = r[o](e), l.c()), $(l, 1), l.m(n, null));\r\n  }, i(i) {\r\n    c || ($(l), l1(() => {\r\n      s || (s = Y1(t, ot, { delay: 0, duration: 400, x: 0, y: -100, opacity: 0.1, easing: nt }, !0)), s.run(1);\r\n    }), c = !0);\r\n  }, o(i) {\r\n    y(l), s || (s = Y1(t, ot, { delay: 0, duration: 400, x: 0, y: -100, opacity: 0.1, easing: nt }, !1)), s.run(0), c = !1;\r\n  }, d(i) {\r\n    i && w(t), d[o].d(), i && s && s.end();\r\n  } };\r\n}\r\nfunction Pt(e) {\r\n  let t;\r\n  return { c() {\r\n    t = S1("Requesting access...");\r\n  }, m(n, o) {\r\n    j(n, t, o);\r\n  }, p: V, i: V, o: V, d(n) {\r\n    n && w(t);\r\n  } };\r\n}\r\nfunction qt(e) {\r\n  let t, n, o, l, s, c;\r\n  return o = new f1({ props: { $$slots: { first: [Zt], default: [St] }, $$scope: { ctx: e } } }), s = new f1({ props: { $$slots: { first: [Ot], default: [Rt] }, $$scope: { ctx: e } } }), { c() {\r\n    t = g("span"), t.innerHTML = "Paste the <b>Public Key</b> you want to grant access", n = B(), P(o.$$.fragment), l = B(), P(s.$$.fragment), h(t, "class", "text-sm svelte-17dj42");\r\n  }, m(r, d) {\r\n    j(r, t, d), j(r, n, d), E(o, r, d), j(r, l, d), E(s, r, d), c = !0;\r\n  }, p(r, d) {\r\n    const u = {};\r\n    260 & d && (u.$$scope = { dirty: d, ctx: r }), o.$set(u);\r\n    const i = {};\r\n    256 & d && (i.$$scope = { dirty: d, ctx: r }), s.$set(i);\r\n  }, i(r) {\r\n    c || ($(o.$$.fragment, r), $(s.$$.fragment, r), c = !0);\r\n  }, o(r) {\r\n    y(o.$$.fragment, r), y(s.$$.fragment, r), c = !1;\r\n  }, d(r) {\r\n    r && w(t), r && w(n), N(o, r), r && w(l), N(s, r);\r\n  } };\r\n}\r\nfunction St(e) {\r\n  let t, n, o;\r\n  return { c() {\r\n    t = g("input"), h(t, "type", "text"), h(t, "placeholder", "Their Public Key");\r\n  }, m(l, s) {\r\n    j(l, t, s), J1(t, e[2]), n || (o = [R(t, "input", e[5]), R(t, "keydown", e[4])], n = !0);\r\n  }, p(l, s) {\r\n    4 & s && t.value !== l[2] && J1(t, l[2]);\r\n  }, d(l) {\r\n    l && w(t), n = !1, F(o);\r\n  } };\r\n}\r\nfunction Zt(e) {\r\n  let t;\r\n  return { c() {\r\n    t = g("span"), t.textContent = "Grant Acess:", h(t, "class", "text-sm mx-1 svelte-17dj42");\r\n  }, m(n, o) {\r\n    j(n, t, o);\r\n  }, p: V, d(n) {\r\n    n && w(t);\r\n  } };\r\n}\r\nfunction Rt(e) {\r\n  let t, n, o;\r\n  return { c() {\r\n    t = g("input"), h(t, "type", "text"), h(t, "placeholder", "douganderson444");\r\n  }, m(l, s) {\r\n    j(l, t, s), n || (o = R(t, "keydown", e[4]), n = !0);\r\n  }, p: V, d(l) {\r\n    l && w(t), n = !1, o();\r\n  } };\r\n}\r\nfunction Ot(e) {\r\n  let t, n, o;\r\n  return { c() {\r\n    t = g("input"), n = B(), o = g("span"), o.innerHTML = "Add <b>Contact</b>", h(t, "type", "checkbox"), t.checked = !0, h(o, "class", "text-sm mx-1 svelte-17dj42");\r\n  }, m(l, s) {\r\n    j(l, t, s), j(l, n, s), j(l, o, s);\r\n  }, p: V, d(l) {\r\n    l && w(t), l && w(n), l && w(o);\r\n  } };\r\n}\r\nfunction Tt(e) {\r\n  let t, n, o, l, s, c, r, d, u = e[0] && lt(e);\r\n  return { c() {\r\n    t = g("div"), n = g("div"), o = g("div"), o.innerHTML = \'<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 752 752"><path d="M346.9 153.4c-6.2 0-12.1 5.2-13.7 10.2l-12.4 43.5a176 176 0 0 0-25.2 10.4l-39.5-21.9c-5.3-3-12.7-2-17 2.4l-41 41.1a14.6 14.6 0 0 0-2.4 16.9l22 39.6a171 171 0 0 0-10.4 25l-43.5 12.5c-6 1.7-10.4 7.6-10.4 13.8v58.3c0 6 4.5 12 10.4 13.6L207 431c2.9 8.7 6.5 17 10.5 25.1L195.7 496a14.7 14.7 0 0 0 2.4 16.9l41 41.1a14.6 14.6 0 0 0 17 2.4l39.5-22c8.1 4.2 16.5 7.7 25.2 10.6l12.4 43.3a14.6 14.6 0 0 0 13.7 10.4h58.3c6 0 12-4.5 13.6-10.4l12.4-43.3c8.7-2.9 17.1-6.4 25.2-10.5l39.5 21.9c5.3 3 12.7 2 17-2.4l41-41.1a14.6 14.6 0 0 0 2.4-17l-22-39.6c4.2-8 7.7-16.4 10.6-25.1l43.3-12.3a14.6 14.6 0 0 0 10.4-13.6V347c0-6.2-4.4-12.1-10.4-13.8l-43.5-12.4c-2.8-8.7-6.3-17-10.3-25l21.9-39.7a14.7 14.7 0 0 0-2.4-16.9l-41-41.1a14.6 14.6 0 0 0-17-2.4l-39.5 21.9c-8-4.1-16.5-7.5-25.2-10.4l-12.4-43.5a14.6 14.6 0 0 0-13.6-10.2zm10.6 28.4h37L406 222c1.3 4.7 5.2 8.7 10 10 11.9 3.2 23.2 8 33.8 14 4.2 2.4 9.7 2.5 14 .2l36.6-20.5 26 26-20.4 36.6a14.5 14.5 0 0 0 0 14c6.1 10.6 11 22 14.3 34a14 14 0 0 0 9.7 9.9l40.3 11.4v36.9L530 406a14.5 14.5 0 0 0-9.7 9.8 149 149 0 0 1-14.3 34 14.5 14.5 0 0 0 0 14l20.5 36.6-26 26-36.8-20.5a14.5 14.5 0 0 0-13.9.1c-10.6 6-22 11-33.9 14.2a14.5 14.5 0 0 0-9.9 9.8l-11.4 40.3h-37L346.2 530a14.5 14.5 0 0 0-9.9-9.8c-12-3.3-23.3-8.1-33.9-14.2a14.5 14.5 0 0 0-13.9-.1l-36.7 20.4-26-25.9 20.4-36.7c2.3-4.2 2.3-9.7 0-13.9-6-10.6-11-22-14.2-34a14.5 14.5 0 0 0-9.8-9.8l-40.3-11.5v-36.9l40.3-11.4c4.6-1.3 8.5-5.2 9.8-10a149 149 0 0 1 14.2-34c2.3-4.2 2.3-9.6 0-13.9l-20.5-36.5 26-26 36.8 20.4c4.2 2.3 9.7 2.2 14-.2a146 146 0 0 1 33.8-14 15 15 0 0 0 10-10zm18.5 90c-57.4 0-104.2 46.8-104.2 104.2S318.6 480.2 376 480.2c57.4 0 104.2-46.8 104.2-104.2S433.4 271.8 376 271.8zm0 28.4c42 0 75.8 33.8 75.8 75.8S418 451.8 376 451.8 300.2 418 300.2 376s33.8-75.8 75.8-75.8z"></path></svg>\', l = B(), u && u.c(), h(o, "class", "w-10 h-10 svelte-17dj42"), h(n, "class", "flex flex-row justify-end svelte-17dj42"), h(t, "class", "flex flex-col svelte-17dj42");\r\n  }, m(i, a) {\r\n    var p;\r\n    j(i, t, a), k(t, n), k(n, o), k(t, l), u && u.m(t, null), c = !0, r || (d = [R(o, "click", e[3]), R(o, "keypress", e[3]), (p = s = Dt.call(null, t, { enabled: e[0], cb: e[6] }), p && j1(p.destroy) ? p.destroy : V)], r = !0);\r\n  }, p(i, [a]) {\r\n    i[0] ? u ? (u.p(i, a), 1 & a && $(u, 1)) : (u = lt(i), u.c(), $(u, 1), u.m(t, null)) : u && (R1(), y(u, 1, 1, () => {\r\n      u = null;\r\n    }), O1()), s && j1(s.update) && 3 & a && s.update.call(null, { enabled: i[0], cb: i[6] });\r\n  }, i(i) {\r\n    c || ($(u), c = !0);\r\n  }, o(i) {\r\n    y(u), c = !1;\r\n  }, d(i) {\r\n    i && w(t), u && u.d(), r = !1, F(d);\r\n  } };\r\n}\r\nfunction Dt(e, { enabled: t, cb: n }) {\r\n  const o = ({ target: s }) => {\r\n    e.contains(s) || n();\r\n  };\r\n  function l({ enabled: s }) {\r\n    s ? window.addEventListener("click", o) : window.removeEventListener("click", o);\r\n  }\r\n  return l({ enabled: t }), { update: l, destroy() {\r\n    window.removeEventListener("click", o);\r\n  } };\r\n}\r\nfunction Ft(e, t, n) {\r\n  const o = Z1();\r\n  let l, s, c = !1;\r\n  return [c, l, s, function(r) {\r\n    n(0, c = !c);\r\n  }, function(r) {\r\n    r.code === "Enter" && (n(1, l = !0), o("change", { targetPublicKey: s }));\r\n  }, function() {\r\n    s = this.value, n(2, s);\r\n  }, () => {\r\n    n(0, c = !1), n(1, l = !1);\r\n  }];\r\n}\r\nclass Kt extends r1 {\r\n  constructor(t) {\r\n    super(), c1(this, t, Ft, Tt, s1, {}, At);\r\n  }\r\n}\r\nfunction Ut(e) {\r\n  L1(e, "svelte-1r987x6", `.absolute.svelte-1r987x6{position:absolute\r\n}.relative.svelte-1r987x6{position:relative\r\n}.z-10.svelte-1r987x6{z-index:10\r\n}.m-auto.svelte-1r987x6{margin:auto\r\n}.my-2.svelte-1r987x6{margin-top:0.5rem;margin-bottom:0.5rem\r\n}.mx-auto.svelte-1r987x6{margin-left:auto;margin-right:auto\r\n}.mx-2.svelte-1r987x6{margin-left:0.5rem;margin-right:0.5rem\r\n}.-mt-20.svelte-1r987x6{margin-top:-5rem\r\n}.mt-5.svelte-1r987x6{margin-top:1.25rem\r\n}.mb-7.svelte-1r987x6{margin-bottom:1.75rem\r\n}.flex.svelte-1r987x6{display:flex\r\n}.h-24.svelte-1r987x6{height:6rem\r\n}.h-32.svelte-1r987x6{height:8rem\r\n}.w-full.svelte-1r987x6{width:100%\r\n}.w-32.svelte-1r987x6{width:8rem\r\n}.max-w-lg.svelte-1r987x6{max-width:32rem\r\n}.max-w-none.svelte-1r987x6{max-width:none\r\n}.flex-none.svelte-1r987x6{flex:none\r\n}.items-center.svelte-1r987x6{align-items:center\r\n}.justify-center.svelte-1r987x6{justify-content:center\r\n}.overflow-hidden.svelte-1r987x6{overflow:hidden\r\n}.rounded-2xl.svelte-1r987x6{border-radius:1rem\r\n}.rounded-full.svelte-1r987x6{border-radius:9999px\r\n}.bg-slate-100.svelte-1r987x6{--tw-bg-opacity:1;background-color:rgb(241 245 249 / var(--tw-bg-opacity))\r\n}.bg-white.svelte-1r987x6{--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity))\r\n}.bg-green-400.svelte-1r987x6{--tw-bg-opacity:1;background-color:rgb(74 222 128 / var(--tw-bg-opacity))\r\n}.fill-slate-500.svelte-1r987x6{fill:#64748b\r\n}.object-cover.svelte-1r987x6{-o-object-fit:cover;object-fit:cover\r\n}.px-3.svelte-1r987x6{padding-left:0.75rem;padding-right:0.75rem\r\n}.text-center.svelte-1r987x6{text-align:center\r\n}.text-xl.svelte-1r987x6{font-size:1.25rem;line-height:1.75rem\r\n}.text-base.svelte-1r987x6{font-size:1rem;line-height:1.5rem\r\n}.text-neutral-800.svelte-1r987x6{--tw-text-opacity:1;color:rgb(38 38 38 / var(--tw-text-opacity))\r\n}.text-sky-500.svelte-1r987x6{--tw-text-opacity:1;color:rgb(14 165 233 / var(--tw-text-opacity))\r\n}.text-white.svelte-1r987x6{--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))\r\n}.shadow-xl.svelte-1r987x6{--tw-shadow:0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)\r\n}.drop-shadow-xl.svelte-1r987x6{--tw-drop-shadow:drop-shadow(0 20px 13px rgb(0 0 0 / 0.03)) drop-shadow(0 8px 5px rgb(0 0 0 / 0.08));filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)\r\n}`);\r\n}\r\nconst Gt = (e) => ({}), st = (e) => ({}), It = (e) => ({}), ct = (e) => ({}), Qt = (e) => ({}), rt = (e) => ({}), Jt = (e) => ({}), it = (e) => ({});\r\nfunction Wt(e) {\r\n  let t, n, o;\r\n  return { c() {\r\n    t = g("div"), n = g("img"), h(n, "class", "rounded-full bg-white absolute max-w-none object-cover svelte-1r987x6"), I1(n.src, o = e[0].avatar) || h(n, "src", o), h(n, "alt", "d"), p1(n, "width", "100%"), p1(n, "height", "100%"), p1(n, "transform-origin", "50% 50% 0px"), h(t, "class", "relative z-10 overflow-hidden flex-none mx-auto w-32 h-32 drop-shadow-xl svelte-1r987x6");\r\n  }, m(l, s) {\r\n    j(l, t, s), k(t, n);\r\n  }, p(l, s) {\r\n    1 & s && !I1(n.src, o = l[0].avatar) && h(n, "src", o);\r\n  }, d(l) {\r\n    l && w(t);\r\n  } };\r\n}\r\nfunction Xt(e) {\r\n  let t, n;\r\n  return { c() {\r\n    t = C1("svg"), n = C1("path"), h(n, "d", "M105 2a129 129 0 0 0 1 253c11 1 33 2 44 0 26-5 48-16 67-35a126 126 0 0 0 38-114A129 129 0 0 0 150 2c-10-2-35-2-45 0zm31 30c23 4 41 24 45 51l3 9 2 6c0 4-1 6-5 14l-7 15c-3 8-11 19-16 24s-5 7-2 13c5 10 13 16 35 23l16 5-3 4a117 117 0 0 1-151 0l-4-4 4-1 17-6c19-6 27-13 31-25l2-5-4-4c-5-6-12-16-15-23l-7-11c-4-6-7-14-7-18 0-3 3-9 5-9l1-3 2-11c6-26 26-43 50-45l8 1z"), h(t, "class", "rounded-full bg-white shadow-xl drop-shadow-xl svelte-1r987x6"), h(t, "xmlns", "http://www.w3.org/2000/svg"), h(t, "version", "1.0"), h(t, "viewBox", "0 0 256 256");\r\n  }, m(o, l) {\r\n    j(o, t, l), k(t, n);\r\n  }, p: V, d(o) {\r\n    o && w(t);\r\n  } };\r\n}\r\nfunction Yt(e) {\r\n  let t;\r\n  const n = e[3].address, o = G(n, e, e[15], rt), l = o || function(s) {\r\n    let c, r, d;\r\n    function u(a) {\r\n      s[11](a);\r\n    }\r\n    let i = {};\r\n    return s[0].address !== void 0 && (i.item = s[0].address), c = new o1({ props: i }), D.push(() => n1(c, "item", u)), { c() {\r\n      P(c.$$.fragment);\r\n    }, m(a, p) {\r\n      E(c, a, p), d = !0;\r\n    }, p(a, p) {\r\n      const f = {};\r\n      !r && 1 & p && (r = !0, f.item = a[0].address, e1(() => r = !1)), c.$set(f);\r\n    }, i(a) {\r\n      d || ($(c.$$.fragment, a), d = !0);\r\n    }, o(a) {\r\n      y(c.$$.fragment, a), d = !1;\r\n    }, d(a) {\r\n      N(c, a);\r\n    } };\r\n  }(e);\r\n  return { c() {\r\n    l && l.c();\r\n  }, m(s, c) {\r\n    l && l.m(s, c), t = !0;\r\n  }, p(s, c) {\r\n    o ? o.p && (!t || 32768 & c) && Q(o, n, s, s[15], t ? I(n, s[15], c, Qt) : J(s[15]), rt) : l && l.p && (!t || 1 & c) && l.p(s, t ? c : -1);\r\n  }, i(s) {\r\n    t || ($(l, s), t = !0);\r\n  }, o(s) {\r\n    y(l, s), t = !1;\r\n  }, d(s) {\r\n    l && l.d(s);\r\n  } };\r\n}\r\nfunction t0(e) {\r\n  let t;\r\n  const n = e[3].email, o = G(n, e, e[15], ct), l = o || function(s) {\r\n    let c, r, d;\r\n    function u(a) {\r\n      s[12](a);\r\n    }\r\n    let i = {};\r\n    return s[0].email !== void 0 && (i.item = s[0].email), c = new o1({ props: i }), D.push(() => n1(c, "item", u)), { c() {\r\n      P(c.$$.fragment);\r\n    }, m(a, p) {\r\n      E(c, a, p), d = !0;\r\n    }, p(a, p) {\r\n      const f = {};\r\n      !r && 1 & p && (r = !0, f.item = a[0].email, e1(() => r = !1)), c.$set(f);\r\n    }, i(a) {\r\n      d || ($(c.$$.fragment, a), d = !0);\r\n    }, o(a) {\r\n      y(c.$$.fragment, a), d = !1;\r\n    }, d(a) {\r\n      N(c, a);\r\n    } };\r\n  }(e);\r\n  return { c() {\r\n    l && l.c();\r\n  }, m(s, c) {\r\n    l && l.m(s, c), t = !0;\r\n  }, p(s, c) {\r\n    o ? o.p && (!t || 32768 & c) && Q(o, n, s, s[15], t ? I(n, s[15], c, It) : J(s[15]), ct) : l && l.p && (!t || 1 & c) && l.p(s, t ? c : -1);\r\n  }, i(s) {\r\n    t || ($(l, s), t = !0);\r\n  }, o(s) {\r\n    y(l, s), t = !1;\r\n  }, d(s) {\r\n    l && l.d(s);\r\n  } };\r\n}\r\nfunction e0(e) {\r\n  let t;\r\n  const n = e[3].phone, o = G(n, e, e[15], st), l = o || function(s) {\r\n    let c, r, d;\r\n    function u(a) {\r\n      s[13](a);\r\n    }\r\n    let i = {};\r\n    return s[0].phone !== void 0 && (i.item = s[0].phone), c = new o1({ props: i }), D.push(() => n1(c, "item", u)), { c() {\r\n      P(c.$$.fragment);\r\n    }, m(a, p) {\r\n      E(c, a, p), d = !0;\r\n    }, p(a, p) {\r\n      const f = {};\r\n      !r && 1 & p && (r = !0, f.item = a[0].phone, e1(() => r = !1)), c.$set(f);\r\n    }, i(a) {\r\n      d || ($(c.$$.fragment, a), d = !0);\r\n    }, o(a) {\r\n      y(c.$$.fragment, a), d = !1;\r\n    }, d(a) {\r\n      N(c, a);\r\n    } };\r\n  }(e);\r\n  return { c() {\r\n    l && l.c();\r\n  }, m(s, c) {\r\n    l && l.m(s, c), t = !0;\r\n  }, p(s, c) {\r\n    o ? o.p && (!t || 32768 & c) && Q(o, n, s, s[15], t ? I(n, s[15], c, Gt) : J(s[15]), st) : l && l.p && (!t || 1 & c) && l.p(s, t ? c : -1);\r\n  }, i(s) {\r\n    t || ($(l, s), t = !0);\r\n  }, o(s) {\r\n    y(l, s), t = !1;\r\n  }, d(s) {\r\n    l && l.d(s);\r\n  } };\r\n}\r\nfunction n0(e) {\r\n  let t, n, o, l, s, c, r, d, u, i, a, p, f, C, x, b, z, L, K, W, A, _1, T1;\r\n  function D1(m, v) {\r\n    return m[0].avatar ? Wt : Xt;\r\n  }\r\n  o = new Kt({}), o.$on("change", e[4]);\r\n  let v1 = D1(e), O = v1(e);\r\n  const B1 = e[3].name, x1 = G(B1, e, e[15], it), S = x1 || function(m) {\r\n    let v, H, T, _, i1, X;\r\n    function q(M) {\r\n      m[9](M);\r\n    }\r\n    let Y = {};\r\n    function g1(M) {\r\n      m[10](M);\r\n    }\r\n    m[0].firstName !== void 0 && (Y.item = m[0].firstName), v = new o1({ props: Y }), D.push(() => n1(v, "item", q));\r\n    let F1 = {};\r\n    return m[0].lastName !== void 0 && (F1.item = m[0].lastName), _ = new o1({ props: F1 }), D.push(() => n1(_, "item", g1)), { c() {\r\n      P(v.$$.fragment), T = B(), P(_.$$.fragment);\r\n    }, m(M, t1) {\r\n      E(v, M, t1), j(M, T, t1), E(_, M, t1), X = !0;\r\n    }, p(M, t1) {\r\n      const K1 = {};\r\n      !H && 1 & t1 && (H = !0, K1.item = M[0].firstName, e1(() => H = !1)), v.$set(K1);\r\n      const U1 = {};\r\n      !i1 && 1 & t1 && (i1 = !0, U1.item = M[0].lastName, e1(() => i1 = !1)), _.$set(U1);\r\n    }, i(M) {\r\n      X || ($(v.$$.fragment, M), $(_.$$.fragment, M), X = !0);\r\n    }, o(M) {\r\n      y(v.$$.fragment, M), y(_.$$.fragment, M), X = !1;\r\n    }, d(M) {\r\n      N(v, M), M && w(T), N(_, M);\r\n    } };\r\n  }(e);\r\n  a = new f1({ props: { name: "address", $$slots: { default: [Yt] }, $$scope: { ctx: e } } }), f = new f1({ props: { name: "email", $$slots: { default: [t0] }, $$scope: { ctx: e } } }), x = new f1({ props: { name: "phone", $$slots: { default: [e0] }, $$scope: { ctx: e } } });\r\n  const H1 = e[3].default, $1 = G(H1, e, e[15], null), Z = $1 || function(m) {\r\n    let v, H, T, _;\r\n    function i1(q) {\r\n      m[14](q);\r\n    }\r\n    let X = { options: { singleLine: !1 } };\r\n    return m[0].notes !== void 0 && (X.item = m[0].notes), H = new o1({ props: X }), D.push(() => n1(H, "item", i1)), { c() {\r\n      v = g("span"), P(H.$$.fragment), h(v, "class", "text-sky-500 svelte-1r987x6");\r\n    }, m(q, Y) {\r\n      j(q, v, Y), E(H, v, null), _ = !0;\r\n    }, p(q, Y) {\r\n      const g1 = {};\r\n      !T && 1 & Y && (T = !0, g1.item = q[0].notes, e1(() => T = !1)), H.$set(g1);\r\n    }, i(q) {\r\n      _ || ($(H.$$.fragment, q), _ = !0);\r\n    }, o(q) {\r\n      y(H.$$.fragment, q), _ = !1;\r\n    }, d(q) {\r\n      q && w(v), N(H);\r\n    } };\r\n  }(e);\r\n  return { c() {\r\n    t = g("div"), n = g("div"), P(o.$$.fragment), l = B(), s = g("input"), c = B(), r = g("div"), O.c(), d = B(), u = g("div"), S && S.c(), i = B(), P(a.$$.fragment), p = B(), P(f.$$.fragment), C = B(), P(x.$$.fragment), b = B(), z = g("blockquote"), L = g("p"), Z && Z.c(), K = B(), W = g("footer"), W.textContent = "Powered by PeerPiper", h(n, "class", "h-24 bg-white svelte-1r987x6"), p1(s, "display", "none"), h(s, "type", "file"), h(s, "accept", ".jpg, .jpeg, .png"), h(r, "class", "-mt-20 h-32 flex justify-center svelte-1r987x6"), h(u, "class", "mt-5 mb-7 px-3 text-center text-xl svelte-1r987x6"), h(L, "class", "mx-2 mb-7 text-center text-base svelte-1r987x6"), h(W, "class", "text-center bg-green-400 text-white svelte-1r987x6"), h(t, "class", "m-auto text-neutral-800 fill-slate-500 my-2 w-full max-w-lg items-center justify-center overflow-hidden rounded-2xl bg-slate-100 shadow-xl svelte-1r987x6");\r\n  }, m(m, v) {\r\n    j(m, t, v), k(t, n), E(o, n, null), k(t, l), k(t, s), e[6](s), k(t, c), k(t, r), O.m(r, null), k(t, d), k(t, u), S && S.m(u, null), k(t, i), E(a, t, null), k(t, p), E(f, t, null), k(t, C), E(x, t, null), k(t, b), k(t, z), k(z, L), Z && Z.m(L, null), k(t, K), k(t, W), A = !0, _1 || (T1 = [R(s, "change", e[5]), R(r, "keypress", e[7]), R(r, "click", e[8])], _1 = !0);\r\n  }, p(m, [v]) {\r\n    v1 === (v1 = D1(m)) && O ? O.p(m, v) : (O.d(1), O = v1(m), O && (O.c(), O.m(r, null))), x1 ? x1.p && (!A || 32768 & v) && Q(x1, B1, m, m[15], A ? I(B1, m[15], v, Jt) : J(m[15]), it) : S && S.p && (!A || 1 & v) && S.p(m, A ? v : -1);\r\n    const H = {};\r\n    32769 & v && (H.$$scope = { dirty: v, ctx: m }), a.$set(H);\r\n    const T = {};\r\n    32769 & v && (T.$$scope = { dirty: v, ctx: m }), f.$set(T);\r\n    const _ = {};\r\n    32769 & v && (_.$$scope = { dirty: v, ctx: m }), x.$set(_), $1 ? $1.p && (!A || 32768 & v) && Q($1, H1, m, m[15], A ? I(H1, m[15], v, null) : J(m[15]), null) : Z && Z.p && (!A || 1 & v) && Z.p(m, A ? v : -1);\r\n  }, i(m) {\r\n    A || ($(o.$$.fragment, m), $(S, m), $(a.$$.fragment, m), $(f.$$.fragment, m), $(x.$$.fragment, m), $(Z, m), A = !0);\r\n  }, o(m) {\r\n    y(o.$$.fragment, m), y(S, m), y(a.$$.fragment, m), y(f.$$.fragment, m), y(x.$$.fragment, m), y(Z, m), A = !1;\r\n  }, d(m) {\r\n    m && w(t), N(o), e[6](null), O.d(), S && S.d(m), N(a), N(f), N(x), Z && Z.d(m), _1 = !1, F(T1);\r\n  } };\r\n}\r\nfunction o0(e, t, n) {\r\n  let { $$slots: o = {}, $$scope: l } = t;\r\n  const s = Z1();\r\n  let c, r = { firstName: "FirstName", lastName: "Lastname", address: "Unknown address", email: "Unknown email", phone: "No phone", notes: "No notes", avatar: null }, { profile: d = r } = t;\r\n  const u = (i) => {\r\n    let a = i.target.files[0], p = new FileReader();\r\n    p.readAsDataURL(a), p.onload = (f) => {\r\n      n(0, d.avatar = f.target.result, d);\r\n    };\r\n  };\r\n  return e.$$set = (i) => {\r\n    "profile" in i && n(0, d = i.profile), "$$scope" in i && n(15, l = i.$$scope);\r\n  }, e.$$.update = () => {\r\n    1 & e.$$.dirty && d && (n(0, d = Object.assign({}, r, d)), s("change", { profile: d }));\r\n  }, [d, c, u, o, function(i) {\r\n    $t.call(this, e, i);\r\n  }, (i) => u(i), function(i) {\r\n    D[i ? "unshift" : "push"](() => {\r\n      c = i, n(1, c);\r\n    });\r\n  }, () => {\r\n    c.click();\r\n  }, () => {\r\n    c.click();\r\n  }, function(i) {\r\n    e.$$.not_equal(d.firstName, i) && (d.firstName = i, n(0, d), n(17, r));\r\n  }, function(i) {\r\n    e.$$.not_equal(d.lastName, i) && (d.lastName = i, n(0, d), n(17, r));\r\n  }, function(i) {\r\n    e.$$.not_equal(d.address, i) && (d.address = i, n(0, d), n(17, r));\r\n  }, function(i) {\r\n    e.$$.not_equal(d.email, i) && (d.email = i, n(0, d), n(17, r));\r\n  }, function(i) {\r\n    e.$$.not_equal(d.phone, i) && (d.phone = i, n(0, d), n(17, r));\r\n  }, function(i) {\r\n    e.$$.not_equal(d.notes, i) && (d.notes = i, n(0, d), n(17, r));\r\n  }, l];\r\n}\r\nclass l0 extends r1 {\r\n  constructor(t) {\r\n    super(), c1(this, t, o0, n0, s1, { profile: 0 }, Ut);\r\n  }\r\n}\r\nexport {\r\n  l0 as default\r\n};\r\n';
let dag;
let p2pcf;
const defaultOptions = {
  stateHeartbeatWindowMs: 9e4,
  fastPollingRateMs: 1e3,
  slowPollingRateMs: 6e4,
  workerUrl: "https://p2pcf.douganderson444.workers.dev"
};
const connect = ({
  username = "user-" + Math.floor(Math.random() * 1e5),
  topic = "peerpiper",
  options = defaultOptions,
  handleConnect = () => {
  },
  handleClose = () => {
  },
  handleMsg = () => {
  }
}) => {
  p2pcf = new P2PCF(username, topic, options);
  window.p2pcf = p2pcf;
  p2pcf.on("peerconnect", handleConnect);
  p2pcf.on("peerclose", handleClose);
  p2pcf.on("msg", handleMsg);
};
const disconnect = () => {
  p2pcf.destroy();
  console.log("Disconnected.");
};
const createDag = async ({ persist } = { persist: true }) => {
  if (!dag && !globalThis.dag) {
    dag = await createDagRepo({ persist });
    globalThis.dag = dag;
  } else {
    dag = globalThis.dag;
  }
  return dag;
};
const createContactCard = async (dag2) => {
  const tag = "ContactCard";
  const contactCardCid = await dag2.tx.addData({ value: contactCard });
  console.log("contactCardCid", contactCardCid.toString());
  const tagNode = {
    compiled: contactCardCid
  };
  const rootCID = await dag2.tx.addTag(tag, tagNode);
  const buffer2 = await dag2.tx.commit();
  console.log({ buffer: buffer2 });
  return rootCID;
};
export {
  connect,
  createContactCard,
  createDag,
  disconnect
};
//# sourceMappingURL=lib-cc382c34.js.map
